
@article{xie_generalized_2021,
	title = {Generalized evidence passing for effect handlers},
	journal = {Microsoft Research. Extended version with proofs},
	author = {Xie, Ningning and Leijen, Daan},
	year = {2021},
	keywords = {to-read},
	file = {Xie_Leijen_2021_Generalized evidence passing for effect handlers.pdf:/home/tim/Zotero/storage/VPJQQIUE/Xie_Leijen_2021_Generalized evidence passing for effect handlers.pdf:application/pdf;Xie_Leijen_2021_Generalized evidence passing for effect handlers2.pdf:/home/tim/Zotero/storage/F7LSKAZN/Xie_Leijen_2021_Generalized evidence passing for effect handlers2.pdf:application/pdf;Xie_Leijen_2021_Generalized evidence passing for effect handlers3.pdf:/home/tim/Zotero/storage/VL7BN5WC/Xie_Leijen_2021_Generalized evidence passing for effect handlers3.pdf:application/pdf},
}

@inproceedings{leijen_first_2018,
	title = {First class dynamic effect handlers: {Or}, polymorphic heaps with dynamic effect handlers},
	booktitle = {Proceedings of the 3rd {ACM} {SIGPLAN} {International} {Workshop} on {Type}-{Driven} {Development}},
	author = {Leijen, Daan},
	year = {2018},
	keywords = {to-read},
	pages = {51--64},
	file = {Leijen - 2018 - First class dynamic effect handlers Or, polymorph.pdf:/home/tim/Zotero/storage/CNAZMVHK/Leijen - 2018 - First class dynamic effect handlers Or, polymorph.pdf:application/pdf},
}

@article{biernacki_logical_nodate,
	title = {Logical {Relations} for {Algebraic} {Effects}},
	author = {Biernacki, Dariusz and Pir√≥g, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	keywords = {to-read},
}

@techreport{leijen_algebraic_2016,
	title = {Algebraic effects for functional programming},
	institution = {Technical Report. MSR-TR-2016-29. Microsoft Research technical report},
	author = {Leijen, Daan},
	year = {2016},
	keywords = {to-read},
	file = {Leijen - 2016 - Algebraic effects for functional programming.pdf:/home/tim/Zotero/storage/LH729TCN/Leijen - 2016 - Algebraic effects for functional programming.pdf:application/pdf},
}

@article{crandall_when_2020,
	title = {When autonomous agents model other agents: {An} appeal for altered judgment coupled with mouths, ears, and a little more tape},
	volume = {280},
	journal = {Artificial Intelligence},
	author = {Crandall, Jacob W},
	year = {2020},
	note = {Publisher: Elsevier},
	pages = {103219},
	file = {Crandall - 2020 - When autonomous agents model other agents An appe.pdf:/home/tim/Zotero/storage/HXXN3259/Crandall - 2020 - When autonomous agents model other agents An appe.pdf:application/pdf},
}

@inproceedings{baumeister_towards_2020,
	title = {Towards reality: smoothed analysis in computational social choice},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {Multiagent} {Systems}},
	author = {Baumeister, Dorothea and Hogrebe, Tobias and Rothe, J√∂rg},
	year = {2020},
	pages = {1691--1695},
}

@inproceedings{jensen_towards_2022,
	title = {Towards {Efficient} {Context}-{Sensitive} {Deliberation}},
	booktitle = {Advances in {Social} {Simulation}: {Proceedings} of the 16th {Social} {Simulation} {Conference}, 20‚Äì24 {September} 2021},
	publisher = {Springer International Publishing Cham},
	author = {Jensen, Maarten and Verhagen, Harko and Vanh√©e, Lo√Øs and Dignum, Frank},
	year = {2022},
	pages = {409--421},
}

@book{robinson_topology_2005,
	title = {The topology of the 2x2 games: a new periodic table},
	volume = {3},
	publisher = {Psychology Press},
	author = {Robinson, David and Goforth, David},
	year = {2005},
}

@inproceedings{was_manipulability_2020,
	title = {The manipulability of centrality measures-an axiomatic approach},
	booktitle = {Proceedings of the 19th international conference on autonomous agents and multiagent systems},
	author = {WƒÖs, Tomasz and Waniek, Marcin and Rahwan, Talal and Michalak, Tomasz},
	year = {2020},
	pages = {1467--1475},
}

@misc{dignum_alignment_2021,
	title = {The {Alignment} {Problem}: {Machine} {Learning} and {Human} {Values}},
	publisher = {NATURE PORTFOLIO HEIDELBERGER PLATZ 3, BERLIN, 14197, GERMANY},
	author = {Dignum, Virginia and Christian, B},
	year = {2021},
}

@inproceedings{lobo_socially_2022,
	title = {Socially {Aware} {Interactions}: {From} {Dialogue} {Trees} to {Natural} {Language} {Dialogue} {Systems}},
	booktitle = {Chatbot {Research} and {Design}: 5th {International} {Workshop}, {CONVERSATIONS} 2021, {Virtual} {Event}, {November} 23‚Äì24, 2021, {Revised} {Selected} {Papers}},
	publisher = {Springer International Publishing Cham},
	author = {Lobo, In√™s and Rato, Diogo and Prada, Rui and Dignum, Frank},
	year = {2022},
	pages = {124--140},
}

@inproceedings{malekzadeh_social_2011,
	title = {Social balance and signed network formation games},
	booktitle = {Proceedings of {KDD} workshop on {Social} {Network} {Analysis} ({SNA}-{KDD}), to appear},
	author = {Malekzadeh, Mohammad and Fazli, M and Khalilabadi, P Jalali and Rabiee, H and Safari, M},
	year = {2011},
}

@article{cisneros-velarde_signed_2020,
	title = {Signed network formation games and clustering balance},
	volume = {10},
	number = {4},
	journal = {Dynamic Games and Applications},
	author = {Cisneros-Velarde, Pedro and Bullo, Francesco},
	year = {2020},
	note = {Publisher: Springer},
	pages = {783--797},
}

@inproceedings{skibski_signed_2020,
	title = {Signed graph games: {Coalitional} games with friends, enemies and allies},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {Multiagent} {Systems}},
	author = {Skibski, Oskar and Suzuki, Takamasa and Grabowski, Tomasz and Michalak, Tomasz and Yokoo, Makoto},
	year = {2020},
	pages = {1287--1295},
}

@article{silverman_rich_2012,
	title = {Rich socio-cognitive agents for immersive training environments: case of {NonKin} {Village}},
	volume = {24},
	journal = {Autonomous Agents and Multi-Agent Systems},
	author = {Silverman, Barry G and Pietrocola, David and Nye, Ben and Weyer, Nathan and Osin, Oleg and Johnson, Dan and Weaver, Ransom},
	year = {2012},
	note = {Publisher: Springer US},
	pages = {312--343},
}

@article{dignum_relational_2022,
	title = {Relational artificial intelligence},
	journal = {arXiv preprint arXiv:2202.07446},
	author = {Dignum, Virginia},
	year = {2022},
}

@article{lorenzen_reference_2022,
	title = {Reference counting with frame limited reuse},
	volume = {6},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Lorenzen, Anton and Leijen, Daan},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {357--380},
	file = {Lorenzen and Leijen - 2022 - Reference counting with frame limited reuse.pdf:/home/tim/Zotero/storage/3MKH4MGE/Lorenzen and Leijen - 2022 - Reference counting with frame limited reuse.pdf:application/pdf},
}

@inproceedings{bowling_rational_2001,
	title = {Rational and convergent learning in stochastic games},
	volume = {17},
	booktitle = {International joint conference on artificial intelligence},
	publisher = {Citeseer},
	author = {Bowling, Michael and Veloso, Manuela},
	year = {2001},
	note = {Issue: 1},
	pages = {1021--1026},
}

@article{powers_new_2004,
	title = {New criteria and a new algorithm for learning in multi-agent systems},
	volume = {17},
	journal = {Advances in neural information processing systems},
	author = {Powers, Rob and Shoham, Yoav},
	year = {2004},
}

@article{bowling_multiagent_2002,
	title = {Multiagent learning using a variable learning rate},
	volume = {136},
	number = {2},
	journal = {Artificial Intelligence},
	author = {Bowling, Michael and Veloso, Manuela},
	year = {2002},
	note = {Publisher: Elsevier},
	pages = {215--250},
}

@inproceedings{leijen_mimalloc_2019,
	title = {Mimalloc: {Free} list sharding in action},
	booktitle = {Programming {Languages} and {Systems}: 17th {Asian} {Symposium}, {APLAS} 2019, {Nusa} {Dua}, {Bali}, {Indonesia}, {December} 1‚Äì4, 2019, {Proceedings} 17},
	publisher = {Springer International Publishing},
	author = {Leijen, Daan and Zorn, Benjamin and de Moura, Leonardo},
	year = {2019},
	keywords = {to-read},
	pages = {244--265},
	file = {Leijen et al. - 2019 - Mimalloc Free list sharding in action.pdf:/home/tim/Zotero/storage/VUBN293D/Leijen et al. - 2019 - Mimalloc Free list sharding in action.pdf:application/pdf},
}

@article{wang_learning_2020,
	title = {Learning context-aware task reasoning for efficient meta-reinforcement learning},
	journal = {arXiv preprint arXiv:2003.01373},
	author = {Wang, Haozhe and Zhou, Jiale and He, Xuming},
	year = {2020},
}

@article{mercuur_integrating_2020,
	title = {Integrating social practice theory in agent-based models: {A} review of theories and agents},
	volume = {7},
	number = {5},
	journal = {IEEE Transactions on Computational Social Systems},
	author = {Mercuur, Rijk and Dignum, Virginia and Jonker, Catholijn M},
	year = {2020},
	note = {Publisher: IEEE},
	pages = {1131--1145},
}

@inproceedings{littman_leading_2001,
	title = {Leading best-response strategies in repeated games},
	booktitle = {Seventeenth {Annual} {International} {Joint} {Conference} on {Artificial} {Intelligence} {Workshop} on {Economic} {Agents}, {Models}, and {Mechanisms}},
	author = {Littman, Michael L and Stone, Peter},
	year = {2001},
}

@inproceedings{stimpson_learning_2003,
	title = {Learning to cooperate in a social dilemma: {A} satisficing approach to bargaining},
	booktitle = {Proceedings of the 20th international conference on machine learning ({ICML}-03)},
	author = {Stimpson, Jeff L and Goodrich, Michael A},
	year = {2003},
	pages = {728--735},
}

@article{mellema_linking_2022,
	title = {Linking sanctions to norms in practice},
	journal = {arXiv preprint arXiv:2205.10295},
	author = {Mellema, Ren√© and Dignum, Frank},
	year = {2022},
}

@article{foerster_learning_2017,
	title = {Learning with opponent-learning awareness},
	journal = {arXiv preprint arXiv:1709.04326},
	author = {Foerster, Jakob N and Chen, Richard Y and Al-Shedivat, Maruan and Whiteson, Shimon and Abbeel, Pieter and Mordatch, Igor},
	year = {2017},
}

@inproceedings{bensch_increasing_2022,
	title = {Increasing robot understandability through social practices},
	booktitle = {Ro-{Man} 2022, 31st {IEEE} {International} {Conference} on {Robot} and {Human} {Interactive} {Communication}, {Naples}, {Italy}, {Aug} 29-{September} 2, 2022},
	author = {Bensch, Suna and Dignum, Frank and Hellstr√∂m, Thomas},
	year = {2022},
}

@article{de_farias_how_2003,
	title = {How to combine expert (and novice) advice when actions impact the environment?},
	volume = {16},
	journal = {Advances in neural information processing systems},
	author = {de Farias, Daniela and Megiddo, Nimrod},
	year = {2003},
}

@inproceedings{yahiro_game_2020,
	title = {Game theoretic analysis for two-sided matching with resource allocation},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {MultiAgent} {Systems}},
	author = {Yahiro, Kentaro and Yokoo, Makoto},
	year = {2020},
	pages = {1548--1556},
}

@inproceedings{littman_friend-or-foe_2001,
	title = {Friend-or-foe {Q}-learning in general-sum games},
	volume = {1},
	booktitle = {{ICML}},
	author = {Littman, Michael L},
	year = {2001},
	pages = {322--328},
}

@inproceedings{dignum_autistic_2014,
	title = {From autistic to social agents},
	booktitle = {Proceedings of the 2014 international conference on {Autonomous} {Agents} and {Multi}-{Agent} {Systems}},
	author = {Dignum, Frank and Prada, Rui and Hofstede, Gert Jan},
	year = {2014},
	pages = {1161--1164},
}

@article{dennis_formal_2016,
	title = {Formal verification of ethical choices in autonomous systems},
	volume = {77},
	journal = {Robotics and Autonomous Systems},
	author = {Dennis, Louise and Fisher, Michael and Slavkovik, Marija and Webster, Matt},
	year = {2016},
	note = {Publisher: Elsevier},
	pages = {1--14},
}

@inproceedings{fan_extending_2005,
	title = {Extending the recognition-primed decision model to support human-agent collaboration},
	booktitle = {Proceedings of the fourth international joint conference on {Autonomous} agents and multiagent systems},
	author = {Fan, Xiaocong and Sun, Shuang and McNeese, Michale and Yen, John},
	year = {2005},
	pages = {945--952},
}

@article{karandikar_evolving_1998,
	title = {Evolving aspirations and cooperation},
	volume = {80},
	number = {2},
	journal = {journal of economic theory},
	author = {Karandikar, Rajeeva and Mookherjee, Dilip and Ray, Debraj and Vega-Redondo, Fernando},
	year = {1998},
	note = {Publisher: Elsevier},
	pages = {292--331},
}

@article{barcelo_dynamic_2005,
	title = {Dynamic network simulation with {AIMSUN}},
	journal = {Simulation approaches in transportation analysis: Recent advances and challenges},
	author = {Barcel√≥, Jaime and Casas, Jordi},
	year = {2005},
	note = {Publisher: Springer US},
	pages = {57--98},
}

@inproceedings{castelfranchi_deliberative_2000,
	title = {Deliberative normative agents: {Principles} and architecture},
	booktitle = {Intelligent {Agents} {VI}. {Agent} {Theories}, {Architectures}, and {Languages}: 6th {International} {Workshop}, {ATAL}‚Äô99, {Orlando}, {Florida}, {USA}, {July} 15-17, 1999. {Proceedings} 6},
	publisher = {Springer Berlin Heidelberg},
	author = {Castelfranchi, Cristiano and Dignum, Frank and Jonker, Catholijn M and Treur, Jan},
	year = {2000},
	pages = {364--378},
}

@inproceedings{kaminka_curing_2013,
	title = {Curing robot autism: {A} challenge},
	booktitle = {Proceedings of the 2013 international conference on {Autonomous} agents and multi-agent systems},
	publisher = {Citeseer},
	author = {Kaminka, Gal A},
	year = {2013},
	pages = {801--804},
}

@article{crandall_cooperating_2018,
	title = {Cooperating with machines},
	volume = {9},
	number = {1},
	journal = {Nature communications},
	author = {Crandall, Jacob W and Oudah, Mayada and Ishowo-Oloko, Fatimah and Abdallah, Sherief and Bonnefon, Jean-Fran√ßois and Cebrian, Manuel and Shariff, Azim and Goodrich, Michael A and Rahwan, Iyad},
	year = {2018},
	note = {Publisher: Nature Publishing Group UK London},
	pages = {233},
	file = {Crandall et al_2018_Cooperating with machines.pdf:/home/tim/Zotero/storage/XGEZPUFU/Crandall et al_2018_Cooperating with machines.pdf:application/pdf;Crandall et al_2018_Cooperating with machines2.pdf:/home/tim/Zotero/storage/L4L9BAZU/Crandall et al_2018_Cooperating with machines2.pdf:application/pdf},
}

@article{bowling_convergence_2004,
	title = {Convergence and no-regret in multiagent learning},
	volume = {17},
	journal = {Advances in neural information processing systems},
	author = {Bowling, Michael},
	year = {2004},
}

@article{whiting_confronting_2021,
	title = {Confronting barriers to human-robot cooperation: balancing efficiency and risk in machine behavior},
	volume = {24},
	number = {1},
	journal = {Iscience},
	author = {Whiting, Tim and Gautam, Alvika and Tye, Jacob and Simmons, Michael and Henstrom, Jordan and Oudah, Mayada and Crandall, Jacob W},
	year = {2021},
	note = {Publisher: Elsevier},
	pages = {101963},
	file = {Whiting et al_2021_Confronting barriers to human-robot cooperation.pdf:/home/tim/Zotero/storage/PNZ55GJ9/Whiting et al_2021_Confronting barriers to human-robot cooperation.pdf:application/pdf;Whiting et al_2021_Confronting barriers to human-robot cooperation2.pdf:/home/tim/Zotero/storage/S8TJNRB3/Whiting et al_2021_Confronting barriers to human-robot cooperation2.pdf:application/pdf;Whiting et al_2021_Confronting barriers to human-robot cooperation3.pdf:/home/tim/Zotero/storage/YEXGTS88/Whiting et al_2021_Confronting barriers to human-robot cooperation3.pdf:application/pdf},
}

@book{chai_choosing_2001,
	title = {Choosing an identity: {A} general model of preference and belief formation},
	publisher = {University of Michigan Press},
	author = {Chai, Sun-Ki},
	year = {2001},
}

@inproceedings{kammler_changing_2022,
	title = {Changing perspectives: adaptable interpretations of norms for agents},
	booktitle = {Multi-{Agent}-{Based} {Simulation} {XXII}: 22nd {International} {Workshop}, {MABS} 2021, {Virtual} {Event}, {May} 3-7, 2021, {Revised} {Selected} {Papers}},
	publisher = {Springer International Publishing Cham},
	author = {Kammler, Christian and Dignum, Frank and Wijermans, Nanda and Lindgren, Helena},
	year = {2022},
	pages = {139--152},
}

@article{dignum_autonomous_1999,
	title = {Autonomous agents with norms},
	volume = {7},
	journal = {Artificial intelligence and law},
	author = {Dignum, Frank},
	year = {1999},
	note = {Publisher: Kluwer Academic Publishers},
	pages = {69--79},
}

@inproceedings{dignum_agents_2020,
	title = {Agents are dead. {Long} live agents!},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Autonomous} {Agents} and {MultiAgent} {Systems}},
	author = {Dignum, Virginia and Dignum, Frank},
	year = {2020},
	pages = {1701--1705},
}

@incollection{erdogan_abstracting_2022,
	title = {Abstracting {Minds}: {Computational} {Theory} of {Mind} for {Human}-{Agent} {Collaboration}},
	booktitle = {{HHAI2022}: {Augmenting} {Human} {Intellect}},
	publisher = {IOS Press},
	author = {Erdogan, Emre and Dignum, Frank and Verbrugge, Rineke and Yolum, Pƒ±nar},
	year = {2022},
	pages = {199--211},
}

@article{de_cote_polynomial-time_2012,
	title = {A polynomial-time {Nash} equilibrium algorithm for repeated stochastic games},
	journal = {arXiv preprint arXiv:1206.3277},
	author = {De Cote, Enrique Munoz and Littman, Michael L},
	year = {2012},
}

@inproceedings{gautam_method_2022,
	title = {A {Method} for {Designing} {Autonomous} {Robots} that {Know} {Their} {Limits}},
	booktitle = {2022 {International} {Conference} on {Robotics} and {Automation} ({ICRA})},
	publisher = {IEEE},
	author = {Gautam, Alvika and Whiting, Tim and Cao, Xuan and Goodrich, Michael A and Crandall, Jacob W},
	year = {2022},
	pages = {121--127},
}

@article{dignum_conceptual_2015,
	title = {A conceptual architecture for social deliberation in multi-agent organizations},
	volume = {11},
	number = {3},
	journal = {Multiagent and Grid Systems},
	author = {Dignum, Frank and Dignum, Virginia and Prada, Rui and Jonker, Catholijn M},
	year = {2015},
	note = {Publisher: IOS Press},
	pages = {147--166},
}

@article{leijen_tail_2023,
	title = {Tail {Recursion} {Modulo} {Context}: {An} {Equational} {Approach}},
	volume = {7},
	issn = {2475-1421},
	shorttitle = {Tail {Recursion} {Modulo} {Context}},
	url = {https://dl.acm.org/doi/10.1145/3571233},
	doi = {10.1145/3571233},
	abstract = {The tail-recursion modulo
              cons
              transformation can rewrite functions that are not quite tail-recursive into a tail-recursive form that can be executed efficiently. In this article we generalize tail recursion modulo
              cons
              (TRMc) to modulo
              contexts
              (TRMC), and calculate a general TRMC algorithm from its specification. We can instantiate our general algorithm by providing an implementation of application and composition on abstract contexts, and showing that our
              context
              laws\_ hold. We provide some known instantiations of TRMC, namely modulo
              evaluation contexts
              (CPS), and
              associative operations
              , and further instantiantions not so commonly associated with TRMC, such as
              defunctionalized
              evaluation contexts,
              monoids
              ,
              semirings
              ,
              exponents
              , and
              cons products
              . We study the modulo
              cons
              instantiation in particular and prove that an instantiation using Minamide‚Äôs hole calculus is sound. We also calculate a second instantiation in terms of the Perceus heap semantics to precisely reason about the soundness of in-place update. While all previous approaches to TRMc fail in the presence of non-linear control (for example induced by call/cc, shift/reset or algebraic effect handlers), we can elegantly extend the heap semantics to a hybrid approach which dynamically adapts to non-linear control flow. We have a full implementation of hybrid TRMc in the Koka language and our benchmark shows the TRMc transformed functions are always as fast or faster than using manual alternatives.},
	language = {en},
	number = {POPL},
	urldate = {2024-02-27},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Leijen, Daan and Lorenzen, Anton},
	month = jan,
	year = {2023},
	keywords = {to-read},
	pages = {1152--1181},
	file = {Leijen and Lorenzen - 2023 - Tail Recursion Modulo Context An Equational Appro.pdf:/home/tim/Zotero/storage/JPXQGIDL/Leijen and Lorenzen - 2023 - Tail Recursion Modulo Context An Equational Appro.pdf:application/pdf},
}

@article{lorenzen_functional_nodate,
	title = {The {Functional} {Essence} of {Imperative} {Binary} {Search} {Trees}},
	language = {en},
	author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter and Lindley, Sam},
	file = {Lorenzen et al. - The Functional Essence of Imperative Binary Search.pdf:/home/tim/Zotero/storage/E9JTSLEK/Lorenzen et al. - The Functional Essence of Imperative Binary Search.pdf:application/pdf},
}

@article{rehof_type-based_nodate,
	title = {Type-{Based} {Flow} {Analysis}: {From} {Polymorphic} {Subtyping} to {CFL}-{Reachability}.},
	abstract = {We present a novel approach to scalable implementation of type-based flow analysis with polymorphic subtyping. Using a new presentation of polymorphic subtyping with instantiation constraints, we are able to apply context-free language (CFL) reachability techniques to type-based flow analysis. We develop a CFL-based algorithm for computing flow information in time O(n3), where n is the size of the typed program. The algorithm substantially improves upon the best previously known algorithm for flow analysis based on polymorphic subtyping with complexity O(n8 ). Our technique also yields the first demand-driven algorithm for polymorphic subtype-based flow-computation. It works directly on higher-order programs with structured data of finite type (unbounded data structures are incorporated via finite approximations), supports context-sensitive, global flow summarization and includes polymorphic recursion.},
	language = {en},
	author = {Rehof, Jakob},
	keywords = {to-read},
	file = {Rehof - Type-Based Flow Analysis From Polymorphic Subtypi.pdf:/home/tim/Zotero/storage/I25WRPRM/Rehof - Type-Based Flow Analysis From Polymorphic Subtypi.pdf:application/pdf},
}

@article{dunfield_bidirectional_2022,
	title = {Bidirectional {Typing}},
	volume = {54},
	issn = {0360-0300, 1557-7341},
	url = {http://arxiv.org/abs/1908.05839},
	doi = {10.1145/3450952},
	abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner's local type inference to the present day, and provide guidance for future investigations.},
	language = {en},
	number = {5},
	urldate = {2024-02-06},
	journal = {ACM Computing Surveys},
	author = {Dunfield, Jana and Krishnaswami, Neel},
	month = jun,
	year = {2022},
	note = {arXiv:1908.05839 [cs]},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages, to-read},
	pages = {1--38},
	file = {Dunfield and Krishnaswami - 2022 - Bidirectional Typing.pdf:/home/tim/Zotero/storage/XQWQDKZ3/Dunfield and Krishnaswami - 2022 - Bidirectional Typing.pdf:application/pdf;PDF:/home/tim/Zotero/storage/RNT4ZYED/Dunfield and Krishnaswami - 2022 - Bidirectional Typing.pdf:application/pdf},
}

@article{vytiniotis_boxy_nodate,
	title = {Boxy {Types}: {Inference} for {Higher}-{Rank} {Types} and {Impredicativity}},
	abstract = {Languages with rich type systems are beginning to employ a blend of type inference and type checking, so that the type inference engine is guided by programmer-supplied type annotations. In this paper we show, for the Ô¨Årst time, how to combine the virtues of two well-established ideas: uniÔ¨Åcation-based inference, and bidirectional propagation of type annotations. The result is a type system that conservatively extends Hindley-Milner, and yet supports both higher-rank types and impredicativity.},
	language = {en},
	author = {Vytiniotis, Dimitrios and Weirich, Stephanie and Jones, Simon Peyton},
	keywords = {to-read},
	file = {PDF:/home/tim/Zotero/storage/8SP5T2LH/Vytiniotis et al. - Boxy Types Inference for Higher-Rank Types and Impredicativity.pdf:application/pdf;Vytiniotis et al. - Boxy Types Inference for Higher-Rank Types and Im.pdf:/home/tim/Zotero/storage/SBA4B9KH/Vytiniotis et al. - Boxy Types Inference for Higher-Rank Types and Im.pdf:application/pdf},
}

@article{odersky_colored_nodate,
	title = {Colored {Local} {Type} {Inference}},
	abstract = {We present a type system for a language based on F‚â§, which allows certain type annotations to be elided in actual programs. Local type inference determines types by a combination of type propagation and local constraint solving, rather than by global constraint solving. We reÔ¨Åne the previously existing local type inference system of Pierce and Turner[PT98] by allowing partial type information to be propagated. This is expressed by coloring types to indicate propagation directions. Propagating partial type information allows us to omit type annotations for the visitor pattern, the analogue of pattern matching in languages without sum types.},
	language = {en},
	author = {Odersky, Martin and Zenger, Christoph and Zenger, Matthias},
	keywords = {to-read},
	file = {Odersky et al. - Colored Local Type Inference.pdf:/home/tim/Zotero/storage/NZCC2N96/Odersky et al. - Colored Local Type Inference.pdf:application/pdf;PDF:/home/tim/Zotero/storage/ZVTXAVIW/Odersky et al. - Colored Local Type Inference.pdf:application/pdf},
}

@inproceedings{odersky_putting_1996,
	address = {St. Petersburg Beach, Florida, United States},
	title = {Putting type annotations to work},
	isbn = {978-0-89791-769-8},
	url = {http://portal.acm.org/citation.cfm?doid=237721.237729},
	doi = {10.1145/237721.237729},
	language = {en},
	urldate = {2024-02-06},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '96},
	publisher = {ACM Press},
	author = {Odersky, Martin and L√§ufer, Konstantin},
	year = {1996},
	keywords = {to-read},
	pages = {54--67},
	file = {Odersky and L√§ufer - 1996 - Putting type annotations to work.pdf:/home/tim/Zotero/storage/UYZT6KTQ/Odersky and L√§ufer - 1996 - Putting type annotations to work.pdf:application/pdf;PDF:/home/tim/Zotero/storage/ZMK6P6X3/Odersky and L√§ufer - 1996 - Putting type annotations to work.pdf:application/pdf;PDF:/home/tim/Zotero/storage/N3J7NWAY/Odersky and L√§ufer - 1996 - Putting type annotations to work.pdf:application/pdf},
}

@article{jones_practical_2007,
	title = {Practical type inference for arbitrary-rank types},
	volume = {17},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796806006034/type/journal_article},
	doi = {10.1017/S0956796806006034},
	abstract = {Haskell‚Äôs popularity has driven the need for ever more expressive type system features, most of which threaten the decidability and practicality of Damas-Milner type inference. One such feature is the ability to write functions with higher-rank types‚Äîthat is, functions that take polymorphic functions as their arguments.},
	language = {en},
	number = {1},
	urldate = {2024-02-06},
	journal = {Journal of Functional Programming},
	author = {Jones, Simon Peyton and Vytiniotis, Dimitrios and Weirich, Stephanie and Shields, Mark},
	month = jan,
	year = {2007},
	keywords = {to-read},
	pages = {1--82},
	file = {Jones et al. - 2007 - Practical type inference for arbitrary-rank types.pdf:/home/tim/Zotero/storage/68DPRYBE/Jones et al. - 2007 - Practical type inference for arbitrary-rank types.pdf:application/pdf;PDF:/home/tim/Zotero/storage/XTP7E3BX/Jones et al. - 2007 - Practical type inference for arbitrary-rank types.pdf:application/pdf;PDF:/home/tim/Zotero/storage/SQA34TRW/Jones et al. - 2007 - Practical type inference for arbitrary-rank types.pdf:application/pdf},
}

@article{bhanuka_getting_2023,
	title = {Getting into the {Flow}: {Towards} {Better} {Type} {Error} {Messages} for {Constraint}-{Based} {Type} {Inference}},
	volume = {7},
	issn = {2475-1421},
	shorttitle = {Getting into the {Flow}},
	url = {https://dl.acm.org/doi/10.1145/3622812},
	doi = {10.1145/3622812},
	abstract = {ISHAN BHANUKA, HKUST, Hong Kong, China LIONEL PARREAUX, HKUST, Hong Kong, China DAVID BINDER, University of T√ºbingen, Germany JONATHAN IMMANUEL BRACHTH√ÑUSER, University of T√ºbingen, Germany Creating good type error messages for constraint-based type inference systems is diÔ¨Écult. Typical type error messages reÔ¨Çect implementation details of the underlying constraint-solving algorithms rather than the speciÔ¨Åc factors leading to type mismatches. We propose using subtyping constraints that capture data Ô¨Çow to classify and explain type errors. Our algorithm explains type errors as faulty data Ô¨Çows, which programmers are already used to reasoning about, and illustrates these data Ô¨Çows as sequences of relevant program locations. We show that our ideas and algorithm are not limited to languages with subtyping, as they can be readily integrated with Hindley-Milner type inference. In addition to these core contributions, we present the results of a user study to evaluate the quality of our messages compared to other implementations. While the quantitative evaluation does not show that Ô¨Çow-based messages improve the localization or understanding of the causes of type errors, the qualitative evaluation suggests a real need and demand for Ô¨Çow-based messages. CCS Concepts: ‚Ä¢ Software and its engineering ‚Üí General programming languages; ‚Ä¢ Theory of computation ‚Üí Program analysis; Type theory; ‚Ä¢ Human-centered computing ‚Üí Human computer interaction (HCI).},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-02-06},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bhanuka, Ishan and Parreaux, Lionel and Binder, David and Brachth√§user, Jonathan Immanuel},
	month = oct,
	year = {2023},
	keywords = {to-read},
	pages = {431--459},
	file = {Bhanuka et al. - 2023 - Getting into the Flow Towards Better Type Error M.pdf:/home/tim/Zotero/storage/KVPNPFPN/Bhanuka et al. - 2023 - Getting into the Flow Towards Better Type Error M.pdf:application/pdf;PDF:/home/tim/Zotero/storage/HHH78BAC/Bhanuka et al. - 2023 - Getting into the Flow Towards Better Type Error Messages for Constraint-Based Type Inference.pdf:application/pdf},
}

@article{heeren_generalizing_nodate,
	title = {Generalizing {Hindley}-{Milner} {Type} {Inference} {Algorithms}},
	abstract = {Type inferencing according to the standard algorithms W and M often yields uninformative error messages. Many times, this is a consequence of a bias inherent in the algorithms. The method developed here is to Ô¨Årst collect constraints from the program, and to solve these afterwards, possibly under the inÔ¨Çuence of a heuristic. We show the soundness and completeness of our algorithm. The algorithms W and M turn out to be deterministic instances of our method, giving the correctness for W and M with respect to the Hindley-Milner typing rules for free. We also show that our algorithm is more Ô¨Çexible, because it naturally allows the generation of multiple messages.},
	language = {en},
	author = {Heeren, Bastiaan and Hage, Jurriaan and Swierstra, Doaitse},
	keywords = {to-read},
	file = {Heeren et al. - Generalizing Hindley-Milner Type Inference Algorit.pdf:/home/tim/Zotero/storage/R8N852SR/Heeren et al. - Generalizing Hindley-Milner Type Inference Algorit.pdf:application/pdf;PDF:/home/tim/Zotero/storage/4Y5VEAAK/Heeren et al. - Generalizing Hindley-Milner Type Inference Algorithms.pdf:application/pdf},
}

@article{leijen_hmf_nodate,
	title = {{HMF}: {Simple} {Type} {Inference} for {First}-{Class} {Polymorphism}},
	abstract = {HMF is a conservative extension of Hindley-Milner type inference with Ô¨Årst-class polymorphism. In contrast to other proposals, HML uses regular System F types and has a simple type inference algorithm that is just a small extension of the usual Damas-Milner algorithm W. Given the relative simplicity and expressive power, we feel that HMF can be an attractive type system in practice. There is a reference implementation of the type system available online together with a technical report containing proofs (Leijen 2007a,b).},
	language = {en},
	author = {Leijen, Daan},
	keywords = {to-read},
	file = {Leijen - HMF Simple Type Inference for First-Class Polymor.pdf:/home/tim/Zotero/storage/7W4IGNXS/Leijen - HMF Simple Type Inference for First-Class Polymor.pdf:application/pdf;PDF:/home/tim/Zotero/storage/WRCJLS7B/Leijen - HMF Simple Type Inference for First-Class Polymorphism.pdf:application/pdf},
}

@article{parreaux_when_2024,
	title = {When {Subtyping} {Constraints} {Liberate}: {A} {Novel} {Type} {Inference} {Approach} for {First}-{Class} {Polymorphism}},
	volume = {8},
	issn = {2475-1421},
	shorttitle = {When {Subtyping} {Constraints} {Liberate}},
	url = {https://dl.acm.org/doi/10.1145/3632890},
	doi = {10.1145/3632890},
	abstract = {Type inference in the presence of first-class or ‚Äúimpredicative‚Äù second-order polymorphism √† la System F has been an active research area for several decades, with original works dating back to the end of the 80s. Yet, until now many basic problems remain open, such as how to type check expressions like (ùúÜùë•. (ùë• 123, ùë• True)) id reliably. We show that a type inference approach based on multi-bounded polymorphism, a form of implicit polymorphic subtyping with multiple lower and upper bounds, can help us resolve most of these problems in a uniquely simple and regular way. We define F
              \{‚â§\}
              , a declarative type system derived from the existing theory of implicit coercions by Cretin and R√©my (LICS 2014), and we introduce SuperF, a novel algorithm to infer polymorphic multi-bounded F
              \{‚â§\}
              types while checking user type annotations written in the syntax of System F. We use a recursion-avoiding heuristic to guarantee termination of type inference at the cost of rejecting some valid programs, which thankfully rarely triggers in practice. We show that SuperF is vastly more powerful than all first-class-polymorphic type inference systems proposed so far, significantly advancing the state of the art in type inference for general-purpose programming languages.},
	language = {en},
	number = {POPL},
	urldate = {2024-02-06},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Parreaux, Lionel and Boruch-Gruszecki, Aleksander and Fan, Andong and Chau, Chun Yin},
	month = jan,
	year = {2024},
	keywords = {to-read},
	pages = {1418--1450},
	file = {Parreaux et al. - 2024 - When Subtyping Constraints Liberate A Novel Type .pdf:/home/tim/Zotero/storage/NRPGE5BJ/Parreaux et al. - 2024 - When Subtyping Constraints Liberate A Novel Type .pdf:application/pdf;PDF:/home/tim/Zotero/storage/6EK6LMCW/Parreaux et al. - 2024 - When Subtyping Constraints Liberate A Novel Type Inference Approach for First-Class Polymorphism.pdf:application/pdf;PDF:/home/tim/Zotero/storage/M6M9KWCQ/Parreaux et al. - 2024 - When Subtyping Constraints Liberate A Novel Type Inference Approach for First-Class Polymorphism.pdf:application/pdf},
}

@article{van_horn_deciding_2008,
	title = {Deciding {KCFA} is {Complete} for {EXPTIME}},
	volume = {43},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/1411203.1411243},
	doi = {10.1145/1411203.1411243},
	abstract = {We give an exact characterization of the computational complexity of the kCFA hierarchy. For any k \&gt; 0, we prove that the control flow decision problem is complete for deterministic exponential time. This theorem validates empirical observations that such control flow analysis is intractable. It also provides more general insight into the complexity of abstract interpretation.},
	number = {9},
	journal = {SIGPLAN Not.},
	author = {Van Horn, David and Mairson, Harry G.},
	month = sep,
	year = {2008},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {complexity, flow analysis, to-read},
	pages = {275--282},
}

@inproceedings{van_horn_deciding_2008-1,
	address = {New York, NY, USA},
	series = {{ICFP} '08},
	title = {Deciding {KCFA} is {Complete} for {EXPTIME}},
	isbn = {978-1-59593-919-7},
	url = {https://doi.org/10.1145/1411204.1411243},
	doi = {10.1145/1411204.1411243},
	abstract = {We give an exact characterization of the computational complexity of the kCFA hierarchy. For any k \&gt; 0, we prove that the control flow decision problem is complete for deterministic exponential time. This theorem validates empirical observations that such control flow analysis is intractable. It also provides more general insight into the complexity of abstract interpretation.},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Van Horn, David and Mairson, Harry G.},
	year = {2008},
	note = {event-place: Victoria, BC, Canada},
	keywords = {complexity, flow analysis, to-read},
	pages = {275--282},
}

@article{thomson_fusing_2022,
	title = {Fusing industry and academia at {GitHub} (experience report)},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3547639},
	doi = {10.1145/3547639},
	abstract = {PATRICK THOMSON, GitHub, Inc., United States ROB RIX, GitHub, Inc., Canada NICOLAS WU, Imperial College London, United Kingdom TOM SCHRIJVERS, KU Leuven, Belgium GitHub hosts hundreds of millions of code repositories written in hundreds of different programming languages. In addition to its hosting services, GitHub provides data and insights into code, such as vulnerability analysis and code navigation, with which users can improve and understand their software development process. GitHub has built Semantic, a program analysis tool capable of parsing and extracting detailed information from source code. The development of Semantic has relied extensively on the functional programming literature; this paper describes how connections to academic research inspired and informed the development of an industrial-scale program analysis toolkit. CCS Concepts: ¬∑ Software and its engineering ‚Üí General programming languages; ¬∑ Social and professional topics ‚Üí History of programming languages.},
	language = {en},
	number = {ICFP},
	urldate = {2024-01-10},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Thomson, Patrick and Rix, Rob and Wu, Nicolas and Schrijvers, Tom},
	month = aug,
	year = {2022},
	keywords = {to-read},
	pages = {496--511},
	file = {Thomson et al. - 2022 - Fusing industry and academia at GitHub (experience.pdf:/home/tim/Zotero/storage/IA9HPMUD/Thomson et al. - 2022 - Fusing industry and academia at GitHub (experience.pdf:application/pdf},
}

@article{whiting_proving_nodate,
	title = {Proving {Out} {Demand} {CFA} for {Modern} {Compiler} {Architectures}},
	language = {en},
	author = {Whiting, Tim},
	keywords = {to-read},
	file = {Whiting - Proving Out Demand CFA for Modern Compiler Archite.pdf:/home/tim/Zotero/storage/H5LE69II/Whiting - Proving Out Demand CFA for Modern Compiler Archite.pdf:application/pdf},
}

@article{jonest_yale_nodate,
	title = {Yale {University} {Department} of {Computer} {Science} {New} {Haven}, {CT} 06520-8285},
	abstract = {We show howa set of building blocks can be used to construct programming language interpreters, and present implementations of such building blocks capable of supporting many commonly known features, including simple expressions, three different function call mechanisms (call-by-name, callby-value and lazy evaluation), references and assignment, nondeterminism, first-class continuations, and program tracing. The underlying mechanism of our system is monad fransfonners, a simple form of abstraction for introducing a wide range of computational behaviors, such as state, 1/0, continuations, and exceptions.},
	language = {en},
	author = {Jonest, Mark},
	keywords = {to-read},
	file = {Jonest - Yale University Department of Computer Science New.pdf:/home/tim/Zotero/storage/AANSHRFY/Jonest - Yale University Department of Computer Science New.pdf:application/pdf},
}

@article{boucher_lightweight_nodate,
	title = {Lightweight {Preemptible} {Functions}},
	abstract = {Lamenting the lack of a natural userland abstraction for preemptive interruption and asynchronous cancellation, we propose lightweight preemptible functions, a mechanism for synchronously performing a function call with a precise timeout that is lightweight, e cient, and composable, all while being portable between programming languages. We present the design of libinger, a library that provides this abstraction, on top of which we build libturquoise, arguably the rst generalpurpose and backwards-compatible preemptive thread library implemented entirely in userland. Finally, we demonstrate this software stack‚Äôs applicability to and performance on the problems of combatting head-ofline blocking and time-based DoS attacks.},
	language = {en},
	author = {Boucher, Sol and Kalia, Anuj and Andersen, David G and Kaminsky, Michael},
	keywords = {to-read},
	file = {Boucher et al. - Lightweight Preemptible Functions.pdf:/home/tim/Zotero/storage/JBI2JB2D/Boucher et al. - Lightweight Preemptible Functions.pdf:application/pdf},
}

@misc{smith_pure_2023,
	title = {A {Pure} {Demand} {Operational} {Semantics} {With} {Applications} to {Program} {Analysis}},
	url = {http://arxiv.org/abs/2310.15915},
	abstract = {This paper develops a novel minimal-state operational semantics for higher-order functional languages which uses only the call stack and two source program points as the complete state information: there is no environment, no substitution, no continuation, etc. We prove this form of operational semantics is equivalent to standard presentations. We then show how this approach can open the door to potential new applications: we define a program analysis as a direct finitization of this operational semantics. The program analysis that naturally emerges has a number of novel and interesting properties compared to standard program analyses for higher-order programs: for example, it can infer recurrences, and does not need value widening. We both give a formal definition of the analysis and describe our current implementation.},
	language = {en},
	urldate = {2023-12-12},
	publisher = {arXiv},
	author = {Smith, Scott and Zhang, Robert},
	month = oct,
	year = {2023},
	note = {arXiv:2310.15915 [cs]},
	keywords = {Computer Science - Programming Languages, to-read},
	file = {Smith and Zhang - 2023 - A Pure Demand Operational Semantics With Applicati.pdf:/home/tim/Zotero/storage/ZQW2UE7D/Smith and Zhang - 2023 - A Pure Demand Operational Semantics With Applicati.pdf:application/pdf},
}

@incollection{swierstra_towards_2022,
	address = {Cham},
	title = {Towards {Efficient} {Adjustment} of {Effect} {Rows}},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_9},
	abstract = {Koka is a functional programming language with native support for algebraic eÔ¨Äects and handlers. To implement eÔ¨Äect handler operations eÔ¨Éciently, Koka employs a semantics where the handlers in scope are passed down to each function as an evidence vector. At runtime, these evidence vectors are adjusted using the open constructs to match the evidence for a particular function. All these adjustments can cause signiÔ¨Åcant runtime overhead. In this paper, we present a novel transformation on the Koka core calculus that we call open Ô¨Çoating. This transformation aims to Ô¨Çoat up open constructs and combine them in order to minimize the adjustments needed at runtime. Open Ô¨Çoating improves performance by 2.5√ó in an experiment. Furthermore, we formalize an aspect of row-based eÔ¨Äect typing, including the closed preÔ¨Åx relation on eÔ¨Äect rows, which clariÔ¨Åes the constraint on open Ô¨Çoating.},
	language = {en},
	urldate = {2023-11-04},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Furudono, Naoya and Cong, Youyou and Masuhara, Hidehiko and Leijen, Daan},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4_9},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {169--191},
	file = {Furudono et al_2023_Towards Efficient Adjustment of Effect Rows.pdf:/home/tim/Zotero/storage/SSRRGFG3/Furudono et al_2023_Towards Efficient Adjustment of Effect Rows.pdf:application/pdf;Furudono et al. - 2022 - Towards Efficient Adjustment of Effect Rows.pdf:/home/tim/Zotero/storage/TYVWNXLB/Furudono et al. - 2022 - Towards Efficient Adjustment of Effect Rows.pdf:application/pdf},
}

@incollection{swierstra_sound_2022,
	address = {Cham},
	title = {Sound and {Complete} {Type} {Inference} for {Closed} {Effect} {Rows}},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_8},
	abstract = {Koka is a functional programming language that has algebraic eÔ¨Äect handlers and a row-based eÔ¨Äect system. The row-based eÔ¨Äect system infers types by naively applying the Hindley-Milner type inference. However, it infers eÔ¨Äect-polymorphic types for many functions, which are hard to read by the programmers and have a negative runtime performance impact to the evidence-passing translation. In order to improve readability and runtime eÔ¨Éciency, we aim to infer closed eÔ¨Äect rows when possible, and open those closed eÔ¨Äect rows automatically at instantiation to avoid loss of typability. This paper gives a type inference algorithm with the open and close mechanisms. In this paper, we deÔ¨Åne a type inference algorithm with the open and close constructs.},
	language = {en},
	urldate = {2023-11-04},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Ikemori, Kazuki and Cong, Youyou and Masuhara, Hidehiko and Leijen, Daan},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4_8},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {144--168},
	file = {Ikemori et al_2022_Sound and Complete Type Inference for Closed Effect Rows.pdf:/home/tim/Zotero/storage/DJM2GGQV/Ikemori et al_2022_Sound and Complete Type Inference for Closed Effect Rows.pdf:application/pdf;Ikemori et al_2023_Sound and Complete Type Inference for Closed Effect Rows.pdf:/home/tim/Zotero/storage/FL2CINY8/Ikemori et al_2023_Sound and Complete Type Inference for Closed Effect Rows.pdf:application/pdf},
}

@inproceedings{oliveira_type_2010,
	address = {New York, NY, USA},
	series = {{OOPSLA} '10},
	title = {Type {Classes} as {Objects} and {Implicits}},
	isbn = {978-1-4503-0203-6},
	url = {https://doi.org/10.1145/1869459.1869489},
	doi = {10.1145/1869459.1869489},
	abstract = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation.This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
	booktitle = {Proceedings of the {ACM} {International} {Conference} on {Object} {Oriented} {Programming} {Systems} {Languages} and {Applications}},
	publisher = {Association for Computing Machinery},
	author = {Oliveira, Bruno C.d.S. and Moors, Adriaan and Odersky, Martin},
	year = {2010},
	note = {event-place: Reno/Tahoe, Nevada, USA},
	keywords = {abstract datatypes, c++ concepts, scala, type classes, to-read},
	pages = {341--360},
	file = {Oliveira et al. - 2010 - Type Classes as Objects and Implicits.pdf:/home/tim/Zotero/storage/9C66UMN5/Oliveira et al. - 2010 - Type Classes as Objects and Implicits.pdf:application/pdf},
}

@article{spath_context-_2019,
	title = {Context-, flow-, and field-sensitive data-flow analysis using synchronized {Pushdown} systems},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3290361},
	doi = {10.1145/3290361},
	abstract = {Precise static analyses are context-, field- and flow-sensitive. Context- and field-sensitivity are both expressible as context-free language (CFL) reachability problems. Solving both CFL problems along the same data-flow path is undecidable, which is why most flow-sensitive data-flow analyses over-approximate field-sensitivity through
              k
              -limited access-path, or through access graphs. Unfortunately, as our experience and this paper show, both representations do not scale very well when used to analyze programs with recursive data structures.
            
            Any single CFL-reachability problem is efficiently solvable, by means of a pushdown system. This work thus introduces the concept of synchronized pushdown systems (SPDS). SPDS encode both procedure calls/returns and field stores/loads as separate but ‚Äúsynchronized‚Äù CFL reachability problems. An SPDS solves both individual problems precisely, and approximation occurs only in corner cases that are apparently rare in practice: at statements where both problems are satisfied but not along the same data-flow path.
            
              SPDS are also efficient: formal complexity analysis shows that SPDS shift the complexity from {\textbar}
              F
              {\textbar}
              
                3
                k
              
              under
              k
              -limiting to {\textbar}
              S
              {\textbar}{\textbar}
              F
              {\textbar}
              2
              , where
              F
              is the set of fields and
              S
              the set of statements involved in a data-flow. Our evaluation using DaCapo shows this shift to pay off in practice: SPDS are almost as efficient as
              k
              -limiting with
              k
              =1 although their precision equals
              k
              =‚àû. For a typestate analysis SPDS accelerate the analysis up to 83√ó for data-flows of objects that involve many field accesses but span rather few methods.
            
            We conclude that SPDS can provide high precision and further improve scalability, in particularly when used in analyses that expose rather local data flows.},
	language = {en},
	number = {POPL},
	urldate = {2023-10-25},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Sp√§th, Johannes and Ali, Karim and Bodden, Eric},
	month = jan,
	year = {2019},
	keywords = {to-read},
	pages = {1--29},
	file = {Sp√§th et al. - 2019 - Context-, flow-, and field-sensitive data-flow ana.pdf:/home/tim/Zotero/storage/73EI3H6A/Sp√§th et al. - 2019 - Context-, flow-, and field-sensitive data-flow ana.pdf:application/pdf},
}

@incollection{hermenegildo_lifting_2023,
	address = {Cham},
	title = {Lifting {On}-{Demand} {Analysis} to {Higher}-{Order} {Languages}},
	volume = {14284},
	isbn = {978-3-031-44244-5 978-3-031-44245-2},
	url = {https://link.springer.com/10.1007/978-3-031-44245-2_20},
	abstract = {In this paper, we present an approach to lift on-demand analysis to higher-order languages. Specifically, our approach bootstraps an on-demand call graph construction by leveraging a pair of on-demand data flow analyses. Static analysis is increasingly applied to find subtle bugs or prove deep properties in large, industrial code bases. To effectively do this at scale, analyzers need to both resolve function calls in a precise manner (i.e., construct a precise call graph) and examine only the relevant portion of the program (i.e., be on-demand). A strawman strategy to this problem is to use fast, approximate, whole-program call graph construction algorithms. However, this strategy is generally not adequate for modern languages like JavaScript that rely heavily on higher-order features, such as callbacks and closures, where scalable approximations often introduce unacceptable imprecision. This strategy also limits increasingly sophisticated on-demand analyses, which scale by analyzing only parts of a program as needed: the scalability advantages of an ondemand analysis may be thwarted by the need to construct a wholeprogram call graph. The key insight of this paper is that existing ondemand data flow analyses can themselves be applied in a black-box manner to construct call graphs on demand. We propose a soundness condition for the existing on-demand analyses with respect to partial call graphs, formalize our algorithm as an abstract domain combinator, and prove it sound in Isabelle/HOL. Furthermore, we evaluate a prototype implementation of the resulting on-demand call graph construction algorithm for a subset of JavaScript (using the Synchronized Push-Down Systems framework as the underlying data flow analysis) on benchmarks making heavy use of higher-order functions.},
	language = {en},
	urldate = {2023-10-25},
	booktitle = {Static {Analysis}},
	publisher = {Springer Nature Switzerland},
	author = {Schoepe, Daniel and Seekatz, David and Stoilkovska, Ilina and Stucki, Sandro and Tattersall, Daniel and Bolignano, Pauline and Raimondi, Franco and Chang, Bor-Yuh Evan},
	editor = {Hermenegildo, Manuel V. and Morales, Jos√© F.},
	year = {2023},
	doi = {10.1007/978-3-031-44245-2_20},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {460--484},
	file = {Schoepe et al. - 2023 - Lifting On-Demand Analysis to Higher-Order Languag.pdf:/home/tim/Zotero/storage/68VTF4LR/Schoepe et al. - 2023 - Lifting On-Demand Analysis to Higher-Order Languag.pdf:application/pdf},
}

@inproceedings{lewis_implicit_2000,
	address = {Boston MA USA},
	title = {Implicit parameters: dynamic scoping with static types},
	isbn = {978-1-58113-125-3},
	shorttitle = {Implicit parameters},
	url = {https://dl.acm.org/doi/10.1145/325694.325708},
	doi = {10.1145/325694.325708},
	abstract = {This paper introduces a language feature, called implicit parameters, that provides dynamically scoped variables within a statically-typed Hindley-Milner framework. Implicit parameters are lexically distinct from regular identifiers, and are bound by a special with construct whose scope is dynamic, rather than static as with let. Implicit parameters are treated by the type system as parameters that are not explicitly declared, but are inferred from their use. We present implicit parameters within a small call-by-name X-calculus. We give a type system, a type inference algorithm, and several semantics. We also explore implicit parameters in the wider settings of call-by-need languages with overloading, and call-by-value languages with effects. As a witness to the former, we have implemented implicit parameters as an extension of Haskell within the Hugs interpreter, which we use to present several motivating examples.},
	language = {en},
	urldate = {2023-10-23},
	booktitle = {Proceedings of the 27th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	publisher = {ACM},
	author = {Lewis, Jeffrey R. and Launchbury, John and Meijer, Erik and Shields, Mark B.},
	month = jan,
	year = {2000},
	keywords = {to-read},
	pages = {108--118},
	file = {Lewis et al. - 2000 - Implicit parameters dynamic scoping with static t.pdf:/home/tim/Zotero/storage/9ZJZPJWY/Lewis et al. - 2000 - Implicit parameters dynamic scoping with static t.pdf:application/pdf},
}

@article{waddell_fast_nodate,
	title = {Fast and {Effective} {Procedure} {Inlining}},
	abstract = {Inlining is an important optimization for programs that use procedural abstraction. Because inlining trades code size for execution speed, the e ectiveness of an inlining algorithm is determined not only by its ability to recognize inlining opportunities but also by its discretion in exercising those opportunities. This paper presents a new inlining algorithm for higher-order languages that combines simple analysis techniques with demand-driven online transformation to achieve consistent and often dramatic performance gains in fast linear time. Benchmark results reported here demonstrate that this inlining algorithm is as e ective as and signi cantly faster than o ine, analysis-intensive algorithms recently described in the literature.},
	language = {en},
	author = {Waddell, Oscar and Dybvig, R Kent},
	keywords = {to-read},
	file = {Waddell and Dybvig - Fast and Effective Procedure Inlining.pdf:/home/tim/Zotero/storage/6APJVM5A/Waddell and Dybvig - Fast and Effective Procedure Inlining.pdf:application/pdf},
}

@article{germane_demand_nodate,
	title = {{DEMAND} {ENVIRONMENT} {ANALYSIS} {OF} {HIGHER}-{ORDER} {LANGUAGES}},
	language = {en},
	author = {Germane, Kimball Richard},
	keywords = {to-read},
	file = {Germane - DEMAND ENVIRONMENT ANALYSIS OF HIGHER-ORDER LANGUA.pdf:/home/tim/Zotero/storage/Y9U99WBP/Germane - DEMAND ENVIRONMENT ANALYSIS OF HIGHER-ORDER LANGUA.pdf:application/pdf},
}

@inproceedings{schwarz_when_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {When {Long} {Jumps} {Fall} {Short}: {Control}-{Flow} {Tracking} and {Misuse} {Detection} for {Non}-{Local} {Jumps} in {C}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596140},
	doi = {10.1145/3589250.3596140},
	abstract = {The C programming language offers setjmp/longjmp as a mechanism for non-local control flow. This mechanism has complicated semantics. As most developers do not encounter it day-to-day, they may be unfamiliar with all its intricacies ‚Äì leading to subtle programming errors. At the same time, most static analyzers lack proper support, implying that otherwise sound tools miss whole classes of program deficiencies. We propose an approach for lifting existing interprocedural analyses to support setjmp/longjmp, as well as to flag their misuse. To deal with the non-local semantics, our approach leverages side-effecting transfer functions which, when executed, may trigger contributions to extra program points. We showcase our analysis on real-world examples and propose a set of litmus tests for other analyzers.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Schwarz, Michael and Erhard, Julian and Vojdani, Vesal and Saan, Simmo and Seidl, Helmut},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {Abstract Interpretation, setjmp / longjmp, Side-Effects, Static Analysis, to-read},
	pages = {20--26},
	file = {Schwarz et al. - 2023 - When Long Jumps Fall Short Control-Flow Tracking .pdf:/home/tim/Zotero/storage/RCSAZW5C/Schwarz et al. - 2023 - When Long Jumps Fall Short Control-Flow Tracking .pdf:application/pdf},
}

@inproceedings{negrini_static_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {Static {Analysis} of {Data} {Transformations} in {Jupyter} {Notebooks}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596145},
	doi = {10.1145/3589250.3596145},
	abstract = {Jupyter notebooks used to pre-process and polish raw data for data science and machine learning processes are challenging to analyze. Their data-centric code manipulates dataframes through call to library functions with complex semantics, and the properties to track over it vary widely depending on the verification task. This paper presents a novel abstract domain that simplifies writing analyses for such programs, by extracting a unique CFG from the notebook that contains all transformations applied to the data. Several properties can then be determined by analyzing such CFG, that is simpler than the original Python code. We present a first use case that exploits our analysis to infer the required shape of the dataframes manipulated by the notebook.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Negrini, Luca and Shabadi, Guruprerana and Urban, Caterina},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {Abstract Interpretation, Static Analysis, Data Science, Jupyter Notebooks, to-read},
	pages = {8--13},
	file = {Negrini et al. - 2023 - Static Analysis of Data Transformations in Jupyter.pdf:/home/tim/Zotero/storage/I2ZQD8LE/Negrini et al. - 2023 - Static Analysis of Data Transformations in Jupyter.pdf:application/pdf},
}

@inproceedings{coward_combining_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {Combining {E}-{Graphs} with {Abstract} {Interpretation}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596144},
	doi = {10.1145/3589250.3596144},
	abstract = {E-graphs are a data structure that compactly represents equivalent expressions. They are constructed via the repeated application of rewrite rules. Often in practical applications, conditional rewrite rules are crucial, but their application requires the detection ‚Äì at the time the e-graph is being built ‚Äì that a condition is valid in the domain of application. Detecting condition validity amounts to proving a property of the program. Abstract interpretation is a general method to learn such properties, traditionally used in static analysis tools. We demonstrate that abstract interpretation and e-graph analysis naturally reinforce each other through a tight integration because (i) the e-graph clustering of equivalent expressions induces natural precision refinement of abstractions and (ii) precise abstractions allow the application of deeper rewrite rules (and hence potentially even greater precision). We develop the theory behind this intuition and present an exemplar interval arithmetic implementation, which we apply to the FPBench suite.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Coward, Samuel and Constantinides, George A. and Drane, Theo},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {abstract interpretation, e-graph, interval arithmetic, static analysis, to-read},
	pages = {1--7},
	file = {Coward et al. - 2023 - Combining E-Graphs with Abstract Interpretation.pdf:/home/tim/Zotero/storage/7BBQBA7K/Coward et al. - 2023 - Combining E-Graphs with Abstract Interpretation.pdf:application/pdf},
}

@article{sieczkowski_general_2023,
	title = {A {General} {Fine}-{Grained} {Reduction} {Theory} for {Effect} {Handlers}},
	volume = {7},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Sieczkowski, Filip and Pyzik, Mateusz and Biernacki, Dariusz},
	year = {2023},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {extra-to-read},
	pages = {511--540},
	file = {Sieczkowski et al. - 2023 - A General Fine-Grained Reduction Theory for Effect.pdf:/home/tim/Zotero/storage/WSJLKG7E/Sieczkowski et al. - 2023 - A General Fine-Grained Reduction Theory for Effect.pdf:application/pdf},
}

@misc{akinshin_statistical_2020,
	title = {Statistical approaches for performance analysis},
	url = {https://aakinshin.net/posts/statistics-for-performance/},
	urldate = {2023-09-12},
	author = {Akinshin, Andrey},
	month = dec,
	year = {2020},
	keywords = {to-read},
}

@techreport{siskind_flow-directed_1999,
	title = {Flow-directed lightweight closure conversion},
	institution = {Technical Report 99-190R, NEC Research Institute, Inc},
	author = {Siskind, Jeffrey Mark},
	year = {1999},
	keywords = {to-read},
	file = {Siskind - 1999 - Flow-directed lightweight closure conversion.pdf:/home/tim/Zotero/storage/QITEFWCH/Siskind - 1999 - Flow-directed lightweight closure conversion.pdf:application/pdf},
}

@article{dybvig_development_2006,
	title = {The development of chez scheme},
	volume = {41},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Dybvig, R Kent},
	year = {2006},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--12},
}

@article{weeks_whole-program_2006,
	title = {Whole-program compilation in {MLton}},
	volume = {6},
	journal = {ML},
	author = {Weeks, Stephen},
	year = {2006},
	keywords = {to-read},
	pages = {1--1},
}

@article{karachalias_efficient_2021,
	title = {Efficient compilation of algebraic effect handlers},
	volume = {5},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Karachalias, Georgios and Koprivec, Filip and Pretnar, Matija and Schrijvers, Tom},
	year = {2021},
	note = {Publisher: Association for Computing Machinery (ACM)},
	keywords = {to-read},
	file = {Karachalias et al. - 2021 - Efficient compilation of algebraic effect handlers.pdf:/home/tim/Zotero/storage/LCPGJ7CJ/Karachalias et al. - 2021 - Efficient compilation of algebraic effect handlers.pdf:application/pdf},
}

@misc{noauthor_home_nodate,
	title = {Home},
	url = {https://effects.js.org/},
	abstract = {Algebraic Effects in Javascript},
	language = {en},
	urldate = {2023-09-11},
	keywords = {to-read},
	file = {Snapshot:/home/tim/Zotero/storage/HN9FLNEG/effects.js.org.html:text/html},
}

@misc{noauthor_effect_2023,
	title = {Effect},
	url = {https://effect.website/},
	abstract = {A fully-fledged functional effect system for TypeScript with a rich standard library},
	language = {en},
	urldate = {2023-09-11},
	month = aug,
	year = {2023},
	keywords = {to-read},
	file = {Snapshot:/home/tim/Zotero/storage/CID5CCYK/effect.website.html:text/html},
}

@article{brandl_modular_2023,
	title = {Modular {Abstract} {Definitional} {Interpreters} for {WebAssembly}},
	abstract = {Even though static analyses can improve performance and secure programs against vulnerabilities, no static whole-program analyses exist for WebAssembly (Wasm) to date. Part of the reason is that Wasm has many complex language concerns, and it is not obvious how to adopt existing analysis frameworks for these features. This paper explores how abstract definitional interpretation can be used to develop sophisticated analyses for Wasm and other complex languages efficiently. In particular, we show that the semantics of Wasm can be decomposed into 19 language-independent components that abstract different aspects of Wasm. We have written a highly configurable definitional interpreter for full Wasm 1.0 in 1628 LOC against these components. Analysis developers can instantiate this interpreter with different value and effect abstractions to obtain abstract definitional interpreters that compute inter-procedural control and data-flow information. This way, we develop the first whole-program dead code, constant propagation, and taint analyses for Wasm, each in less than 210 LOC. We evaluate our analyses on 1458 Wasm binaries collected by others in the wild. Our implementation is based on a novel framework for definitional abstract interpretation in Scala that eliminates scalability issues of prior work.},
	language = {en},
	author = {Brandl, Katharina and Erdweg, Sebastian and Keidel, Sven and Hansen, Nils},
	year = {2023},
	keywords = {to-read},
	file = {Brandl et al. - 2023 - Modular Abstract Definitional Interpreters for Web.pdf:/home/tim/Zotero/storage/UBY3M7LG/Brandl et al. - 2023 - Modular Abstract Definitional Interpreters for Web.pdf:application/pdf},
}

@article{xie_macocaml_2023,
	title = {{MacoCaml}: {Staging} {Composable} and {Compilable} {Macros}},
	volume = {7},
	url = {https://doi.org/10.1145/3607851},
	doi = {10.1145/3607851},
	abstract = {We introduce MacoCaml, a new design and implementation of compile-time code generation for the OCaml language. MacoCaml features a novel combination of macros with phase separation and quotation-based staging, where macros are considered as compile-time bindings, expression cross evaluation phases using staging annotations, and compile-time evaluation happens inside top-level splices. We provide a theoretical foundation for MacoCaml by formalizing a typed source calculus maco that supports interleaving typing and compile-time code generation, references with explicit compile-time heaps, and modules. We study various crucial properties including soundness and phase distinction. We have implemented MacoCaml in the OCaml compiler, and ported two substantial existing libraries to validate our implementation.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Xie, Ningning and White, Leo and Nicole, Olivier and Yallop, Jeremy},
	month = aug,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Compile-time code generation, Macros, OCaml, Staging, to-read},
	file = {Xie et al. - 2023 - MacoCaml Staging Composable and Compilable Macros.pdf:/home/tim/Zotero/storage/BTHWANWR/Xie et al. - 2023 - MacoCaml Staging Composable and Compilable Macros.pdf:application/pdf},
}

@inproceedings{lindley_algebraic_2014,
	address = {New York, NY, USA},
	series = {{WGP} '14},
	title = {Algebraic {Effects} and {Effect} {Handlers} for {Idioms} and {Arrows}},
	isbn = {978-1-4503-3042-8},
	url = {https://doi.org/10.1145/2633628.2633636},
	doi = {10.1145/2633628.2633636},
	abstract = {Plotkin and Power's algebraic effects combined with Plotkin and Pretnar's effect handlers provide a foundation for modular programming with effects. We present a generalisation of algebraic effects and effect handlers to support other kinds of effectful computations corresponding to McBride and Paterson's idioms and Hughes' arrows.},
	booktitle = {Proceedings of the 10th {ACM} {SIGPLAN} {Workshop} on {Generic} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Lindley, Sam},
	year = {2014},
	note = {event-place: Gothenburg, Sweden},
	keywords = {algebraic effects, applicative functors, arrows, call-by-push-value, effect handlers, idioms, monads, to-read},
	pages = {47--58},
	file = {Lindley - 2014 - Algebraic Effects and Effect Handlers for Idioms a.pdf:/home/tim/Zotero/storage/XXF3T69A/Lindley - 2014 - Algebraic Effects and Effect Handlers for Idioms a.pdf:application/pdf},
}

@article{hughes_generalising_2000,
	title = {Generalising monads to arrows},
	volume = {37},
	issn = {0167-6423},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642399000234},
	doi = {https://doi.org/10.1016/S0167-6423(99)00023-4},
	abstract = {Monads have become very popular for structuring functional programs since Wadler introduced their use in 1990. In particular, libraries of combinators are often based on a monadic type. Such libraries share (in part) a common interface, from which numerous benefits flow, such as the possibility to write generic code which works together with any library. But, several interesting and useful libraries are fundamentally incompatible with the monadic interface. In this paper I propose a generalisation of monads, which I call arrows, with significantly wider applicability. The paper shows how many of the techniques of monadic programming generalise to the new setting, and gives examples to show that the greater generality is useful. In particular, three non-monadic libraries for efficient parsing, building graphical user interfaces, and programming active web pages fit naturally into the new framework.},
	number = {1},
	journal = {Science of Computer Programming},
	author = {Hughes, John},
	year = {2000},
	keywords = {to-read},
	pages = {67--111},
	file = {Hughes - 2000 - Generalising monads to arrows.pdf:/home/tim/Zotero/storage/T6HY3WMY/Hughes - 2000 - Generalising monads to arrows.pdf:application/pdf},
}

@inproceedings{xie_haskell_2023,
	address = {New York, NY, USA},
	series = {Haskell 2023},
	title = {Haskell for {Choice}-{Based} {Learning} ({Keynote})},
	isbn = {9798400702983},
	url = {https://doi.org/10.1145/3609026.3615580},
	doi = {10.1145/3609026.3615580},
	abstract = {Machine learning has achieved many successes during the past decades, spanning domains of game-playing, protein folding, competitive programming, and many others. However, while there have been major efforts in building programming techniques and frameworks for machine learning programming, there has been very little study of general language design for machine learning programming. We pursue such a study in this talk, focusing on choice-based learning, particularly where choices are driven by optimizations. This includes widely-used decision-making models and techniques (e.g., Markov decision processes or gradient descent) which provide frameworks for describing systems in terms of choices (e.g., actions or parameters) and their resulting feedback as losses (dually, rewards). We propose and give evidence for the following thesis: languages for choice-based learning can be obtained by combining two paradigms, algebraic effects and handlers, and the selection monad. We provide a prototype implementation as a Haskell library and present a variety of programming examples for choice-based learning: stochastic gradient descent, hyperparameter tuning, generative adversarial networks, and reinforcement learning.},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Haskell} {Symposium}},
	publisher = {Association for Computing Machinery},
	author = {Xie, Ningning},
	year = {2023},
	note = {event-place: Seattle, WA, USA},
	keywords = {to-read},
	pages = {1},
}

@article{pinto_exploring_nodate,
	title = {Exploring {Perceus} {For} {OCaml}},
	language = {en},
	author = {Pinto, Elton and Leijen, Daan},
	keywords = {to-read},
	file = {Pinto and Leijen - Exploring Perceus For OCaml.pdf:/home/tim/Zotero/storage/MLLBRNVX/Pinto and Leijen - Exploring Perceus For OCaml.pdf:application/pdf},
}

@inproceedings{nguyen_effect_2023,
	address = {New York, NY, USA},
	series = {Haskell 2023},
	title = {Effect {Handlers} for {Programmable} {Inference}},
	isbn = {9798400702983},
	url = {https://doi.org/10.1145/3609026.3609729},
	doi = {10.1145/3609026.3609729},
	abstract = {Inference algorithms for probabilistic programming are complex imperative programs with many moving parts. Efficient inference often requires customising an algorithm to a particular probabilistic model or problem, sometimes called inference programming. Most inference frameworks are implemented in languages that lack a disciplined approach to side effects, which can result in monolithic implementations where the structure of the algorithms is obscured and inference programming is hard. Functional programming with typed effects offers a more structured and modular foundation for programmable inference, with monad transformers being the primary structuring mechanism explored to date. This paper presents an alternative approach to inference programming based on algebraic effects. Using effect signatures to specify the key operations of the algorithms, and effect handlers to modularly interpret those operations for specific variants, we develop two abstract algorithms, or inference patterns, representing two important classes of inference: Metropolis-Hastings and particle filtering. We show how our approach reveals the algorithms‚Äô high-level structure, and makes it easy to tailor and recombine their parts into new variants. We implement the two inference patterns as a Haskell library, and discuss the pros and cons of algebraic effects vis-√†-vis monad transformers as a structuring mechanism for modular imperative algorithm design.},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Haskell} {Symposium}},
	publisher = {Association for Computing Machinery},
	author = {Nguyen, Minh and Perera, Roly and Wang, Meng and Ramsay, Steven},
	year = {2023},
	note = {event-place: Seattle, WA, USA},
	keywords = {algebraic effects, functional programming, modularity, probabilistic programming, to-read},
	pages = {44--58},
	file = {Nguyen et al. - 2023 - Effect Handlers for Programmable Inference.pdf:/home/tim/Zotero/storage/KBYXTB5E/Nguyen et al. - 2023 - Effect Handlers for Programmable Inference.pdf:application/pdf},
}

@inproceedings{wu_evolution_2023,
	address = {New York, NY, USA},
	series = {Haskell 2023},
	title = {The {Evolution} of {Effects} ({Keynote})},
	isbn = {9798400702983},
	url = {https://doi.org/10.1145/3609026.3615581},
	doi = {10.1145/3609026.3615581},
	abstract = {Functional programming has been celebrated for its promise of pure functions, delivering referential transparency and elegant reasoning about programs. However, real-world applications are not pure, and necessitate interaction with the outside world, introducing computational effects such as IO, state, and exceptions. The journey to harmonize these seemingly contradictory paradigms has led to a fascinating evolution of effectful programming in Haskell. The introduction of monads as a practical programming tool was a pivotal discovery, enabling controlled sequencing of effectful computations and addressing the challenge of handling side effects in a pure language. However, it soon became evident that the lack of modularity in composing effects using monads posed a limitation to effectful programming. To overcome this obstacle, monad transformers emerged as a solution, providing a composable manner of building effects on top of one another. More recent advancements have led to algebraic effects as an alternative framework that is easy to extend, particularly as domain-specific languages crafted to work in specific contexts. Nevertheless, these effects are not without quirks and limitations, leading to the development of higher-order effects. These higher-order effects extend the capabilities of algebraic effects, providing greater flexibility for expressing effectful computations, while also shedding light on the connection between the monad approach and the algebraic approach to effects. This talk will survey the historical milestones that have shaped the landscape of effectful programming in Haskell, exploring the transition from monads to monad transformers and the emergence of algebraic and higher-order effects.},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Haskell} {Symposium}},
	publisher = {Association for Computing Machinery},
	author = {Wu, Nicolas},
	year = {2023},
	note = {event-place: Seattle, WA, USA},
	keywords = {to-read},
	pages = {2},
	file = {Wu - 2023 - The Evolution of Effects (Keynote).pdf:/home/tim/Zotero/storage/G92EUW56/Wu - 2023 - The Evolution of Effects (Keynote).pdf:application/pdf},
}

@article{hubers_generic_2023,
	title = {Generic {Programming} with {Extensible} {Data} {Types}: {Or}, {Making} {Ad} {Hoc} {Extensible} {Data} {Types} {Less} {Ad} {Hoc}},
	volume = {7},
	url = {https://doi.org/10.1145/3607843},
	doi = {10.1145/3607843},
	abstract = {We present a novel approach to generic programming over extensible data types. Row types capture the structure of records and variants, and can be used to express record and variant subtyping, record extension, and modular composition of case branches. We extend row typing to capture generic programming over rows themselves, capturing patterns including lifting operations to records and variations from their component types, and the duality between cases blocks over variants and records of labeled functions, without placing specific requirements on the fields or constructors present in the records and variants. We formalize our approach in System Rùúî, an extension of Fùúî with row types, and give a denotational semantics for (stratified) Rùúî in Agda.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Hubers, Alex and Morris, J. Garrett},
	month = aug,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {extensible data types, generic programming, qualified types, row polymorphism, row types, to-read},
	file = {Hubers and Morris - 2023 - Generic Programming with Extensible Data Types Or.pdf:/home/tim/Zotero/storage/5GRVM9CX/Hubers and Morris - 2023 - Generic Programming with Extensible Data Types Or.pdf:application/pdf},
}

@article{keidel_combinator-based_2023,
	title = {Combinator-{Based} {Fixpoint} {Algorithms} for {Big}-{Step} {Abstract} {Interpreters}},
	volume = {7},
	url = {https://doi.org/10.1145/3607863},
	doi = {10.1145/3607863},
	abstract = {Big-step abstract interpreters are an approach to build static analyzers based on big-step interpretation. While big-step interpretation provides a number of benefits for the definition of an analysis, it also requires particularly complicated fixpoint algorithms because the analysis definition is a recursive function whose termination is uncertain. This is in contrast to other analysis approaches, such as small-step reduction, abstract machines, or graph reachability, where the analysis essentially forms a finite transition system between widened analysis states. We show how to systematically develop sophisticated fixpoint algorithms for big-step abstract interpreters and how to ensure their soundness. Our approach is based on small and reusable fixpoint combinators that can be composed to yield fixpoint algorithms. For example, these combinators describe the order in which the program is analyzed, how deep recursive functions are unfolded and loops unrolled, or they record auxiliary data such as a (context-sensitive) call graph. Importantly, each combinator can be developed separately, reused across analyses, and can be verified sound independently. Consequently, analysis developers can freely compose combinators to obtain sound fixpoint algorithms that work best for their use case. We provide a formal metatheory that guarantees a fixpoint algorithm is sound if its composed from sound combinators only. We experimentally validate our combinator-based approach by describing sophisticated fixpoint algorithms for analyses of Stratego, Scheme, and WebAssembly.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Keidel, Sven and Erdweg, Sebastian and Homb√ºcher, Tobias},
	month = aug,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Static Analysis, Big-Step Abstract Interpretation, Fixpoint Algorithm, to-read},
	file = {Keidel et al. - 2023 - Combinator-Based Fixpoint Algorithms for Big-Step .pdf:/home/tim/Zotero/storage/TGC6RY9K/Keidel et al. - 2023 - Combinator-Based Fixpoint Algorithms for Big-Step .pdf:application/pdf},
}

@article{duesterwald_practical_1997,
	title = {A practical framework for demand-driven interprocedural data flow analysis},
	volume = {19},
	number = {6},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Duesterwald, Evelyn and Gupta, Rajiv and Soffa, Mary Lou},
	year = {1997},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {992--1030},
	file = {Duesterwald et al. - 1997 - A practical framework for demand-driven interproce.pdf:/home/tim/Zotero/storage/6ULR935R/Duesterwald et al. - 1997 - A practical framework for demand-driven interproce.pdf:application/pdf},
}

@article{author_context-sensitive_nodate,
	title = {Context-{Sensitive} {Demand}-{Driven} {Control}-{Flow} {Analysis}},
	language = {en},
	journal = {Flow Analysis},
	author = {Author, Anonymous},
	keywords = {to-read},
	file = {Author_Context-Sensitive Demand-Driven Control-Flow Analysis.pdf:/home/tim/Zotero/storage/KJE2L9YQ/Author_Context-Sensitive Demand-Driven Control-Flow Analysis.pdf:application/pdf;demand-cfa (1).rkt:/home/tim/Zotero/storage/4ABVI45L/demand-cfa (1).rkt:text/plain;paper.pdf:/home/tim/context-sensitive-demand-cfa/paper.pdf:application/pdf},
}

@article{mine_octagon_2006,
	title = {The octagon abstract domain},
	volume = {19},
	journal = {Higher-order and symbolic computation},
	author = {Min√©, Antoine},
	year = {2006},
	note = {Publisher: Springer},
	keywords = {to-read},
	pages = {31--100},
	file = {Min√© - 2006 - The octagon abstract domain.pdf:/home/tim/Zotero/storage/SG75L3ZR/Min√© - 2006 - The octagon abstract domain.pdf:application/pdf},
}

@inproceedings{plotkin_logic_2008,
	title = {A logic for algebraic effects},
	booktitle = {2008 23rd {Annual} {IEEE} symposium on logic in computer science},
	publisher = {IEEE},
	author = {Plotkin, Gordon and Pretnar, Matija},
	year = {2008},
	keywords = {to-read},
	pages = {118--129},
	file = {Plotkin and Pretnar - 2008 - A logic for algebraic effects.pdf:/home/tim/Zotero/storage/6SGA8BDK/Plotkin and Pretnar - 2008 - A logic for algebraic effects.pdf:application/pdf},
}

@inproceedings{plotkin_handlers_2009,
	title = {Handlers of algebraic effects},
	booktitle = {European {Symposium} on {Programming}},
	publisher = {Springer},
	author = {Plotkin, Gordon and Pretnar, Matija},
	year = {2009},
	keywords = {to-read},
	pages = {80--94},
	file = {Plotkin and Pretnar - 2009 - Handlers of algebraic effects.pdf:/home/tim/Zotero/storage/B5TC48XR/Plotkin and Pretnar - 2009 - Handlers of algebraic effects.pdf:application/pdf;Plotkin_Pretnar_2009_Handlers of algebraic effects2.pdf:/home/tim/Zotero/storage/L9J8DXFW/Plotkin_Pretnar_2009_Handlers of algebraic effects2.pdf:application/pdf},
}

@inproceedings{might_shape_2010,
	title = {Shape analysis in the absence of pointers and structure},
	booktitle = {International {Workshop} on {Verification}, {Model} {Checking}, and {Abstract} {Interpretation}},
	publisher = {Springer},
	author = {Might, Matthew},
	year = {2010},
	keywords = {to-read},
	pages = {263--278},
	file = {Might - 2010 - Shape analysis in the absence of pointers and stru.pdf:/home/tim/Zotero/storage/BHF32VQP/Might - 2010 - Shape analysis in the absence of pointers and stru.pdf:application/pdf},
}

@inproceedings{bergstrom_practical_2014,
	address = {New York, NY, USA},
	series = {{ICFP} '14},
	title = {Practical and {Effective} {Higher}-{Order} {Optimizations}},
	isbn = {978-1-4503-2873-9},
	url = {https://doi.org/10.1145/2628136.2628153},
	doi = {10.1145/2628136.2628153},
	abstract = {Inlining is an optimization that replaces a call to a function with that function's body. This optimization not only reduces the overhead of a function call, but can expose additional optimization opportunities to the compiler, such as removing redundant operations or unused conditional branches. Another optimization, copy propagation, replaces a redundant copy of a still-live variable with the original. Copy propagation can reduce the total number of live variables, reducing register pressure and memory usage, and possibly eliminating redundant memory-to-memory copies. In practice, both of these optimizations are implemented in nearly every modern compiler.These two optimizations are practical to implement and effective in first-order languages, but in languages with lexically-scoped first-class functions (aka, closures), these optimizations are not available to code programmed in a higher-order style. With higher-order functions, the analysis challenge has been that the environment at the call site must be the same as at the closure capture location, up to the free variables, or the meaning of the program may change. Olin Shivers' 1991 dissertation called this family of optimizations superŒí and he proposed one analysis technique, called reflow, to support these optimizations. Unfortunately, reflow has proven too expensive to implement in practice. Because these higher-order optimizations are not available in functional-language compilers, programmers studiously avoid uses of higher-order values that cannot be optimized (particularly in compiler benchmarks).This paper provides the first practical and effective technique for superŒí (higher-order) inlining and copy propagation, which we call unchanged variable analysis. We show that this technique is practical by implementing it in the context of a real compiler for an ML-family language and showing that the required analyses have costs below 3\% of the total compilation time. This technique's effectiveness is shown through a set of benchmarks and example programs, where this analysis exposes additional potential optimization sites.},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	publisher = {Association for Computing Machinery},
	author = {Bergstrom, Lars and Fluet, Matthew and Le, Matthew and Reppy, John and Sandler, Nora},
	year = {2014},
	note = {event-place: Gothenburg, Sweden},
	keywords = {control-flow analysis, inlining, optimization, to-read},
	pages = {81--93},
	file = {Bergstrom et al. - 2014 - Practical and Effective Higher-Order Optimizations.pdf:/home/tim/Zotero/storage/SYY5VMWX/Bergstrom et al. - 2014 - Practical and Effective Higher-Order Optimizations.pdf:application/pdf},
}

@inproceedings{stein_demanded_2021,
	title = {Demanded abstract interpretation},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Stein, Benno and Chang, Bor-Yuh Evan and Sridharan, Manu},
	year = {2021},
	keywords = {to-read},
	pages = {282--295},
	file = {Stein et al. - 2021 - Demanded abstract interpretation.pdf:/home/tim/Zotero/storage/NNNEYJWQ/Stein et al. - 2021 - Demanded abstract interpretation.pdf:application/pdf},
}

@article{ma_context_2023,
	title = {Context {Sensitivity} without {Contexts}: {A} {Cut}-{Shortcut} {Approach} to {Fast} and {Precise} {Pointer} {Analysis}},
	volume = {7},
	url = {https://doi.org/10.1145/3591242},
	doi = {10.1145/3591242},
	abstract = {Over the past decades, context sensitivity has been considered as one of the most effective ideas for improving the precision of pointer analysis for Java. Different from the extremely fast context-insensitivity approach, context sensitivity requires every program method to be analyzed under different contexts for separating the static abstractions of different dynamic instantiations of the method‚Äôs variables and heap objects, and thus reducing spurious object flows introduced by method calls. However, despite great precision benefits, as each method is equivalently cloned and analyzed under each context, context sensitivity brings heavy efficiency costs. Recently, numerous selective context-sensitive approaches have been put forth for scaling pointer analysis to large and complex Java programs by applying contexts only to the selected methods while analyzing the remaining ones context-insensitively; however, because the selective approaches do not fundamentally alter the primary methodology of context sensitivity (and do not thus remove its efficiency bottleneck), they produce much improved but still limited results. In this work, we present a fundamentally different approach called Cut-Shortcut for fast and precise pointer analysis for Java. Its insight is simple: the main effect of cloning methods under different contexts is to filter spurious object flows that have been merged inside a callee method; from the view of a typical pointer flow graph (PFG), such effect can be simulated by cutting off (Cut) the edges that introduce precision loss to certain pointers and adding Shortcut edges directly from source pointers to the target ones circumventing the method on PFG. As a result, we can achieve the effect of context sensitivity without contexts. We identify three general program patterns and develop algorithms based on them to safely cut off and add shortcut edges on PFG, formalize them and formally prove the soundness. To comprehensively validate Cut-Shortcut‚Äôs effectiveness, we implement two versions of Cut-Shortcut for two state-of-the-art pointer analysis frameworks for Java, one in Datalog for the declarative Doop and the other in Java for the imperative Tai-e, and we consider all the large and complex programs used in recent literatures that meet the experimental requirements. The evaluation results are extremely promising: Cut-Shortcut is even able to run faster than context insensitivity for most evaluated programs while obtaining high precision that is comparable to context sensitivity (if scalable) in both frameworks. This is for the first time that we have been able to achieve such a good efficiency and precision trade-off for those hard-to-analyze programs, and we hope Cut-Shortcut could offer new perspectives for developing more effective pointer analysis for Java in the future.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Ma, Wenjie and Yang, Shengyuan and Tan, Tian and Ma, Xiaoxing and Xu, Chang and Li, Yue},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Alias Analysis, Context Sensitivity, Java, Pointer Analysis, to-read},
	file = {Ma et al. - 2023 - Context Sensitivity without Contexts A Cut-Shortc.pdf:/home/tim/Zotero/storage/5QATY4T8/Ma et al. - 2023 - Context Sensitivity without Contexts A Cut-Shortc.pdf:application/pdf},
}

@inproceedings{nicolay_effect-driven_2019,
	title = {Effect-driven flow analysis},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}: 20th {International} {Conference}, {VMCAI} 2019, {Cascais}, {Portugal}, {January} 13‚Äì15, 2019, {Proceedings} 20},
	publisher = {Springer},
	author = {Nicolay, Jens and Sti√©venart, Quentin and De Meuter, Wolfgang and De Roover, Coen},
	year = {2019},
	keywords = {to-read},
	pages = {247--274},
	file = {Nicolay et al. - 2019 - Effect-driven flow analysis.pdf:/home/tim/Zotero/storage/DQNDNKRI/Nicolay et al. - 2019 - Effect-driven flow analysis.pdf:application/pdf},
}

@inproceedings{heintze_linear-time_1997,
	title = {Linear-time subtransitive control flow analysis},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1997 conference on {Programming} language design and implementation},
	author = {Heintze, Nevin and McAllester, David},
	year = {1997},
	keywords = {to-read},
	pages = {261--272},
	file = {Heintze and McAllester - 1997 - Linear-time subtransitive control flow analysis.pdf:/home/tim/Zotero/storage/Y3SBSFX2/Heintze and McAllester - 1997 - Linear-time subtransitive control flow analysis.pdf:application/pdf},
}

@inproceedings{midtgaard_calculational_2008,
	title = {A calculational approach to control-flow analysis by abstract interpretation},
	booktitle = {International {Static} {Analysis} {Symposium}},
	publisher = {Springer},
	author = {Midtgaard, Jan and Jensen, Thomas},
	year = {2008},
	keywords = {to-read},
	pages = {347--362},
	file = {Midtgaard and Jensen - 2008 - A calculational approach to control-flow analysis .pdf:/home/tim/Zotero/storage/VRMJIQ48/Midtgaard and Jensen - 2008 - A calculational approach to control-flow analysis .pdf:application/pdf},
}

@inproceedings{biswas_demand-driven_1997,
	title = {A demand-driven set-based analysis},
	booktitle = {Proceedings of the 24th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Biswas, Sandip K},
	year = {1997},
	keywords = {to-read},
	pages = {372--385},
	file = {Biswas - 1997 - A demand-driven set-based analysis.pdf:/home/tim/Zotero/storage/2PEF6TME/Biswas - 1997 - A demand-driven set-based analysis.pdf:application/pdf},
}

@inproceedings{shivers_modular_2011,
	title = {Modular rollback through control logging: a pair of twin functional pearls},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Shivers, Olin and Turon, Aaron J},
	year = {2011},
	keywords = {to-read, extra-to-read},
	pages = {58--68},
	file = {Shivers and Turon - 2011 - Modular rollback through control logging a pair o.pdf:/home/tim/Zotero/storage/8TIC9TV5/Shivers and Turon - 2011 - Modular rollback through control logging a pair o.pdf:application/pdf},
}

@article{harrison_compiler_1977,
	title = {Compiler analysis of the value ranges for variables},
	number = {3},
	journal = {IEEE Transactions on software engineering},
	author = {Harrison, William H.},
	year = {1977},
	note = {Publisher: IEEE},
	keywords = {to-read},
	pages = {243--250},
	file = {Harrison - 1977 - Compiler analysis of the value ranges for variable.pdf:/home/tim/Zotero/storage/MHIF7MLR/Harrison - 1977 - Compiler analysis of the value ranges for variable.pdf:application/pdf},
}

@inproceedings{glaze_abstracting_2014,
	title = {Abstracting abstract control},
	booktitle = {Proceedings of the 10th {ACM} {Symposium} on {Dynamic} languages},
	author = {Glaze, Dionna and Van Horn, David},
	year = {2014},
	keywords = {to-read},
	pages = {11--22},
	file = {1305.3163v8.pdf:/home/tim/Zotero/storage/FGSJDH3B/1305.3163v8.pdf:application/pdf;Glaze and Van Horn - 2014 - Abstracting abstract control.pdf:/home/tim/Zotero/storage/DHHPJFWN/Glaze and Van Horn - 2014 - Abstracting abstract control.pdf:application/pdf},
}

@article{hoare_proof_1971,
	title = {Proof of a program: {FIND}},
	volume = {14},
	number = {1},
	journal = {Communications of the ACM},
	author = {Hoare, Charles AR},
	year = {1971},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {39--45},
	file = {Hoare - 1971 - Proof of a program FIND.pdf:/home/tim/Zotero/storage/IRNAB2IF/Hoare - 1971 - Proof of a program FIND.pdf:application/pdf},
}

@article{hoare_axiomatic_1969,
	title = {An axiomatic basis for computer programming},
	volume = {12},
	number = {10},
	journal = {Communications of the ACM},
	author = {Hoare, Charles Antony Richard},
	year = {1969},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {576--580},
	file = {Hoare - 1969 - An axiomatic basis for computer programming.pdf:/home/tim/Zotero/storage/LZ2ESL28/Hoare - 1969 - An axiomatic basis for computer programming.pdf:application/pdf},
}

@inproceedings{reynolds_separation_2002,
	title = {Separation logic: {A} logic for shared mutable data structures},
	booktitle = {Proceedings 17th {Annual} {IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {IEEE},
	author = {Reynolds, John C},
	year = {2002},
	keywords = {to-read},
	pages = {55--74},
	file = {Reynolds - 2002 - Separation logic A logic for shared mutable data .pdf:/home/tim/Zotero/storage/DF82BPDB/Reynolds - 2002 - Separation logic A logic for shared mutable data .pdf:application/pdf},
}

@article{illous_relational_2021,
	title = {A relational shape abstract domain},
	volume = {57},
	number = {3},
	journal = {Formal Methods in System Design},
	author = {Illous, Hugo and Lemerre, Matthieu and Rival, Xavier},
	year = {2021},
	note = {Publisher: Springer},
	keywords = {to-read},
	pages = {343--400},
	file = {Illous et al. - 2021 - A relational shape abstract domain.pdf:/home/tim/Zotero/storage/EUCNRPN9/Illous et al. - 2021 - A relational shape abstract domain.pdf:application/pdf},
}

@inproceedings{facchinetti_relative_2017,
	title = {Relative store fragments for singleton abstraction},
	booktitle = {Static {Analysis}: 24th {International} {Symposium}, {SAS} 2017, {New} {York}, {NY}, {USA}, {August} 30‚Äì{September} 1, 2017, {Proceedings} 24},
	publisher = {Springer},
	author = {Facchinetti, Leandro and Palmer, Zachary and Smith, Scott F},
	year = {2017},
	keywords = {to-read},
	pages = {106--127},
	file = {Facchinetti et al. - 2017 - Relative store fragments for singleton abstraction.pdf:/home/tim/Zotero/storage/HIZE5MSN/Facchinetti et al. - 2017 - Relative store fragments for singleton abstraction.pdf:application/pdf},
}

@inproceedings{montagu_trace-based_2021,
	address = {New York, NY, USA},
	series = {{PLDI} 2021},
	title = {Trace-{Based} {Control}-{Flow} {Analysis}},
	isbn = {978-1-4503-8391-2},
	url = {https://doi.org/10.1145/3453483.3454057},
	doi = {10.1145/3453483.3454057},
	abstract = {We define a small-step semantics for the untyped Œª-calculus, that traces the Œ≤-reductions that occur during evaluation. By abstracting the computation traces, we reconstruct k-CFA using abstract interpretation, and justify constraint-based k-CFA in a semantic way. The abstract interpretation of the trace semantics also paves the way for introducing widening operators in CFA that go beyond existing analyses, that are all based on exploring a finite state space. We define ‚àáCFA, a widening-based analysis that limits the cycles in call stacks, and can achieve better precision than k-CFA at a similar cost.},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Montagu, Beno√Æt and Jensen, Thomas},
	year = {2021},
	note = {event-place: Virtual, Canada},
	keywords = {abstract interpretation, control flow analysis, lambda-calculus, program traces, widening, to-read},
	pages = {482--496},
	file = {Montagu and Jensen - 2021 - Trace-Based Control-Flow Analysis.pdf:/home/tim/Zotero/storage/QL5KZ7TH/Montagu and Jensen - 2021 - Trace-Based Control-Flow Analysis.pdf:application/pdf},
}

@misc{jaiswal_demand-driven_2018,
	title = {Demand-driven {Alias} {Analysis} : {Formalizing} {Bidirectional} {Analyses} for {Soundness} and {Precision}},
	author = {Jaiswal, Swati and Khedker, Uday P. and Chakraborty, Supratik},
	year = {2018},
	note = {\_eprint: 1802.00932},
	keywords = {to-read},
	file = {Jaiswal et al. - 2018 - Demand-driven Alias Analysis  Formalizing Bidirec.pdf:/home/tim/Zotero/storage/SRRTUYK9/Jaiswal et al. - 2018 - Demand-driven Alias Analysis  Formalizing Bidirec.pdf:application/pdf},
}

@inproceedings{arceri_speeding_2023,
	address = {New York, NY, USA},
	series = {{SOAP} 2023},
	title = {Speeding up {Static} {Analysis} with the {Split} {Operator}},
	isbn = {9798400701702},
	url = {https://doi.org/10.1145/3589250.3596141},
	doi = {10.1145/3589250.3596141},
	abstract = {In the context of static analysis based on Abstract Interpretation, we propose a new abstract operator modeling the split of control flow paths: the goal of the operator is to enable a more efficient analysis when using abstract domains that are computationally expensive, having no effect on precision. Focusing on the case of conditional branches guarded by numeric linear constraints, we provide a preliminary experimental evaluation showing that, by using the split operator, we can achieve significant efficiency improvements for a static analysis based on the domain of convex polyhedra. We also briefly discuss the applicability of this new operator to different, possibly non-numeric abstract domains.},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} {International} {Workshop} on the {State} {Of} the {Art} in {Program} {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Arceri, Vincenzo and Dolcetti, Greta and Zaffanella, Enea},
	year = {2023},
	note = {event-place: Orlando, FL, USA},
	keywords = {Abstract Interpretation, Static Analysis, Abstract Operators, to-read},
	pages = {14--19},
	file = {Arceri et al. - 2023 - Speeding up Static Analysis with the Split Operato.pdf:/home/tim/Zotero/storage/JH6P92RL/Arceri et al. - 2023 - Speeding up Static Analysis with the Split Operato.pdf:application/pdf},
}

@article{ramsey_beyond_2022,
	title = {Beyond {Relooper}: {Recursive} {Translation} of {Unstructured} {Control} {Flow} to {Structured} {Control} {Flow} ({Functional} {Pearl})},
	volume = {6},
	url = {https://doi.org/10.1145/3547621},
	doi = {10.1145/3547621},
	abstract = {In many compilers, control flow is represented using an arbitrary directed graph. But in some interesting target languages, including JavaScript and WebAssembly, intraprocedural control flow can be expressed only in structured ways, using loops, conditionals, and multilevel breaks or exits. As was shown by Peterson, Kasami, and Tokura in 1973, such structured control flow can be obtained by translating arbitrary control flow. The translation uses two standard analyses, but as published, it takes three passes‚Äîwhich may explain why it was overlooked by Emscripten, a popular compiler from C to JavaScript. By tweaking the analyses and by applying fundamental ideas from functional programming (recursive functions and immutable abstract-syntax trees), the translation, along with a couple of code improvements, can be implemented in a single pass. This new implementation is slated to be added to the Glasgow Haskell Compiler. Its single-pass translation, its immutable representation, and its use of dominator trees make it much easier to reason about than the original translation.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Ramsey, Norman},
	month = aug,
	year = {2022},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {control-flow analysis, dominator tree, Haskell, reverse postorder numbering, WebAssembly, to-read},
	file = {Ramsey - 2022 - Beyond Relooper Recursive Translation of Unstruct.pdf:/home/tim/Zotero/storage/LUIUT5U8/Ramsey - 2022 - Beyond Relooper Recursive Translation of Unstruct.pdf:application/pdf},
}

@article{parreaux_simple_2020,
	title = {The simple essence of algebraic subtyping: principal type inference with subtyping made easy (functional pearl)},
	volume = {4},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Parreaux, Lionel},
	year = {2020},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Parreaux - 2020 - The simple essence of algebraic subtyping princip.pdf:/home/tim/Zotero/storage/9WISRFYE/Parreaux - 2020 - The simple essence of algebraic subtyping princip.pdf:application/pdf},
}

@book{dolan_algebraic_2017,
	title = {Algebraic subtyping},
	publisher = {BCS, The Chartered Institute for IT},
	author = {Dolan, Stephen},
	year = {2017},
	keywords = {to-read},
}

@inproceedings{reps_precise_1995,
	title = {Precise interprocedural dataflow analysis via graph reachability},
	booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Reps, Thomas and Horwitz, Susan and Sagiv, Mooly},
	year = {1995},
	keywords = {to-read},
	pages = {49--61},
	file = {Reps et al. - 1995 - Precise interprocedural dataflow analysis via grap.pdf:/home/tim/Zotero/storage/T6AYFSA5/Reps et al. - 1995 - Precise interprocedural dataflow analysis via grap.pdf:application/pdf},
}

@inproceedings{cousot_static_1976,
	title = {Static determination of dynamic properties of programs},
	booktitle = {Proceedings of the 2nd {International} {Symposium} on {Programming}, {Paris}, {France}},
	publisher = {Dunod},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1976},
	keywords = {to-read},
	pages = {106--130},
	file = {Cousot and Cousot - 1976 - Static determination of dynamic properties of prog.pdf:/home/tim/Zotero/storage/QMSQAN2V/Cousot and Cousot - 1976 - Static determination of dynamic properties of prog.pdf:application/pdf},
}

@inproceedings{might_resolving_2010,
	title = {Resolving and exploiting the k-{CFA} paradox: illuminating functional vs. object-oriented program analysis},
	booktitle = {Proceedings of the 31st {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Might, Matthew and Smaragdakis, Yannis and Van Horn, David},
	year = {2010},
	keywords = {to-read},
	pages = {305--315},
	file = {Might et al_2010_Resolving and exploiting the k-CFA paradox.pdf:/home/tim/Zotero/storage/QGKDL6A3/Might et al_2010_Resolving and exploiting the k-CFA paradox.pdf:application/pdf;Might et al_2010_Resolving and exploiting the k-CFA paradox2.pdf:/home/tim/Zotero/storage/A9C57PHW/Might et al_2010_Resolving and exploiting the k-CFA paradox2.pdf:application/pdf},
}

@article{forster_expressive_2019,
	title = {On the expressive power of user-defined effects: {Effect} handlers, monadic reflection, delimited control},
	volume = {29},
	journal = {Journal of Functional Programming},
	author = {Forster, Yannick and Kammar, Ohad and Lindley, Sam and Pretnar, Matija},
	year = {2019},
	note = {Publisher: Cambridge University Press},
	keywords = {delimited control},
	pages = {e15},
	file = {Forster et al. - 2019 - On the expressive power of user-defined effects E.pdf:/home/tim/Zotero/storage/CWHVITUF/Forster et al. - 2019 - On the expressive power of user-defined effects E.pdf:application/pdf},
}

@inproceedings{meijer_functional_1991,
	title = {Functional {Programming} with {Bananas}, {Lenses}, {Envelopes} and {Barbed} {Wire}.},
	volume = {91},
	booktitle = {{FPCA}},
	author = {Meijer, Erik and Fokkinga, Maarten M and Paterson, Ross},
	year = {1991},
	keywords = {to-read},
	pages = {124--144},
	file = {Meijer et al. - 1991 - Functional Programming with Bananas, Lenses, Envel.pdf:/home/tim/Zotero/storage/6ZQUQ9WJ/Meijer et al. - 1991 - Functional Programming with Bananas, Lenses, Envel.pdf:application/pdf},
}

@inproceedings{asai_functional_2010,
	title = {Functional derivation of a virtual machine for delimited continuations},
	booktitle = {Proceedings of the 12th international {ACM} {SIGPLAN} symposium on {Principles} and practice of declarative programming},
	author = {Asai, Kenichi and Kitani, Arisa},
	year = {2010},
	keywords = {to-read},
	pages = {87--98},
	file = {Asai and Kitani - 2010 - Functional derivation of a virtual machine for del.pdf:/home/tim/Zotero/storage/NTCVZ7DW/Asai and Kitani - 2010 - Functional derivation of a virtual machine for del.pdf:application/pdf},
}

@article{might_environment_2006,
	title = {Environment analysis via Œî{CFA}},
	volume = {41},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Might, Matthew and Shivers, Olin},
	year = {2006},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {127--140},
	file = {Might and Shivers - 2006 - Environment analysis via ŒîCFA.pdf:/home/tim/Zotero/storage/FXJ5WEQF/Might and Shivers - 2006 - Environment analysis via ŒîCFA.pdf:application/pdf},
}

@article{morrisett_system_1999,
	title = {From {System} {F} to typed assembly language},
	volume = {21},
	number = {3},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Morrisett, Greg and Walker, David and Crary, Karl and Glew, Neal},
	year = {1999},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {certified code, closure conversion, secure extensible systems, type-directed compilation, typed assembly language, typed intermediate languages, to-read},
	pages = {527--568},
	file = {Morrisett et al. - 1999 - From System F to typed assembly language.pdf:/home/tim/Zotero/storage/NHW2MG5Z/Morrisett et al. - 1999 - From System F to typed assembly language.pdf:application/pdf},
}

@inproceedings{germane_demand_2019,
	title = {Demand control-flow analysis},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}: 20th {International} {Conference}, {VMCAI} 2019, {Cascais}, {Portugal}, {January} 13‚Äì15, 2019, {Proceedings} 20},
	publisher = {Springer},
	author = {Germane, Kimball and McCarthy, Jay and Adams, Michael D and Might, Matthew},
	year = {2019},
	keywords = {to-read},
	pages = {226--246},
	file = {Germane et al_2019_Demand control-flow analysis.pdf:/home/tim/Zotero/storage/42J6WM6A/Germane et al_2019_Demand control-flow analysis.pdf:application/pdf;Germane et al_2019_Demand control-flow analysis2.pdf:/home/tim/Zotero/storage/W8HXVWGV/Germane et al_2019_Demand control-flow analysis2.pdf:application/pdf},
}

@inproceedings{downen_codata_2019,
	title = {Codata in action},
	booktitle = {Programming {Languages} and {Systems}: 28th {European} {Symposium} on {Programming}, {ESOP} 2019, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2019, {Prague}, {Czech} {Republic}, {April} 6‚Äì11, 2019, {Proceedings}},
	publisher = {Springer International Publishing Cham},
	author = {Downen, Paul and Sullivan, Zachary and Ariola, Zena M and Peyton Jones, Simon},
	year = {2019},
	keywords = {to-read},
	pages = {119--146},
}

@article{darais_abstracting_2017,
	title = {Abstracting {Definitional} {Interpreters} ({Functional} {Pearl})},
	volume = {1},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Darais, David and Labich, Nicholas and Nguyen, Ph√∫c C and Van Horn, David},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--25},
	file = {Darais et al. - 2017 - Abstracting Definitional Interpreters (Functional .pdf:/home/tim/Zotero/storage/R8DX6CRS/Darais et al. - 2017 - Abstracting Definitional Interpreters (Functional .pdf:application/pdf},
}

@article{wei_compiling_2020,
	title = {Compiling symbolic execution with staging and algebraic effects},
	volume = {4},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Wei, Guannan and Braƒçevac, Oliver and Tan, Shangyin and Rompf, Tiark},
	year = {2020},
	keywords = {to-read},
	file = {Wei et al. - 2020 - Compiling symbolic execution with staging and alge.pdf:/home/tim/Zotero/storage/XEHP8UJU/Wei et al. - 2020 - Compiling symbolic execution with staging and alge.pdf:application/pdf},
}

@article{vardoulakis_cfa2_2011,
	title = {{CFA2}: a {Context}-{Free} {Approach} to {Control}-{Flow} {Analysis}},
	volume = {Volume 7, Issue 2},
	url = {https://doi.org/10.2168%2Flmcs-7%282%3A3%292011},
	doi = {10.2168/lmcs-7(2:3)2011},
	journal = {Logical Methods in Computer Science},
	author = {Vardoulakis, Dimitrios and Shivers, Olin},
	month = may,
	year = {2011},
	note = {Publisher: Centre pour la Communication Scientifique Directe (CCSD)},
	keywords = {to-read},
	file = {Vardoulakis and Shivers - 2011 - CFA2 a Context-Free Approach to Control-Flow Anal.pdf:/home/tim/Zotero/storage/RCAWTA49/Vardoulakis and Shivers - 2011 - CFA2 a Context-Free Approach to Control-Flow Anal.pdf:application/pdf},
}

@article{sharir_structural_1980,
	title = {Structural analysis: {A} new approach to flow analysis in optimizing compilers},
	volume = {5},
	number = {3-4},
	journal = {Computer Languages},
	author = {Sharir, Micha},
	year = {1980},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {141--153},
	file = {Sharir - 1980 - Structural analysis A new approach to flow analys.pdf:/home/tim/Zotero/storage/CD24DDS8/Sharir - 1980 - Structural analysis A new approach to flow analys.pdf:application/pdf},
}

@book{sharir_two_1978,
	title = {Two approaches to interprocedural data flow analysis},
	publisher = {New York University. Courant Institute of Mathematical Sciences ‚Ä¶},
	author = {Sharir, Micha and Pnueli, Amir and {others}},
	year = {1978},
	keywords = {to-read},
	file = {Sharir et al. - 1978 - Two approaches to interprocedural data flow analys.pdf:/home/tim/Zotero/storage/S4W2IDLP/Sharir et al. - 1978 - Two approaches to interprocedural data flow analys.pdf:application/pdf},
}

@inproceedings{cousot_automatic_1978,
	title = {Automatic discovery of linear restraints among variables of a program},
	booktitle = {Proceedings of the 5th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	author = {Cousot, Patrick and Halbwachs, Nicolas},
	year = {1978},
	keywords = {to-read},
	pages = {84--96},
	file = {Cousot and Halbwachs - 1978 - Automatic discovery of linear restraints among var.pdf:/home/tim/Zotero/storage/XD87FRV2/Cousot and Halbwachs - 1978 - Automatic discovery of linear restraints among var.pdf:application/pdf},
}

@inproceedings{cousot_abstract_1977,
	address = {New York, NY, USA},
	series = {{POPL} '77},
	title = {Abstract {Interpretation}: {A} {Unified} {Lattice} {Model} for {Static} {Analysis} of {Programs} by {Construction} or {Approximation} of {Fixpoints}},
	isbn = {978-1-4503-7350-0},
	url = {https://doi.org/10.1145/512950.512973},
	doi = {10.1145/512950.512973},
	abstract = {A program denotes computations in some universe of objects. Abstract interpretation of programs consists in using that denotation to describe computations in another universe of abstract objects, so that the results of abstract execution give some information on the actual computations. An intuitive example (which we borrow from Sintzoff [72]) is the rule of signs. The text -1515 * 17 may be understood to denote computations on the abstract universe (+), (-), (¬±) where the semantics of arithmetic operators is defined by the rule of signs. The abstract execution -1515 * 17 ‚Üí -(+) * (+) ‚Üí (-) * (+) ‚Üí (-), proves that -1515 * 17 is a negative number. Abstract interpretation is concerned by a particular underlying structure of the usual universe of computations (the sign, in our example). It gives a summary of some facets of the actual executions of a program. In general this summary is simple to obtain but inaccurate (e.g. -1515 + 17 ‚Üí -(+) + (+) ‚Üí (-) + (+) ‚Üí (¬±)). Despite its fundamentally incomplete results abstract interpretation allows the programmer or the compiler to answer questions which do not need full knowledge of program executions or which tolerate an imprecise answer, (e.g. partial correctness proofs of programs ignoring the termination problems, type checking, program optimizations which are not carried in the absence of certainty about their feasibility, ‚Ä¶).},
	booktitle = {Proceedings of the 4th {ACM} {SIGACT}-{SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1977},
	note = {event-place: Los Angeles, California},
	keywords = {to-read},
	pages = {238--252},
	file = {Cousot and Cousot - 1977 - Abstract Interpretation A Unified Lattice Model f.pdf:/home/tim/Zotero/storage/P4G6EAZY/Cousot and Cousot - 1977 - Abstract Interpretation A Unified Lattice Model f.pdf:application/pdf},
}

@article{jeon_precise_2018,
	title = {Precise and {Scalable} {Points}-to {Analysis} via {Data}-{Driven} {Context} {Tunneling}},
	volume = {2},
	url = {https://doi.org/10.1145/3276510},
	doi = {10.1145/3276510},
	abstract = {We present context tunneling, a new approach for making k-limited context-sensitive points-to analysis precise and scalable. As context-sensitivity holds the key to the development of precise and scalable points-to analysis, a variety of techniques for context-sensitivity have been proposed. However, existing approaches such as k-call-site-sensitivity or k-object-sensitivity have a significant weakness that they unconditionally update the context of a method at every call-site, allowing important context elements to be overwritten by more recent, but not necessarily more important, context elements. In this paper, we show that this is a key limiting factor of existing context-sensitive analyses, and demonstrate that remarkable increase in both precision and scalability can be gained by maintaining important context elements only. Our approach, called context tunneling, updates contexts selectively and decides when to propagate the same context without modification. We attain context tunneling via a data-driven approach. The effectiveness of context tunneling is very sensitive to the choice of important context elements. Even worse, precision is not monotonically increasing with respect to the ordering of the choices. As a result, manually coming up with a good heuristic rule for context tunneling is extremely challenging and likely fails to maximize its potential. We address this challenge by developing a specialized data-driven algorithm, which is able to automatically search for high-quality heuristics over the non-monotonic space of context tunneling. We implemented our approach in the Doop framework and applied it to four major flavors of context-sensitivity: call-site-sensitivity, object-sensitivity, type-sensitivity, and hybrid context-sensitivity. In all cases, 1-context-sensitive analysis with context tunneling far outperformed deeper context-sensitivity with k=2 in both precision and scalability.},
	number = {OOPSLA},
	journal = {Proc. ACM Program. Lang.},
	author = {Jeon, Minseok and Jeong, Sehun and Oh, Hakjoo},
	month = oct,
	year = {2018},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Context-sensitive analysis, Data-driven program analysis, Points-to analysis, to-read},
	file = {Jeon et al. - 2018 - Precise and Scalable Points-to Analysis via Data-D.pdf:/home/tim/Zotero/storage/VLIQS3YS/Jeon et al. - 2018 - Precise and Scalable Points-to Analysis via Data-D.pdf:application/pdf},
}

@techreport{lorenzen_fp2_2023,
	title = {{FP}{\textasciicircum}2: {Fully} in-{Place} {Functional} {Programming}},
	url = {https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming/},
	abstract = {As functional programmers we always face a dilemma: should we write purely functional code, or sacrifice purity for efficiency and resort to in-place updates? This paper identifies precisely when we can have the best of both worlds: a wide class of purely functional programs can be executed safely using in-place updates without requiring allocation. We describe a linear \_fully in-place\_ (FIP) calculus where we prove that we can always execute such functions in way that requires no (de)allocation and uses constant stack space. Of course, such calculus is only relevant if we can express interesting algorithms, and we show many examples, including splay trees, finger trees, merge sort, and quick sort. We also show how we can generically derive a map function over \_any\_ polynomial data type that is fully in-place and uses neither heap- nor stack space. We consider two approaches to embed the FIP calculus in a larger language, either a static approach based on uniqueness typing, or a dynamic approach based on precise reference counting. We have a full implementation based on the dynamic approach in the Koka language and all examples in the paper can be checked and executed fully in-place.},
	number = {MSR-TR-2023-19},
	institution = {Microsoft},
	author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter},
	month = may,
	year = {2023},
	keywords = {to-read},
	file = {Lorenzen et al. - 2023 - FP^2 Fully in-Place Functional Programming.pdf:/home/tim/Zotero/storage/J3ZWNIJQ/Lorenzen et al. - 2023 - FP^2 Fully in-Place Functional Programming.pdf:application/pdf},
}

@article{adams_orbit_1986,
	title = {Orbit: {An} optimizing compiler for {Scheme}},
	volume = {21},
	number = {7},
	journal = {ACM SIGPLAN Notices},
	author = {Adams, Norman and Kranz, David and Kelsey, Richard and Rees, Jonathan and Hudak, Paul and Philbin, James},
	year = {1986},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {219--233},
	file = {Adams et al. - 1986 - Orbit An optimizing compiler for Scheme.pdf:/home/tim/Zotero/storage/EAY39CPD/Adams et al. - 1986 - Orbit An optimizing compiler for Scheme.pdf:application/pdf},
}

@inproceedings{blume_demand-driven_1995,
	title = {Demand-driven, symbolic range propagation},
	booktitle = {International {Workshop} on {Languages} and {Compilers} for {Parallel} {Computing}},
	publisher = {Springer},
	author = {Blume, William and Eigenmann, Rudolf},
	year = {1995},
	keywords = {to-read},
	pages = {141--160},
	file = {Blume and Eigenmann - 1995 - Demand-driven, symbolic range propagation.pdf:/home/tim/Zotero/storage/Z2AE3CMZ/Blume and Eigenmann - 1995 - Demand-driven, symbolic range propagation.pdf:application/pdf},
}

@inproceedings{bodik_abcd_2000,
	address = {New York, NY, USA},
	series = {{PLDI} '00},
	title = {{ABCD}: {Eliminating} {Array} {Bounds} {Checks} on {Demand}},
	isbn = {1-58113-199-2},
	url = {https://doi.org/10.1145/349299.349342},
	doi = {10.1145/349299.349342},
	abstract = {To guarantee typesafe execution, Java and other strongly typed languages require bounds checking of array accesses. Because array-bounds checks may raise exceptions, they block code motion of instructions with side effects, thus preventing many useful code optimizations, such as partial redundancy elimination or instruction scheduling of memory operations. Furthermore, because it is not expressible at bytecode level, the elimination of bounds checks can only be performed at run time, after the bytecode program is loaded. Using existing powerful bounds-check optimizers at run time is not feasible, however, because they are too heavyweight for the dynamic compilation setting.ABCD is a light-weight algorithm for elimination of Array Bounds Checks on Demand. Its design emphasizes simplicity and efficiency. In essence, ABCD works by adding a few edges to the SSA value graph and performing a simple traversal of the graph. Despite its simplicity, ABCD is surprisingly powerful. On our benchmarks, ABCD removes on average 45\% of dynamic bound check instructions, sometimes achieving near-ideal optimization. The efficiency of ABCD stems from two factors. First, ABCD works on a sparse representation. As a result, it requires on average fewer than 10 simple analysis steps per bounds check. Second, ABCD is demand-driven. It can be applied to a set of frequently executed (hot) bounds checks, which makes it suitable for the dynamic-compilation setting, in which compile-time cost is constrained but hot statements are known.},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 2000 {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {Association for Computing Machinery},
	author = {Bod√≠k, Rastislav and Gupta, Rajiv and Sarkar, Vivek},
	year = {2000},
	note = {event-place: Vancouver, British Columbia, Canada},
	keywords = {to-read},
	pages = {321--333},
	file = {Bod√≠k et al. - 2000 - ABCD Eliminating Array Bounds Checks on Demand.pdf:/home/tim/Zotero/storage/8EBGUGAJ/Bod√≠k et al. - 2000 - ABCD Eliminating Array Bounds Checks on Demand.pdf:application/pdf},
}

@inproceedings{odersky_second_1995,
	title = {A second look at overloading},
	booktitle = {Proceedings of the seventh international conference on {Functional} programming languages and computer architecture},
	author = {Odersky, Martin and Wadler, Philip and Wehr, Martin},
	year = {1995},
	keywords = {to-read},
	pages = {135--146},
	file = {Odersky et al. - 1995 - A second look at overloading.pdf:/home/tim/Zotero/storage/C8QX3U3R/Odersky et al. - 1995 - A second look at overloading.pdf:application/pdf},
}

@inproceedings{lyde_strong_2014,
	title = {Strong function call},
	volume = {2014},
	booktitle = {Workshop on {Higher}-{Order} {Program} {Analysis}},
	author = {Lyde, Steven and Might, Matthew},
	year = {2014},
	keywords = {to-read},
	file = {Lyde and Might - 2014 - Strong function call.pdf:/home/tim/Zotero/storage/FFSXF5ZB/Lyde and Might - 2014 - Strong function call.pdf:application/pdf},
}

@inproceedings{lyde_environment_2014,
	title = {Environment unrolling},
	volume = {2014},
	booktitle = {Workshop on {Higher}-{Order} {Program} {Analysis}},
	publisher = {Citeseer},
	author = {Lyde, Steven and Might, Matthew},
	year = {2014},
	keywords = {to-read},
	file = {Lyde and Might - 2014 - Environment unrolling.pdf:/home/tim/Zotero/storage/QJG2K3FF/Lyde and Might - 2014 - Environment unrolling.pdf:application/pdf},
}

@inproceedings{liang_fast_2014,
	title = {Fast flow analysis with godel hashes},
	booktitle = {2014 {IEEE} 14th {International} {Working} {Conference} on {Source} {Code} {Analysis} and {Manipulation}},
	publisher = {IEEE},
	author = {Liang, Shuying and Sun, Weibin and Might, Matthew},
	year = {2014},
	keywords = {to-read},
	pages = {225--234},
	file = {Liang et al. - 2014 - Fast flow analysis with godel hashes.pdf:/home/tim/Zotero/storage/9UAP3JJF/Liang et al. - 2014 - Fast flow analysis with godel hashes.pdf:application/pdf},
}

@inproceedings{liang_pruning_2014,
	title = {Pruning, pushdown exception-flow analysis},
	booktitle = {2014 {IEEE} 14th {International} {Working} {Conference} on {Source} {Code} {Analysis} and {Manipulation}},
	publisher = {IEEE},
	author = {Liang, Shuying and Sun, Weibin and Might, Matthew and Keep, Andrew and Van Horn, David},
	year = {2014},
	keywords = {to-read},
	pages = {265--274},
	file = {Liang et al. - 2014 - Pruning, pushdown exception-flow analysis.pdf:/home/tim/Zotero/storage/7UXXEH4Q/Liang et al. - 2014 - Pruning, pushdown exception-flow analysis.pdf:application/pdf},
}

@inproceedings{jenkins_concrete_2015,
	title = {Concrete and abstract interpretation: {Better} together},
	volume = {14},
	booktitle = {Proceedings of the 2014 {Scheme} and {Functional} {Programming} {Workshop}, {SFP}},
	publisher = {Citeseer},
	author = {Jenkins, Maria and Andersen, Leif and Gilray, Thomas and Might, Matthew},
	year = {2015},
	keywords = {to-read},
	file = {Jenkins et al. - 2015 - Concrete and abstract interpretation Better toget.pdf:/home/tim/Zotero/storage/X4Y83DW7/Jenkins et al. - 2015 - Concrete and abstract interpretation Better toget.pdf:application/pdf},
}

@inproceedings{maurer_compiling_2017,
	title = {Compiling without continuations},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Maurer, Luke and Downen, Paul and Ariola, Zena M and Peyton Jones, Simon},
	year = {2017},
	keywords = {to-read},
	pages = {482--494},
	file = {Maurer et al. - 2017 - Compiling without continuations.pdf:/home/tim/Zotero/storage/HW7YLWIZ/Maurer et al. - 2017 - Compiling without continuations.pdf:application/pdf},
}

@inproceedings{danvy_abstracting_1990,
	title = {Abstracting control},
	booktitle = {Proceedings of the 1990 {ACM} {Conference} on {LISP} and {Functional} {Programming}},
	author = {Danvy, Olivier and Filinski, Andrzej},
	year = {1990},
	keywords = {to-read},
	pages = {151--160},
	file = {Danvy and Filinski - 1990 - Abstracting control.pdf:/home/tim/Zotero/storage/SFSAVBSB/Danvy and Filinski - 1990 - Abstracting control.pdf:application/pdf},
}

@inproceedings{danvy_operational_1999,
	title = {An operational investigation of the {CPS} hierarchy},
	booktitle = {European {Symposium} {On} {Programming}},
	publisher = {Springer},
	author = {Danvy, Olivier and Yang, Zhe},
	year = {1999},
	keywords = {to-read},
	pages = {224--242},
	file = {Danvy and Yang - 1999 - An operational investigation of the CPS hierarchy.pdf:/home/tim/Zotero/storage/8GPJL3N7/Danvy and Yang - 1999 - An operational investigation of the CPS hierarchy.pdf:application/pdf},
}

@inproceedings{kameyama_shifting_2009,
	title = {Shifting the stage: {Staging} with delimited control},
	booktitle = {Proceedings of the 2009 {ACM} {SIGPLAN} workshop on {Partial} {Evaluation} and {Program} {Manipulation}},
	author = {Kameyama, Yukiyoshi and Kiselyov, Oleg and Shan, Chung-chieh},
	year = {2009},
	keywords = {to-read},
	pages = {111--120},
	file = {Kameyama et al. - 2009 - Shifting the stage Staging with delimited control.pdf:/home/tim/Zotero/storage/GCV94SS6/Kameyama et al. - 2009 - Shifting the stage Staging with delimited control.pdf:application/pdf},
}

@article{brandon_better_2023,
	title = {Better {Defunctionalization} through {Lambda} {Set} {Specialization}},
	volume = {7},
	url = {https://doi.org/10.1145/3591260},
	doi = {10.1145/3591260},
	abstract = {Higher-order functions pose a challenge for both static program analyses and optimizing compilers. To simplify the analysis and compilation of languages with higher-order functions, a rich body of prior work has proposed a variety of defunctionalization techniques, which can eliminate higher-order functions from a program by transforming the program to a semantically-equivalent first-order representation. Several modern languages take this a step further, specializing higher-order functions with respect to the functions on which they operate, and in turn allowing compilers to generate more efficient code. However, existing specializing defunctionalization techniques restrict how function values may be used, forcing implementations to fall back on costly dynamic alternatives. We propose lambda set specialization (LSS), the first specializing defunctionalization technique which imposes no restrictions on how function values may be used. We formulate LSS in terms of a polymorphic type system which tracks the flow of function values through the program, and use this type system to recast specialization of higher-order functions with respect to their arguments as a form of type monomorphization. We show that our type system admits a simple and tractable type inference algorithm, and give a formalization and fully-mechanized proof in the Isabelle/HOL proof assistant showing soundness and completeness of the type inference algorithm with respect to the type system. To show the benefits of LSS, we evaluate its impact on the run time performance of code generated by the MLton compiler for Standard ML, the OCaml compiler, and the new Morphic functional programming language. We find that pre-processing with LSS achieves run time speedups of up to 6.85x under MLton, 3.45x for OCaml, and 78.93x for Morphic.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Brandon, William and Driscoll, Benjamin and Dai, Frank and Berkow, Wilson and Milano, Mae},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {defunctionalization, monomorphization, type systems, to-read},
	file = {Brandon et al. - 2023 - Better Defunctionalization through Lambda Set Spec.pdf:/home/tim/Zotero/storage/586Z4LMZ/Brandon et al. - 2023 - Better Defunctionalization through Lambda Set Spec.pdf:application/pdf},
}

@article{moseley_derivative_2023,
	title = {Derivative {Based} {Nonbacktracking} {Real}-{World} {Regex} {Matching} with {Backtracking} {Semantics}},
	volume = {7},
	url = {https://doi.org/10.1145/3591262},
	doi = {10.1145/3591262},
	abstract = {We develop a new derivative based theory and algorithm for nonbacktracking regex matching that supports anchors and counting, preserves backtracking semantics, and can be extended with lookarounds. The algorithm has been implemented as a new regex backend in .NET and was extensively tested as part of the formal release process of .NET7. We present a formal proof of the correctness of the algorithm, which we believe to be the first of its kind concerning industrial implementations of regex matchers. The paper describes the complete foundation, the matching algorithm, and key aspects of the implementation involving a regex rewrite system, as well as a comprehensive evaluation over industrial case studies and other regex engines.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Moseley, Dan and Nishio, Mario and Perez Rodriguez, Jose and Saarikivi, Olli and Toub, Stephen and Veanes, Margus and Wan, Tiki and Xu, Eric},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {automata, derivative, matching, PCRE, regex, symbolic, to-read},
	file = {Moseley et al. - 2023 - Derivative Based Nonbacktracking Real-World Regex .pdf:/home/tim/Zotero/storage/KNY4MZ7Z/Moseley et al. - 2023 - Derivative Based Nonbacktracking Real-World Regex .pdf:application/pdf},
}

@article{zhang_better_2023,
	title = {Better {Together}: {Unifying} {Datalog} and {Equality} {Saturation}},
	volume = {7},
	url = {https://doi.org/10.1145/3591239},
	doi = {10.1145/3591239},
	abstract = {We present egglog, a fixpoint reasoning system that unifies Datalog and equality saturation (EqSat). Like Datalog, egglog supports efficient incremental execution, cooperating analyses, and lattice-based reasoning. Like EqSat, egglog supports term rewriting, efficient congruence closure, and extraction of optimized terms. We identify two recent applications ‚Äì a unification-based pointer analysis in Datalog and an EqSat-based floating-point term rewriter ‚Äì that have been hampered by features missing from Datalog but found in EqSat or vice-versa. We evaluate our system by reimplementing those projects in egglog. The resulting systems in egglog are faster, simpler, and fix bugs found in the original systems.},
	number = {PLDI},
	journal = {Proc. ACM Program. Lang.},
	author = {Zhang, Yihong and Wang, Yisu Remy and Flatt, Oliver and Cao, David and Zucker, Philip and Rosenthal, Eli and Tatlock, Zachary and Willsey, Max},
	month = jun,
	year = {2023},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Datalog, Equality saturation, Program optimization, Rewrite systems, to-read},
	file = {Zhang et al. - 2023 - Better Together Unifying Datalog and Equality Sat.pdf:/home/tim/Zotero/storage/VNNMQAZS/Zhang et al. - 2023 - Better Together Unifying Datalog and Equality Sat.pdf:application/pdf},
}

@inproceedings{might_logic-flow_2007,
	title = {Logic-flow analysis of higher-order programs},
	booktitle = {Proceedings of the 34th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Might, Matthew},
	year = {2007},
	keywords = {to-read},
	pages = {185--198},
	file = {Might - 2007 - Logic-flow analysis of higher-order programs.pdf:/home/tim/Zotero/storage/WZMJSV9J/Might - 2007 - Logic-flow analysis of higher-order programs.pdf:application/pdf},
}

@inproceedings{liang_entangled_2013,
	title = {Entangled abstract domains for higher-order programs},
	booktitle = {Proceedings of the 2013 {Workshop} on {Scheme} and {Functional} {Programming}, {Washington}, {DC}},
	author = {Liang, Shuying and Might, Matthew},
	year = {2013},
	keywords = {to-read},
	file = {Liang and Might - 2013 - Entangled abstract domains for higher-order progra.pdf:/home/tim/Zotero/storage/B4ALCRY3/Liang and Might - 2013 - Entangled abstract domains for higher-order progra.pdf:application/pdf},
}

@inproceedings{liang_hash-flow_2012,
	title = {Hash-flow taint analysis of higher-order programs},
	booktitle = {Proceedings of the 7th {Workshop} on {Programming} {Languages} and {Analysis} for {Security}},
	author = {Liang, Shuying and Might, Matthew},
	year = {2012},
	keywords = {to-read},
	pages = {1--12},
	file = {Liang and Might - 2012 - Hash-flow taint analysis of higher-order programs.pdf:/home/tim/Zotero/storage/DRRD3EM9/Liang and Might - 2012 - Hash-flow taint analysis of higher-order programs.pdf:application/pdf},
}

@article{yallop_flap_2023,
	title = {flap: {A} {Deterministic} {Parser} with {Fused} {Lexing}},
	volume = {7},
	number = {PLDI},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Yallop, Jeremy and Xie, Ningning and Krishnaswami, Neel},
	year = {2023},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1194--1217},
	file = {Yallop et al. - 2023 - flap A Deterministic Parser with Fused Lexing.pdf:/home/tim/Zotero/storage/YBY5RAGX/Yallop et al. - 2023 - flap A Deterministic Parser with Fused Lexing.pdf:application/pdf},
}

@article{bruni_abstract_2019,
	title = {Abstract extensionality: on the properties of incomplete abstract interpretations},
	volume = {4},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bruni, Roberto and Giacobazzi, Roberto and Gori, Roberta and Garcia-Contreras, Isabel and Pavlovic, Dusko},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Bruni et al. - 2019 - Abstract extensionality on the properties of inco.pdf:/home/tim/Zotero/storage/5KB6BEXS/Bruni et al. - 2019 - Abstract extensionality on the properties of inco.pdf:application/pdf},
}

@article{zimmerman_langcc_2022,
	title = {langcc: {A} {Next}-{Generation} {Compiler} {Compiler}},
	journal = {arXiv preprint arXiv:2209.08385},
	author = {Zimmerman, Joe},
	year = {2022},
	keywords = {to-read},
	file = {Zimmerman - 2022 - langcc A Next-Generation Compiler Compiler.pdf:/home/tim/Zotero/storage/AA2HQXVL/Zimmerman - 2022 - langcc A Next-Generation Compiler Compiler.pdf:application/pdf},
}

@article{zimmerman_practical_2022,
	title = {Practical {LR} {Parser} {Generation}},
	journal = {arXiv preprint arXiv:2209.08383},
	author = {Zimmerman, Joe},
	year = {2022},
	keywords = {to-read},
	file = {Zimmerman - 2022 - Practical LR Parser Generation.pdf:/home/tim/Zotero/storage/SAH7VNXZ/Zimmerman - 2022 - Practical LR Parser Generation.pdf:application/pdf},
}

@article{wright_polymorphic_1998,
	title = {Polymorphic splitting: {An} effective polyvariant flow analysis},
	volume = {20},
	number = {1},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Wright, Andrew K and Jagannathan, Suresh},
	year = {1998},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {166--207},
	file = {Wright and Jagannathan - 1998 - Polymorphic splitting An effective polyvariant fl.pdf:/home/tim/Zotero/storage/BS8VEBMF/Wright and Jagannathan - 1998 - Polymorphic splitting An effective polyvariant fl.pdf:application/pdf},
}

@article{jones_secrets_2002,
	title = {Secrets of the glasgow haskell compiler inliner},
	volume = {12},
	number = {4-5},
	journal = {Journal of Functional Programming},
	author = {Jones, Simon Peyton and Marlow, Simon},
	year = {2002},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {393--434},
	file = {Jones and Marlow - 2002 - Secrets of the glasgow haskell compiler inliner.pdf:/home/tim/Zotero/storage/EHVUGCEI/Jones and Marlow - 2002 - Secrets of the glasgow haskell compiler inliner.pdf:application/pdf},
}

@inproceedings{flanagan_essence_1993,
	title = {The essence of compiling with continuations},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1993 conference on {Programming} language design and implementation},
	author = {Flanagan, Cormac and Sabry, Amr and Duba, Bruce F and Felleisen, Matthias},
	year = {1993},
	keywords = {to-read},
	pages = {237--247},
	file = {Flanagan et al. - 1993 - The essence of compiling with continuations.pdf:/home/tim/Zotero/storage/N8DCMX64/Flanagan et al. - 1993 - The essence of compiling with continuations.pdf:application/pdf},
}

@inproceedings{vardoulakis_ordering_2011,
	title = {Ordering multiple continuations on the stack},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} workshop on {Partial} evaluation and program manipulation},
	author = {Vardoulakis, Dimitrios and Shivers, Olin},
	year = {2011},
	keywords = {to-read},
	pages = {13--22},
	file = {Vardoulakis and Shivers - 2011 - Ordering multiple continuations on the stack.pdf:/home/tim/Zotero/storage/RPWRPXUC/Vardoulakis and Shivers - 2011 - Ordering multiple continuations on the stack.pdf:application/pdf},
}

@inproceedings{gilray_pushdown_2016,
	title = {Pushdown control-flow analysis for free},
	booktitle = {Proceedings of the 43rd {Annual} {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	author = {Gilray, Thomas and Lyde, Steven and Adams, Michael D and Might, Matthew and Van Horn, David},
	year = {2016},
	keywords = {to-read},
	pages = {691--704},
	file = {Gilray et al. - 2016 - Pushdown control-flow analysis for free.pdf:/home/tim/Zotero/storage/NYHVHYI6/Gilray et al. - 2016 - Pushdown control-flow analysis for free.pdf:application/pdf},
}

@inproceedings{jagannathan_unified_1995,
	title = {A unified treatment of flow analysis in higher-order languages},
	booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Jagannathan, Suresh and Weeks, Stephen},
	year = {1995},
	keywords = {to-read},
	pages = {393--407},
	file = {Jagannathan and Weeks - 1995 - A unified treatment of flow analysis in higher-ord.pdf:/home/tim/Zotero/storage/TUEHSN76/Jagannathan and Weeks - 1995 - A unified treatment of flow analysis in higher-ord.pdf:application/pdf},
}

@article{glaze_optimizing_2013,
	title = {Optimizing abstract abstract machines},
	volume = {48},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Glaze, Dionna and Labich, Nicholas and Might, Matthew and Van Horn, David},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {443--454},
	file = {Glaze et al. - 2013 - Optimizing abstract abstract machines.pdf:/home/tim/Zotero/storage/3BA5WDMG/Glaze et al. - 2013 - Optimizing abstract abstract machines.pdf:application/pdf},
}

@article{okasaki_red-black_1999,
	title = {Red-black trees in a functional setting},
	volume = {9},
	number = {4},
	journal = {Journal of functional programming},
	author = {Okasaki, Chris},
	year = {1999},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {471--477},
	file = {Okasaki - 1999 - Red-black trees in a functional setting.pdf:/home/tim/Zotero/storage/G9EV9P5W/Okasaki - 1999 - Red-black trees in a functional setting.pdf:application/pdf},
}

@inproceedings{bose_o_2010,
	title = {An {O} (log log n)-competitive binary search tree with optimal worst-case access times},
	booktitle = {Algorithm {Theory}-{SWAT} 2010: 12th {Scandinavian} {Symposium} and {Workshops} on {Algorithm} {Theory}, {Bergen}, {Norway}, {June} 21-23, 2010. {Proceedings} 12},
	publisher = {Springer},
	author = {Bose, Prosenjit and Dou√Øeb, Karim and Dujmoviƒá, Vida and Fagerberg, Rolf},
	year = {2010},
	keywords = {to-read},
	pages = {38--49},
	file = {Bose et al. - 2010 - An O (log log n)-competitive binary search tree wi.pdf:/home/tim/Zotero/storage/HMGWAWZ4/Bose et al. - 2010 - An O (log log n)-competitive binary search tree wi.pdf:application/pdf},
}

@inproceedings{brahmakshatriya_buildit_2021,
	title = {{BuildIt}: {A} type-based multi-stage programming framework for code generation in {C}++},
	booktitle = {2021 {IEEE}/{ACM} {International} {Symposium} on {Code} {Generation} and {Optimization} ({CGO})},
	publisher = {IEEE},
	author = {Brahmakshatriya, Ajay and Amarasinghe, Saman},
	year = {2021},
	keywords = {to-read},
	pages = {39--51},
	file = {Brahmakshatriya and Amarasinghe - 2021 - BuildIt A type-based multi-stage programming fram.pdf:/home/tim/Zotero/storage/XXLP8UF3/Brahmakshatriya and Amarasinghe - 2021 - BuildIt A type-based multi-stage programming fram.pdf:application/pdf},
}

@inproceedings{brahmakshatriya_d2x_2023,
	title = {{D2X}: {An} {eXtensible} {conteXtual} {Debugger} for {Modern} {DSLs}},
	booktitle = {Proceedings of the 21st {ACM}/{IEEE} {International} {Symposium} on {Code} {Generation} and {Optimization}},
	author = {Brahmakshatriya, Ajay and Amarasinghe, Saman},
	year = {2023},
	keywords = {to-read},
	pages = {162--172},
	file = {Brahmakshatriya and Amarasinghe - 2023 - D2X An eXtensible conteXtual Debugger for Modern .pdf:/home/tim/Zotero/storage/SXXQYH4B/Brahmakshatriya and Amarasinghe - 2023 - D2X An eXtensible conteXtual Debugger for Modern .pdf:application/pdf},
}

@inproceedings{cousot_systematic_1979,
	title = {Systematic design of program analysis frameworks},
	booktitle = {Proceedings of the 6th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	author = {Cousot, Patrick and Cousot, Radhia},
	year = {1979},
	keywords = {to-read},
	pages = {269--282},
	file = {Cousot and Cousot - 1979 - Systematic design of program analysis frameworks.pdf:/home/tim/Zotero/storage/G6ZW2XTM/Cousot and Cousot - 1979 - Systematic design of program analysis frameworks.pdf:application/pdf},
}

@article{quiring_analyzing_2022,
	title = {Analyzing binding extent in {3CPS}},
	volume = {6},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Quiring, Benjamin and Reppy, John and Shivers, Olin},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {650--678},
	file = {Quiring et al. - 2022 - Analyzing binding extent in 3CPS.pdf:/home/tim/Zotero/storage/XR9BSLWB/Quiring et al. - 2022 - Analyzing binding extent in 3CPS.pdf:application/pdf},
}

@inproceedings{quiring_3cps_2021,
	title = {{3CPS}: {The} {Design} of an {Environment}-{Focussed} {Intermediate} {Representation}},
	booktitle = {33rd {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	author = {Quiring, Benjamin and Reppy, John and Shivers, Olin},
	year = {2021},
	pages = {20--28},
	file = {Quiring et al. - 2021 - 3CPS The Design of an Environment-Focussed Interm.pdf:/home/tim/Zotero/storage/F6V3KZHQ/Quiring et al. - 2021 - 3CPS The Design of an Environment-Focussed Interm.pdf:application/pdf},
}

@article{shene_comparative_1996,
	title = {A comparative study of linked list sorting algorithms},
	volume = {3},
	number = {2},
	journal = {3C ON-LINE},
	author = {Shene, Ching-Kuang},
	year = {1996},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {4--9},
	file = {Shene - 1996 - A comparative study of linked list sorting algorit.pdf:/home/tim/Zotero/storage/6J89Q238/Shene - 1996 - A comparative study of linked list sorting algorit.pdf:application/pdf},
}

@article{midtgaard_control-flow_2012,
	title = {Control-flow analysis of functional programs},
	volume = {44},
	number = {3},
	journal = {ACM computing surveys (CSUR)},
	author = {Midtgaard, Jan},
	year = {2012},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--33},
	file = {Midtgaard - 2012 - Control-flow analysis of functional programs.pdf:/home/tim/Zotero/storage/UKV9Z9SU/Midtgaard - 2012 - Control-flow analysis of functional programs.pdf:application/pdf},
}

@inproceedings{wolff_gradual_2011,
	title = {Gradual {Typestate}.},
	volume = {11},
	booktitle = {{ECOOP}},
	publisher = {Springer},
	author = {Wolff, Roger and Garcia, Ronald and Tanter, √âric and Aldrich, Jonathan},
	year = {2011},
	keywords = {to-read},
	pages = {459--483},
	file = {Wolff et al. - 2011 - Gradual Typestate..pdf:/home/tim/Zotero/storage/67KVSTD8/Wolff et al. - 2011 - Gradual Typestate..pdf:application/pdf},
}

@article{szabolcsi_combinatory_1992,
	title = {Combinatory grammar and projection from the lexicon},
	volume = {1192},
	journal = {Lexical matters},
	author = {Szabolcsi, Anna},
	year = {1992},
	note = {Publisher: CSLI publications Stanford},
	keywords = {to-read},
	file = {Szabolcsi - 1992 - Combinatory grammar and projection from the lexico.pdf:/home/tim/Zotero/storage/NHTBXTTN/Szabolcsi - 1992 - Combinatory grammar and projection from the lexico.pdf:application/pdf},
}

@inproceedings{freeman_refinement_1991,
	title = {Refinement types for {ML}},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1991 conference on {Programming} language design and implementation},
	author = {Freeman, Tim and Pfenning, Frank},
	year = {1991},
	keywords = {to-read},
	pages = {268--277},
	file = {Freeman and Pfenning - 1991 - Refinement types for ML.pdf:/home/tim/Zotero/storage/4WTFST8W/Freeman and Pfenning - 1991 - Refinement types for ML.pdf:application/pdf},
}

@book{nielson_principles_2015,
	title = {Principles of program analysis},
	publisher = {Springer},
	author = {Nielson, Flemming and Nielson, Hanne R and Hankin, Chris},
	year = {2015},
	keywords = {to-read},
}

@inproceedings{fachinetti_set-based_2020,
	title = {A {Set}-{Based} {Context} {Model} for {Program} {Analysis}},
	booktitle = {Programming {Languages} and {Systems}: 18th {Asian} {Symposium}, {APLAS} 2020, {Fukuoka}, {Japan}, {November} 30‚Äì{December} 2, 2020, {Proceedings} 18},
	publisher = {Springer},
	author = {Fachinetti, Leandro and Palmer, Zachary and Smith, Scott F and Wu, Ke and Yorihiro, Ayaka},
	year = {2020},
	keywords = {to-read},
	pages = {3--24},
	file = {Fachinetti et al. - 2020 - A Set-Based Context Model for Program Analysis.pdf:/home/tim/Zotero/storage/C2WBJBED/Fachinetti et al. - 2020 - A Set-Based Context Model for Program Analysis.pdf:application/pdf},
}

@article{palmer_higher-order_2020,
	title = {Higher-order demand-driven symbolic evaluation.},
	volume = {4},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Palmer, Zachary and Park, Theodore and Smith, Scott F and Weng, Shiwei},
	year = {2020},
	keywords = {to-read},
	pages = {102--1},
	file = {Palmer et al. - 2020 - Higher-order demand-driven symbolic evaluation..pdf:/home/tim/Zotero/storage/J95XK7NY/Palmer et al. - 2020 - Higher-order demand-driven symbolic evaluation..pdf:application/pdf},
}

@article{facchinetti_higher-order_2019,
	title = {Higher-order demand-driven program analysis},
	volume = {41},
	number = {3},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Facchinetti, Leandro and Palmer, Zachary and Smith, Scott},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--53},
	file = {Facchinetti et al. - 2019 - Higher-order demand-driven program analysis.pdf:/home/tim/Zotero/storage/E6MCWIRW/Facchinetti et al. - 2019 - Higher-order demand-driven program analysis.pdf:application/pdf},
}

@book{filinski_declarative_1989,
	title = {Declarative continuations and categorical duality},
	publisher = {Citeseer},
	author = {Filinski, Andrzej},
	year = {1989},
	keywords = {to-read},
	file = {Filinski - 1989 - Declarative continuations and categorical duality.pdf:/home/tim/Zotero/storage/SZN3YT7W/Filinski - 1989 - Declarative continuations and categorical duality.pdf:application/pdf},
}

@inproceedings{downen_computational_2020,
	title = {A computational understanding of classical (co) recursion},
	booktitle = {Proceedings of the 22nd {International} {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	author = {Downen, Paul and Ariola, Zena M},
	year = {2020},
	keywords = {to-read},
	pages = {1--13},
	file = {Downen and Ariola - 2020 - A computational understanding of classical (co) re.pdf:/home/tim/Zotero/storage/7DJYN3R9/Downen and Ariola - 2020 - A computational understanding of classical (co) re.pdf:application/pdf},
}

@article{downen_classical_2021,
	title = {Classical ({Co}) {Recursion}: {Programming}},
	journal = {arXiv preprint arXiv:2103.06913},
	author = {Downen, Paul and Ariola, Zena M},
	year = {2021},
	keywords = {to-read},
	file = {Downen and Ariola - 2021 - Classical (Co) Recursion Programming.pdf:/home/tim/Zotero/storage/W899RTIX/Downen and Ariola - 2021 - Classical (Co) Recursion Programming.pdf:application/pdf},
}

@article{petricek_coeffects_2014,
	title = {Coeffects: a calculus of context-dependent computation},
	volume = {49},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Petricek, Tomas and Orchard, Dominic and Mycroft, Alan},
	year = {2014},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {123--135},
	file = {Petricek et al. - 2014 - Coeffects a calculus of context-dependent computa.pdf:/home/tim/Zotero/storage/U6M46G66/Petricek et al. - 2014 - Coeffects a calculus of context-dependent computa.pdf:application/pdf},
}

@article{abel_copatterns_2013,
	title = {Copatterns: {Programming} infinite structures by observations},
	volume = {48},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {27--38},
}

@inproceedings{blanchette_truly_2014,
	title = {Truly modular (co) datatypes for {Isabelle}/{HOL}},
	booktitle = {Interactive {Theorem} {Proving}: 5th {International} {Conference}, {ITP} 2014, {Held} as {Part} of the {Vienna} {Summer} of {Logic}, {VSL} 2014, {Vienna}, {Austria}, {July} 14-17, 2014. {Proceedings} 5},
	publisher = {Springer},
	author = {Blanchette, Jasmin Christian and H√∂lzl, Johannes and Lochbihler, Andreas and Panny, Lorenz and Popescu, Andrei and Traytel, Dmitriy},
	year = {2014},
	keywords = {to-read},
	pages = {93--110},
}

@article{jacobs_tutorial_1997,
	title = {A tutorial on (co) algebras and (co) induction},
	volume = {62},
	journal = {Bulletin-European Association for Theoretical Computer Science},
	author = {Jacobs, Bart and Rutten, Jan},
	year = {1997},
	note = {Publisher: Citeseer},
	keywords = {to-read},
	pages = {222--259},
	file = {Jacobs and Rutten - 1997 - A tutorial on (co) algebras and (co) induction.pdf:/home/tim/Zotero/storage/MFV372GB/Jacobs and Rutten - 1997 - A tutorial on (co) algebras and (co) induction.pdf:application/pdf},
}

@article{jeannin_cocaml_2017,
	title = {Cocaml: {Functional} programming with regular coinductive types},
	volume = {150},
	number = {3-4},
	journal = {Fundamenta Informaticae},
	author = {Jeannin, Jean-Baptiste and Kozen, Dexter and Silva, Alexandra},
	year = {2017},
	note = {Publisher: IOS Press},
	keywords = {to-read},
	pages = {347--377},
}

@article{eremondi_approximate_2019,
	title = {Approximate {Normalization} for {Gradual} {Dependent} {Types}},
	volume = {3},
	url = {https://doi.org/10.1145/3341692},
	doi = {10.1145/3341692},
	abstract = {Dependent types help programmers write highly reliable code. However, this reliability comes at a cost: it can be challenging to write new prototypes in (or migrate old code to) dependently-typed programming languages. Gradual typing makes static type disciplines more flexible, so an appropriate notion of gradual dependent types could fruitfully lower this cost. However, dependent types raise unique challenges for gradual typing. Dependent typechecking involves the execution of program code, but gradually-typed code can signal runtime type errors or diverge. These runtime errors threaten the soundness guarantees that make dependent types so attractive, while divergence spoils the type-driven programming experience. This paper presents GDTL, a gradual dependently-typed language that emphasizes pragmatic dependently-typed programming. GDTL fully embeds both an untyped and dependently-typed language, and allows for smooth transitions between the two. In addition to gradual types we introduce gradual terms, which allow the user to be imprecise in type indices and to omit proof terms; runtime checks ensure type safety. To account for nontermination and failure, we distinguish between compile-time normalization and run-time execution: compile-time normalization is approximate but total, while runtime execution is exact, but may fail or diverge. We prove that GDTL has decidable typechecking and satisfies all the expected properties of gradual languages. In particular, GDTL satisfies the static and dynamic gradual guarantees: reducing type precision preserves typedness, and altering type precision does not change program behavior outside of dynamic type failures. To prove these properties, we were led to establish a novel normalization gradual guarantee that captures the monotonicity of approximate normalization with respect to imprecision.},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Eremondi, Joseph and Tanter, √âric and Garcia, Ronald},
	month = jul,
	year = {2019},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {dependent types, Gradual types, normalization, to-read},
}

@phdthesis{sullivan_essence_2018,
	type = {{PhD} {Thesis}},
	title = {The essence of codata and its implementation},
	school = {University of Oregon},
	author = {Sullivan, Zachary Joseph},
	year = {2018},
	keywords = {to-read},
}

@article{hillerstrom_asymptotic_nodate,
	title = {Asymptotic {Speedup} via {Effect} {Handlers}},
	author = {HILLERSTR√ñM, DANIEL and LINDLEY, SAM and LONGLEY, JOHN},
	keywords = {to-read},
	file = {HILLERSTR√ñM et al. - Asymptotic Speedup via Effect Handlers.pdf:/home/tim/Zotero/storage/TCMGG8JR/HILLERSTR√ñM et al. - Asymptotic Speedup via Effect Handlers.pdf:application/pdf},
}

@inproceedings{jensen_remedying_2012,
	address = {New York, NY, USA},
	series = {{ISSTA} 2012},
	title = {Remedying the {Eval} {That} {Men} {Do}},
	isbn = {978-1-4503-1454-1},
	url = {https://doi.org/10.1145/2338965.2336758},
	doi = {10.1145/2338965.2336758},
	abstract = {A range of static analysis tools and techniques have been developed in recent years with the aim of helping JavaScript web application programmers produce code that is more robust, safe, and efficient. However, as shown in a previous large-scale study, many web applications use the JavaScript eval function to dynamically construct code from text strings in ways that obstruct existing static analyses. As a consequence, the analyses either fail to reason about the web applications or produce unsound or useless results. We present an approach to soundly and automatically transform many common uses of eval into other language constructs to enable sound static analysis of web applications. By eliminating calls to eval, we expand the applicability of static analysis for JavaScript web applications in general. The transformation we propose works by incorporating a refactoring technique into a dataflow analyzer. We report on our experimental results with a small collection of programming patterns extracted from popular web sites. Although there are inevitably cases where the transformation must give up, our technique succeeds in eliminating many nontrivial occurrences of eval.},
	booktitle = {Proceedings of the 2012 {International} {Symposium} on {Software} {Testing} and {Analysis}},
	publisher = {Association for Computing Machinery},
	author = {Jensen, Simon Holm and Jonsson, Peter A. and M√∏ller, Anders},
	year = {2012},
	note = {event-place: Minneapolis, MN, USA},
	keywords = {to-read},
	pages = {34--44},
}

@inproceedings{wadler_linear_1990,
	title = {Linear types can change the world!},
	volume = {3},
	booktitle = {Programming concepts and methods},
	publisher = {Citeseer},
	author = {Wadler, Philip},
	year = {1990},
	note = {Issue: 4},
	keywords = {to-read},
	pages = {5},
	file = {Wadler - 1990 - Linear types can change the world!.pdf:/home/tim/Zotero/storage/T9LPNQGB/Wadler - 1990 - Linear types can change the world!.pdf:application/pdf},
}

@article{loh_tutorial_2010,
	title = {A tutorial implementation of a dependently typed lambda calculus},
	volume = {102},
	number = {2},
	journal = {Fundamenta informaticae},
	author = {L√∂h, Andres and McBride, Conor and Swierstra, Wouter},
	year = {2010},
	note = {Publisher: IOS Press},
	keywords = {to-read},
	pages = {177--207},
	file = {L√∂h et al. - 2010 - A tutorial implementation of a dependently typed l.pdf:/home/tim/Zotero/storage/HTQWFEGL/L√∂h et al. - 2010 - A tutorial implementation of a dependently typed l.pdf:application/pdf},
}

@inproceedings{leijen_madoko_2015,
	title = {Madoko: {Scholarly} documents for the {Web}},
	booktitle = {Proceedings of the 2015 {ACM} {Symposium} on {Document} {Engineering}},
	author = {Leijen, Daan},
	year = {2015},
	keywords = {to-read},
	pages = {129--132},
	file = {Leijen - 2015 - Madoko Scholarly documents for the Web.pdf:/home/tim/Zotero/storage/X2PHMUAY/Leijen - 2015 - Madoko Scholarly documents for the Web.pdf:application/pdf},
}

@inproceedings{germane_relatively_2019,
	title = {Relatively {Complete} {Pushdown} {Analysis} of {Escape} {Continuations}},
	booktitle = {Verification, {Model} {Checking}, and {Abstract} {Interpretation}: 20th {International} {Conference}, {VMCAI} 2019, {Cascais}, {Portugal}, {January} 13‚Äì15, 2019, {Proceedings}},
	publisher = {Springer},
	author = {Germane, Kimball and Might, Matthew},
	year = {2019},
	keywords = {to-read},
	pages = {205--225},
	file = {Germane and Might - 2019 - Relatively Complete Pushdown Analysis of Escape Co.pdf:/home/tim/Zotero/storage/RIM4Y4X9/Germane and Might - 2019 - Relatively Complete Pushdown Analysis of Escape Co.pdf:application/pdf},
}

@inproceedings{germane_liberate_2020,
	title = {Liberate {Abstract} {Garbage} {Collection} from the {Stack} by {Decomposing} the {Heap}},
	booktitle = {Programming {Languages} and {Systems}: 29th {European} {Symposium} on {Programming}, {ESOP} 2020, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2020, {Dublin}, {Ireland}, {April} 25‚Äì30, 2020, {Proceedings} 29},
	publisher = {Springer International Publishing},
	author = {Germane, Kimball and Adams, Michael D},
	year = {2020},
	keywords = {to-read},
	pages = {197--223},
	file = {Germane and Adams - 2020 - Liberate Abstract Garbage Collection from the Stac.pdf:/home/tim/Zotero/storage/ZEVNM9KE/Germane and Adams - 2020 - Liberate Abstract Garbage Collection from the Stac.pdf:application/pdf},
}

@article{germane_newly-single_2021,
	title = {Newly-single and loving it: improving higher-order must-alias analysis with heap fragments},
	volume = {5},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Germane, Kimball and McCarthy, Jay},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read, extra-to-read},
	pages = {1--28},
	file = {Germane and McCarthy - 2021 - Newly-single and loving it improving higher-order.pdf:/home/tim/Zotero/storage/IF9KQVKL/Germane and McCarthy - 2021 - Newly-single and loving it improving higher-order.pdf:application/pdf},
}

@article{germane_posteriori_2017,
	title = {A posteriori environment analysis with pushdown {Delta} {CFA}},
	volume = {52},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Germane, Kimball and Might, Matthew},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {19--31},
	file = {Germane and Might - 2017 - A posteriori environment analysis with pushdown De.pdf:/home/tim/Zotero/storage/7K9B8YPJ/Germane and Might - 2017 - A posteriori environment analysis with pushdown De.pdf:application/pdf},
}

@inproceedings{leijen_flexible_2009,
	title = {Flexible types: robust type inference for first-class polymorphism},
	booktitle = {Proceedings of the 36th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Leijen, Daan},
	year = {2009},
	keywords = {to-read},
	pages = {66--77},
	file = {Leijen - 2009 - Flexible types robust type inference for first-cl.pdf:/home/tim/Zotero/storage/GJAMNBMK/Leijen - 2009 - Flexible types robust type inference for first-cl.pdf:application/pdf},
}

@article{serrano_quick_2020,
	title = {A quick look at impredicativity},
	volume = {4},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Serrano, Alejandro and Hage, Jurriaan and Peyton Jones, Simon and Vytiniotis, Dimitrios and {others}},
	year = {2020},
	keywords = {to-read},
	pages = {1--29},
	file = {PDF:/home/tim/Zotero/storage/U5YN9GUC/Serrano et al. - 2020 - A quick look at impredicativity.pdf:application/pdf;PDF:/home/tim/Zotero/storage/CLD8QV97/Serrano et al. - 2020 - A quick look at impredicativity.pdf:application/pdf;Serrano et al. - 2020 - A quick look at impredicativity.pdf:/home/tim/Zotero/storage/CN96TFV3/Serrano et al. - 2020 - A quick look at impredicativity.pdf:application/pdf},
}

@inproceedings{flatt_units_1998,
	title = {Units: {Cool} modules for {HOT} languages},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1998 conference on {Programming} language design and implementation},
	author = {Flatt, Matthew and Felleisen, Matthias},
	year = {1998},
	keywords = {to-read},
	pages = {236--248},
	file = {Flatt and Felleisen - 1998 - Units Cool modules for HOT languages.pdf:/home/tim/Zotero/storage/MDFWS8LG/Flatt and Felleisen - 1998 - Units Cool modules for HOT languages.pdf:application/pdf},
}

@inproceedings{xie_let_2018,
	title = {Let arguments go first},
	booktitle = {Programming {Languages} and {Systems}: 27th {European} {Symposium} on {Programming}, {ESOP} 2018, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2018, {Thessaloniki}, {Greece}, {April} 14-20, 2018, {Proceedings} 27},
	publisher = {Springer},
	author = {Xie, Ningning and Oliveira, Bruno C d S},
	year = {2018},
	keywords = {to-read},
	pages = {272--299},
	file = {Xie and Oliveira - 2018 - Let arguments go first.pdf:/home/tim/Zotero/storage/7ABW6GD2/Xie and Oliveira - 2018 - Let arguments go first.pdf:application/pdf},
}

@inproceedings{xie_consistent_2018,
	title = {Consistent subtyping for all},
	booktitle = {Programming {Languages} and {Systems}: 27th {European} {Symposium} on {Programming}, {ESOP} 2018, {Held} as {Part} of the {European} {Joint} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2018, {Thessaloniki}, {Greece}, {April} 14-20, 2018, {Proceedings} 27},
	publisher = {Springer},
	author = {Xie, Ningning and Bi, Xuan and Oliveira, Bruno C d S},
	year = {2018},
	keywords = {to-read},
	pages = {3--30},
	file = {Xie et al. - 2018 - Consistent subtyping for all.pdf:/home/tim/Zotero/storage/PV5QPZUL/Xie et al. - 2018 - Consistent subtyping for all.pdf:application/pdf},
}

@inproceedings{hillerstrom_liberating_2016,
	title = {Liberating effects with rows and handlers},
	booktitle = {Proceedings of the 1st {International} {Workshop} on {Type}-{Driven} {Development}},
	author = {Hillerstr√∂m, Daniel and Lindley, Sam},
	year = {2016},
	keywords = {to-read, abstract machines},
	pages = {15--27},
	file = {Hillerstr√∂m and Lindley - 2016 - Liberating effects with rows and handlers.pdf:/home/tim/Zotero/storage/KE2GBICZ/Hillerstr√∂m and Lindley - 2016 - Liberating effects with rows and handlers.pdf:application/pdf},
}

@book{shivers_control-flow_1991,
	title = {Control-flow analysis of higher-order languages or taming lambda},
	publisher = {Carnegie Mellon University},
	author = {Shivers, Olin Grigsby},
	year = {1991},
	keywords = {to-read},
	file = {Shivers - 1991 - Control-flow analysis of higher-order languages or.pdf:/home/tim/Zotero/storage/QYH7P4UJ/Shivers - 1991 - Control-flow analysis of higher-order languages or.pdf:application/pdf},
}

@book{felleisen_semantics_2009,
	title = {Semantics engineering with {PLT} {Redex}},
	publisher = {Mit Press},
	author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew},
	year = {2009},
	keywords = {to-read},
}

@article{darais_galois_2015,
	title = {Galois transformers and modular abstract interpreters: reusable metatheory for program analysis},
	volume = {50},
	number = {10},
	journal = {ACM SIGPLAN Notices},
	author = {Darais, David and Might, Matthew and Van Horn, David},
	year = {2015},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {552--571},
	file = {Darais et al. - 2015 - Galois transformers and modular abstract interpret.pdf:/home/tim/Zotero/storage/TSFJICQD/Darais et al. - 2015 - Galois transformers and modular abstract interpret.pdf:application/pdf},
}

@article{ramachandra2014database,
  title={Database-Aware Program Optimization via Static Analysis},
  author={Ramachandra, Karthik and Guravannavar, Ravindra},
  journal={IEEE Data Eng. Bull.},
  volume={37},
  number={1},
  pages={60--69},
  year={2014},
  publisher={Citeseer}
}

@inproceedings{gilray_allocation_2016,
	title = {Allocation characterizes polyvariance: a unified methodology for polyvariant control-flow analysis},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
	author = {Gilray, Thomas and Adams, Michael D and Might, Matthew},
	year = {2016},
	keywords = {to-read},
	pages = {407--420},
	file = {Gilray et al. - 2016 - Allocation characterizes polyvariance a unified m.pdf:/home/tim/Zotero/storage/5T8HX8Q3/Gilray et al. - 2016 - Allocation characterizes polyvariance a unified m.pdf:application/pdf},
}

@inproceedings{might_improving_2006,
	title = {Improving flow analyses via Œì{CFA}: {Abstract} garbage collection and counting},
	booktitle = {Proceedings of the eleventh {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Might, Matthew and Shivers, Olin},
	year = {2006},
	keywords = {to-read},
	pages = {13--25},
	file = {Might and Shivers - 2006 - Improving flow analyses via ŒìCFA Abstract garbage.pdf:/home/tim/Zotero/storage/J4ZRNJJB/Might and Shivers - 2006 - Improving flow analyses via ŒìCFA Abstract garbage.pdf:application/pdf},
}

@article{asai_typing_2009,
	title = {On typing delimited continuations: three new solutions to the printf problem},
	volume = {22},
	journal = {Higher-order and symbolic computation},
	author = {Asai, Kenichi},
	year = {2009},
	note = {Publisher: Springer},
	keywords = {to-read},
	pages = {275--291},
	file = {Asai_2009_On typing delimited continuations.pdf:/home/tim/Zotero/storage/ID8GE6HQ/Asai_2009_On typing delimited continuations.pdf:application/pdf},
}

@article{balik_algebraic_nodate,
	title = {Algebraic {Effect} {Instance} {Scopes}},
	author = {Balik, Patrycja},
	keywords = {to-read},
	file = {Balik - Algebraic Effect Instance Scopes.pdf:/home/tim/Zotero/storage/6VKXR43F/Balik - Algebraic Effect Instance Scopes.pdf:application/pdf},
}

@inproceedings{rafkind_honu_2012,
	title = {Honu: syntactic extension for algebraic notation through enforestation},
	booktitle = {Proceedings of the 11th {International} {Conference} on {Generative} {Programming} and {Component} {Engineering}},
	author = {Rafkind, Jon and Flatt, Matthew},
	year = {2012},
	keywords = {to-read},
	pages = {122--131},
	file = {Rafkind and Flatt - 2012 - Honu syntactic extension for algebraic notation t.pdf:/home/tim/Zotero/storage/K42LLPZU/Rafkind and Flatt - 2012 - Honu syntactic extension for algebraic notation t.pdf:application/pdf},
}

@article{brachthauser_effects_2022,
	title = {Effects, capabilities, and boxes: from scope-based reasoning to type-based reasoning and back},
	volume = {6},
	number = {OOPSLA1},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Brachth√§user, Jonathan Immanuel and Schuster, Philipp and Lee, Edward and Boruch-Gruszecki, Aleksander},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {Brachth√§user et al. - 2022 - Effects, capabilities, and boxes from scope-based.pdf:/home/tim/Zotero/storage/PLQK9YLU/Brachth√§user et al. - 2022 - Effects, capabilities, and boxes from scope-based.pdf:application/pdf},
}

@article{krishnaswami_higher-order_2013,
	title = {Higher-order functional reactive programming without spacetime leaks},
	volume = {48},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Krishnaswami, Neelakantan R},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {221--232},
	file = {Krishnaswami - 2013 - Higher-order functional reactive programming witho.pdf:/home/tim/Zotero/storage/BXRZDXT9/Krishnaswami - 2013 - Higher-order functional reactive programming witho.pdf:application/pdf},
}

@inproceedings{brady_programming_2013,
	title = {Programming and reasoning with algebraic effects and dependent types},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Brady, Edwin},
	year = {2013},
	keywords = {to-read},
	pages = {133--144},
	file = {Brady - 2013 - Programming and reasoning with algebraic effects a.pdf:/home/tim/Zotero/storage/MQA6XRU9/Brady - 2013 - Programming and reasoning with algebraic effects a.pdf:application/pdf},
}

@article{cabitza_need_2021,
	title = {The need to move away from agential-{AI}: {Empirical} investigations, useful concepts and open issues},
	volume = {155},
	journal = {International Journal of Human-Computer Studies},
	author = {Cabitza, Federico and Campagner, Andrea and Simone, Carla},
	year = {2021},
	note = {Publisher: Elsevier},
	pages = {102696},
}

@incollection{littman_markov_1994,
	title = {Markov games as a framework for multi-agent reinforcement learning},
	booktitle = {Machine learning proceedings 1994},
	publisher = {Elsevier},
	author = {Littman, Michael L},
	year = {1994},
	pages = {157--163},
}

@inproceedings{oudah_how_2018,
	title = {How {AI} wins friends and influences people in repeated games with cheap talk},
	volume = {32},
	booktitle = {Proceedings of the {AAAI} {Conference} on {Artificial} {Intelligence}},
	author = {Oudah, Mayada and Rahwan, Talal and Crandall, Tawna and Crandall, Jacob},
	year = {2018},
	note = {Issue: 1},
	file = {Oudah et al. - 2018 - How AI wins friends and influences people in repea.pdf:/home/tim/Zotero/storage/8ZQKE9TK/Oudah et al. - 2018 - How AI wins friends and influences people in repea.pdf:application/pdf},
}

@inproceedings{oudah_learning_2015,
	title = {Learning to interact with a human partner},
	booktitle = {Proceedings of the tenth annual acm/ieee international conference on human-robot interaction},
	author = {Oudah, Mayada and Babushkin, Vahan and Chenlinangjia, Tennom and Crandall, Jacob W},
	year = {2015},
	pages = {311--318},
	file = {Oudah et al. - 2015 - Learning to interact with a human partner.pdf:/home/tim/Zotero/storage/93EJPZ9P/Oudah et al. - 2015 - Learning to interact with a human partner.pdf:application/pdf},
}

@article{pretnar_handling_2013,
	title = {Handling algebraic effects},
	volume = {9},
	journal = {Logical methods in computer science},
	author = {Pretnar, Matija and Plotkin, Gordon D},
	year = {2013},
	note = {Publisher: Episciences. org},
	keywords = {to-read},
	file = {Pretnar and Plotkin - 2013 - Handling algebraic effects.pdf:/home/tim/Zotero/storage/3D5MGSV6/Pretnar and Plotkin - 2013 - Handling algebraic effects.pdf:application/pdf;Pretnar_Plotkin_2013_Handling algebraic effects.pdf:/home/tim/Zotero/storage/GNGWHCZT/Pretnar_Plotkin_2013_Handling algebraic effects.pdf:application/pdf},
}

@inproceedings{vandenbroucke_fixing_2015,
	title = {Fixing non-determinism},
	booktitle = {Proceedings of the 27th {Symposium} on the {Implementation} and {Application} of {Functional} {Programming} {Languages}},
	author = {Vandenbroucke, Alexander and Schrijvers, Tom and Piessens, Frank},
	year = {2015},
	keywords = {to-read},
	pages = {1--12},
	file = {Vandenbroucke et al. - 2015 - Fixing non-determinism.pdf:/home/tim/Zotero/storage/26QKDDDK/Vandenbroucke et al. - 2015 - Fixing non-determinism.pdf:application/pdf},
}

@article{germane_deletion_2014,
	title = {Deletion: {The} curse of the red-black tree},
	volume = {24},
	number = {4},
	journal = {Journal of Functional Programming},
	author = {Germane, Kimball and Might, Matthew},
	year = {2014},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {423--433},
	file = {Germane and Might - 2014 - Deletion The curse of the red-black tree.pdf:/home/tim/Zotero/storage/TANYSSPJ/Germane and Might - 2014 - Deletion The curse of the red-black tree.pdf:application/pdf},
}

@inproceedings{ullrich_counting_2019,
	title = {Counting immutable beans: {Reference} counting optimized for purely functional programming},
	booktitle = {Proceedings of the 31st {Symposium} on {Implementation} and {Application} of {Functional} {Languages}},
	author = {Ullrich, Sebastian and de Moura, Leonardo},
	year = {2019},
	keywords = {to-read},
	pages = {1--12},
	file = {Ullrich and de Moura - 2019 - Counting immutable beans Reference counting optim.pdf:/home/tim/Zotero/storage/TDH24SCC/Ullrich and de Moura - 2019 - Counting immutable beans Reference counting optim.pdf:application/pdf},
}

@inproceedings{wu_fusion_2015,
	title = {Fusion for free: {Efficient} algebraic effect handlers},
	booktitle = {Mathematics of {Program} {Construction}: 12th {International} {Conference}, {MPC} 2015, {K√∂nigswinter}, {Germany}, {June} 29‚Äì{July} 1, 2015. {Proceedings} 12},
	publisher = {Springer International Publishing},
	author = {Wu, Nicolas and Schrijvers, Tom},
	year = {2015},
	pages = {302--322},
	file = {Wu and Schrijvers - 2015 - Fusion for free Efficient algebraic effect handle.pdf:/home/tim/Zotero/storage/VB552ZZ5/Wu and Schrijvers - 2015 - Fusion for free Efficient algebraic effect handle.pdf:application/pdf},
}

@article{xie_parallel_2021,
	title = {Parallel {Algebraic} {Effect} {Handlers}},
	journal = {arXiv preprint arXiv:2110.07493},
	author = {Xie, Ningning and Johnson, Daniel D and Maclaurin, Dougal and Paszke, Adam},
	year = {2021},
	keywords = {to-read},
}

@phdthesis{niimi_extending_2021,
	type = {{PhD} {Thesis}},
	title = {Extending {Effekt} with {Bidirectional} {Effects}},
	school = {Tokyo Institute OF Technology},
	author = {NIIMI, Kazuki},
	year = {2021},
	keywords = {to-read},
}

@inproceedings{hillerstrom_shallow_2018,
	title = {Shallow effect handlers},
	booktitle = {Programming {Languages} and {Systems}: 16th {Asian} {Symposium}, {APLAS} 2018, {Wellington}, {New} {Zealand}, {December} 2‚Äì6, 2018, {Proceedings} 16},
	publisher = {Springer International Publishing},
	author = {Hillerstr√∂m, Daniel and Lindley, Sam},
	year = {2018},
	keywords = {to-read},
	pages = {415--435},
	file = {Hillerstr√∂m and Lindley - 2018 - Shallow effect handlers.pdf:/home/tim/Zotero/storage/ZBYJ3TY9/Hillerstr√∂m and Lindley - 2018 - Shallow effect handlers.pdf:application/pdf},
}

@article{ahman_asynchronous_2021,
	title = {Asynchronous effects},
	volume = {5},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Ahman, Danel and Pretnar, Matija},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Ahman_Pretnar_2021_Asynchronous effects.pdf:/home/tim/Zotero/storage/CDQZ9RX6/Ahman_Pretnar_2021_Asynchronous effects.pdf:application/pdf},
}

@article{zhang_handling_2020,
	title = {Handling bidirectional control flow},
	volume = {4},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Zhang, Yizhou and Salvaneschi, Guido and Myers, Andrew C},
	year = {2020},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {Zhang et al. - 2020 - Handling bidirectional control flow.pdf:/home/tim/Zotero/storage/JXACGVJ6/Zhang et al. - 2020 - Handling bidirectional control flow.pdf:application/pdf},
}

@article{bauer_programming_2015,
	title = {Programming with algebraic effects and handlers},
	volume = {84},
	number = {1},
	journal = {Journal of logical and algebraic methods in programming},
	author = {Bauer, Andrej and Pretnar, Matija},
	year = {2015},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {108--123},
	file = {Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:/home/tim/Zotero/storage/4H34Y86C/Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:application/pdf},
}

@article{castagna_programming_2021,
	title = {Programming with union, intersection, and negation types},
	journal = {arXiv preprint arXiv:2111.03354},
	author = {Castagna, Giuseppe},
	year = {2021},
	keywords = {to-read},
	file = {Castagna - 2021 - Programming with union, intersection, and negation.pdf:/home/tim/Zotero/storage/HJHL5CE3/Castagna - 2021 - Programming with union, intersection, and negation.pdf:application/pdf},
}

@article{christiansen_bidirectional_2013,
	title = {Bidirectional typing rules: {A} tutorial},
	author = {Christiansen, David Raymond},
	year = {2013},
	keywords = {to-read},
	file = {Christiansen - 2013 - Bidirectional typing rules A tutorial.pdf:/home/tim/Zotero/storage/YCU37TXY/Christiansen - 2013 - Bidirectional typing rules A tutorial.pdf:application/pdf},
}

@article{biernacki_handle_2017,
	title = {Handle with care: relational interpretation of algebraic effects and handlers},
	volume = {2},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Biernacki, Dariusz and Pir√≥g, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read, extra-to-read, abstract machines},
	pages = {1--30},
	file = {Biernacki et al. - 2017 - Handle with care relational interpretation of alg.pdf:/home/tim/Zotero/storage/Q7K2N8PM/Biernacki et al. - 2017 - Handle with care relational interpretation of alg.pdf:application/pdf},
}

@inproceedings{yang_fantastic_2022,
	title = {Fantastic {Morphisms} and {Where} to {Find} {Them}: {A} {Guide} to {Recursion} {Schemes}},
	booktitle = {Mathematics of {Program} {Construction}: 14th {International} {Conference}, {MPC} 2022, {Tbilisi}, {Georgia}, {September} 26‚Äì28, 2022, {Proceedings}},
	publisher = {Springer International Publishing Cham},
	author = {Yang, Zhixuan and Wu, Nicolas},
	year = {2022},
	keywords = {to-read},
	pages = {222--267},
	file = {Yang and Wu - 2022 - Fantastic Morphisms and Where to Find Them A Guid.pdf:/home/tim/Zotero/storage/LSEUZGYS/Yang and Wu - 2022 - Fantastic Morphisms and Where to Find Them A Guid.pdf:application/pdf},
}

@inproceedings{jones_type_2000,
	title = {Type classes with functional dependencies},
	booktitle = {Programming {Languages} and {Systems}: 9th {European} {Symposium} on {Programming}, {ESOP} 2000 {Held} as {Part} of the {Joint} {European} {Conferences} on {Theory} and {Practice} of {Software}, {ETAPS} 2000 {Berlin}, {Germany}, {March} 25‚Äì{April} 2, 2000 {Proceedings}},
	publisher = {Springer Berlin Heidelberg Berlin, Heidelberg},
	author = {Jones, Mark P},
	year = {2000},
	keywords = {to-read},
	pages = {230--244},
	file = {Jones - 2000 - Type classes with functional dependencies.pdf:/home/tim/Zotero/storage/E324EWLG/Jones - 2000 - Type classes with functional dependencies.pdf:application/pdf},
}

@inproceedings{jones_type_1997,
	title = {Type classes: an exploration of the design space},
	booktitle = {Haskell workshop},
	author = {Jones, Simon Peyton and Jones, Mark and Meijer, Erik},
	year = {1997},
	keywords = {to-read},
	pages = {1--16},
	file = {Jones et al. - 1997 - Type classes an exploration of the design space.pdf:/home/tim/Zotero/storage/LHF82IUC/Jones et al. - 1997 - Type classes an exploration of the design space.pdf:application/pdf},
}

@article{flatt_submodules_2013,
	title = {Submodules in racket: you want it when, again?},
	volume = {49},
	number = {3},
	journal = {ACM SIGPLAN Notices},
	author = {Flatt, Matthew},
	year = {2013},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {13--22},
	file = {Flatt - 2013 - Submodules in racket you want it when, again.pdf:/home/tim/Zotero/storage/B7XVK5U7/Flatt - 2013 - Submodules in racket you want it when, again.pdf:application/pdf},
}

@article{flatt_composable_2002,
	title = {Composable and compilable macros: you want it when?},
	volume = {37},
	number = {9},
	journal = {ACM SIGPLAN Notices},
	author = {Flatt, Matthew},
	year = {2002},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {72--83},
	file = {Flatt - 2002 - Composable and compilable macros you want it when.pdf:/home/tim/Zotero/storage/ZXSRF34N/Flatt - 2002 - Composable and compilable macros you want it when.pdf:application/pdf},
}

@inproceedings{culpepper_macros_2019,
	title = {From macros to dsls: {The} evolution of racket},
	booktitle = {3rd summit on advances in programming languages (snapl 2019)},
	publisher = {Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik},
	author = {Culpepper, Ryan and Felleisen, Matthias and Flatt, Matthew and Krishnamurthi, Shriram},
	year = {2019},
	keywords = {to-read},
	file = {Culpepper et al. - 2019 - From macros to dsls The evolution of racket.pdf:/home/tim/Zotero/storage/CU9IKH9N/Culpepper et al. - 2019 - From macros to dsls The evolution of racket.pdf:application/pdf},
}

@article{bindings_macros_2002,
	title = {Macros that {Work} {Together}},
	author = {Bindings, Compile-Time and Flatt, Matthew and Culpepper, Ryan and Darais, David and Findler, Robert Bruce},
	year = {2002},
	keywords = {to-read},
	file = {Bindings et al. - 2002 - Macros that Work Together.pdf:/home/tim/Zotero/storage/2BEAIB5F/Bindings et al. - 2002 - Macros that Work Together.pdf:application/pdf},
}

@inproceedings{sozeau_first-class_2008,
	title = {First-class type classes},
	booktitle = {Theorem {Proving} in {Higher} {Order} {Logics}: 21st {International} {Conference}, {TPHOLs} 2008, {Montreal}, {Canada}, {August} 18-21, 2008. {Proceedings} 21},
	publisher = {Springer Berlin Heidelberg},
	author = {Sozeau, Matthieu and Oury, Nicolas},
	year = {2008},
	keywords = {to-read},
	pages = {278--293},
	file = {Sozeau and Oury - 2008 - First-class type classes.pdf:/home/tim/Zotero/storage/5AVL255B/Sozeau and Oury - 2008 - First-class type classes.pdf:application/pdf},
}

@article{flatt_binding_2016,
	title = {Binding as sets of scopes},
	volume = {51},
	number = {1},
	journal = {ACM SIGPLAN Notices},
	author = {Flatt, Matthew},
	year = {2016},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {705--717},
	file = {Flatt - 2016 - Binding as sets of scopes.pdf:/home/tim/Zotero/storage/5I2E6ZNN/Flatt - 2016 - Binding as sets of scopes.pdf:application/pdf},
}

@article{felleisen_programmable_2018,
	title = {A programmable programming language},
	volume = {61},
	number = {3},
	journal = {Communications of the ACM},
	author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram and Barzilay, Eli and McCarthy, Jay and Tobin-Hochstadt, Sam},
	year = {2018},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {62--71},
	file = {Felleisen et al. - 2018 - A programmable programming language.pdf:/home/tim/Zotero/storage/APTUTK4X/Felleisen et al. - 2018 - A programmable programming language.pdf:application/pdf},
}

@article{van_antwerpen_scopes_2018,
	title = {Scopes as types},
	volume = {2},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {van Antwerpen, Hendrik and Bach Poulsen, Casper and Rouvoet, Arjen and Visser, Eelco},
	year = {2018},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {van Antwerpen et al. - 2018 - Scopes as types.pdf:/home/tim/Zotero/storage/H9CINDJX/van Antwerpen et al. - 2018 - Scopes as types.pdf:application/pdf},
}

@inproceedings{omar_filling_2021,
	title = {Filling typed holes with live {GUIs}},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Omar, Cyrus and Moon, David and Blinn, Andrew and Voysey, Ian and Collins, Nick and Chugh, Ravi},
	year = {2021},
	keywords = {to-read},
	pages = {511--525},
}

@article{chang_dependent_2019,
	title = {Dependent type systems as macros},
	volume = {4},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Chang, Stephen and Ballantyne, Michael and Turner, Milo and Bowman, William J},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
	file = {Chang et al. - 2019 - Dependent type systems as macros.pdf:/home/tim/Zotero/storage/D6EM7QM5/Chang et al. - 2019 - Dependent type systems as macros.pdf:application/pdf},
}

@article{plotkin_tensors_2008,
	title = {Tensors of comodels and models for operational semantics},
	volume = {218},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Plotkin, Gordon and Power, John},
	year = {2008},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {295--311},
	file = {Plotkin and Power - 2008 - Tensors of comodels and models for operational sem.pdf:/home/tim/Zotero/storage/4FB6H75P/Plotkin and Power - 2008 - Tensors of comodels and models for operational sem.pdf:application/pdf},
}

@article{yallop_staged_2017,
	title = {Staged generic programming.},
	volume = {1},
	number = {ICFP},
	journal = {Proc. ACM Program. Lang.},
	author = {Yallop, Jeremy},
	year = {2017},
	keywords = {to-read},
	pages = {29--1},
	file = {Yallop - 2017 - Staged generic programming..pdf:/home/tim/Zotero/storage/2MLUMIKW/Yallop - 2017 - Staged generic programming..pdf:application/pdf},
}

@inproceedings{felleisen_expressive_2005,
	title = {On the expressive power of programming languages},
	booktitle = {{ESOP}'90: 3rd {European} {Symposium} on {Programming} {Copenhagen}, {Denmark}, {May} 15‚Äì18, 1990 {Proceedings}},
	publisher = {Springer Berlin Heidelberg Berlin, Heidelberg},
	author = {Felleisen, Matthias},
	year = {2005},
	keywords = {to-read},
	pages = {134--151},
	file = {Felleisen - 2005 - On the expressive power of programming languages.pdf:/home/tim/Zotero/storage/NSV6GLEA/Felleisen - 2005 - On the expressive power of programming languages.pdf:application/pdf},
}

@article{de_vilhena_type_2022,
	title = {A {Type} {System} for {Effect} {Handlers} and {Dynamic} {Labels}},
	author = {de Vilhena, Paulo Em√≠lio and Pottier, Fran√ßois},
	year = {2022},
	keywords = {to-read},
}

@phdthesis{geron_defined_2020,
	type = {{PhD} {Thesis}},
	title = {Defined algebraic operations},
	school = {University of Birmingham},
	author = {Geron, Bram},
	year = {2020},
	keywords = {to-read},
}

@article{brachthauser_effects_2020,
	title = {Effects as capabilities: effect handlers and lightweight effect polymorphism},
	volume = {4},
	number = {OOPSLA},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Brachth√§user, Jonathan Immanuel and Schuster, Philipp and Ostermann, Klaus},
	year = {2020},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
	file = {Brachth√§user et al. - 2020 - Effects as capabilities effect handlers and light.pdf:/home/tim/Zotero/storage/ZMKLGBE6/Brachth√§user et al. - 2020 - Effects as capabilities effect handlers and light.pdf:application/pdf},
}

@inproceedings{pirog_syntax_2018,
	title = {Syntax and semantics for operations with scopes},
	booktitle = {Proceedings of the 33rd {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	author = {Pir√≥g, Maciej and Schrijvers, Tom and Wu, Nicolas and Jaskelioff, Mauro},
	year = {2018},
	keywords = {to-read},
	pages = {809--818},
}

@inproceedings{wadler_how_1989,
	title = {How to make ad-hoc polymorphism less ad hoc},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Wadler, Philip and Blott, Stephen},
	year = {1989},
	keywords = {to-read},
	pages = {60--76},
	file = {Wadler and Blott - 1989 - How to make ad-hoc polymorphism less ad hoc.pdf:/home/tim/Zotero/storage/AI922P9M/Wadler and Blott - 1989 - How to make ad-hoc polymorphism less ad hoc.pdf:application/pdf},
}

@article{morris_abstracting_2019,
	title = {Abstracting extensible data types: or, rows by any other name},
	volume = {3},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Morris, J Garrett and McKinna, James},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--28},
	file = {Morris and McKinna - 2019 - Abstracting extensible data types or, rows by any.pdf:/home/tim/Zotero/storage/S6SF9YVF/Morris and McKinna - 2019 - Abstracting extensible data types or, rows by any.pdf:application/pdf},
}

@inproceedings{kuper_lvars_2013,
	title = {{LVars}: lattice-based data structures for deterministic parallelism},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} workshop on {Functional} high-performance computing},
	author = {Kuper, Lindsey and Newton, Ryan R},
	year = {2013},
	keywords = {to-read},
	pages = {71--84},
}

@article{hinze_chapter_2003,
	title = {Chapter 2. {Generic} {Haskell}: {Applications}},
	journal = {Generic Programming: Advanced Lectures},
	author = {Hinze, Ralf and Jeuring, Johan},
	year = {2003},
	note = {Publisher: Springer Berlin Heidelberg},
	keywords = {to-read},
	pages = {57--96},
}

@inproceedings{martins_zipper-based_2013,
	title = {Zipper-based attribute grammars and their extensions},
	booktitle = {Programming {Languages}: 17th {Brazilian} {Symposium}, {SBLP} 2013, {Bras√≠lia}, {Brazil}, {October} 3-4, 2013. {Proceedings} 17},
	publisher = {Springer Berlin Heidelberg},
	author = {Martins, Pedro and Fernandes, Jo√£o Paulo and Saraiva, Jo√£o},
	year = {2013},
	keywords = {to-read},
	pages = {135--149},
}

@article{allwood_strengthening_2010,
	title = {Strengthening the zipper},
	volume = {253},
	number = {7},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Allwood, Tristan OR and Eisenbach, Susan},
	year = {2010},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {3--18},
}

@inproceedings{hudak_aggregate_1985,
	title = {The aggregate update problem in functional programming systems},
	booktitle = {Proceedings of the 12th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	author = {Hudak, Paul and Bloss, Adrienne},
	year = {1985},
	keywords = {to-read},
	pages = {300--314},
}

@article{ehrhard_differential_2003,
	title = {The differential lambda-calculus},
	volume = {309},
	number = {1-3},
	journal = {Theoretical Computer Science},
	author = {Ehrhard, Thomas and Regnier, Laurent},
	year = {2003},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {1--41},
}

@article{altenkirch_indexed_2015,
	title = {Indexed containers},
	volume = {25},
	journal = {Journal of Functional Programming},
	author = {Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and McBride, Conor and Morris, Peter},
	year = {2015},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {e5},
}

@article{amin_collapsing_2017,
	title = {Collapsing towers of interpreters},
	volume = {2},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Amin, Nada and Rompf, Tiark},
	year = {2017},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--33},
	file = {Amin and Rompf - 2017 - Collapsing towers of interpreters.pdf:/home/tim/Zotero/storage/ETV2YI7V/Amin and Rompf - 2017 - Collapsing towers of interpreters.pdf:application/pdf},
}

@article{de_moura_beyond_2022,
	title = {Beyond {Notations}: {Hygienic} {Macro} {Expansion} for {Theorem} {Proving} {Languages}},
	volume = {18},
	journal = {Logical Methods in Computer Science},
	author = {de Moura, Leonardo and Ullrich, Sebastian},
	year = {2022},
	note = {Publisher: Episciences. org},
	keywords = {to-read},
	file = {de Moura and Ullrich - 2022 - Beyond Notations Hygienic Macro Expansion for The.pdf:/home/tim/Zotero/storage/HYEP5FXU/de Moura and Ullrich - 2022 - Beyond Notations Hygienic Macro Expansion for The.pdf:application/pdf},
}

@inproceedings{handlers_fusion_2015,
	title = {Fusion for {Free}},
	volume = {9129},
	booktitle = {Mathematics of {Program} {Construction}: 12th {International} {Conference}, {MPC} 2015, {K√∂nigswinter}, {Germany}, {June} 29‚Äì{July} 1, 2015. {Proceedings}},
	publisher = {Springer},
	author = {Handlers, Efficient Algebraic Effect},
	year = {2015},
	keywords = {to-read},
	pages = {302},
}

@article{yang_reasoning_2021,
	title = {Reasoning about effect interaction by fusion},
	volume = {5},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Yang, Zhixuan and Wu, Nicolas},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
}

@article{ghica_high-level_2022,
	title = {High-{Level} {Effect} {Handlers} in {C}+},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Ghica, Dan and Lindley, Sam and Bravo, Marcos Maro√±as and Pir√≥g, Maciej},
	year = {2022},
	note = {Publisher: Association for Computing Machinery (ACM)},
	keywords = {to-read},
	file = {Ghica et al. - 2022 - High-Level Effect Handlers in C+.pdf:/home/tim/Zotero/storage/B8ZNVN4A/Ghica et al. - 2022 - High-Level Effect Handlers in C+.pdf:application/pdf},
}

@article{bach_poulsen_hefty_2023,
	title = {Hefty {Algebras}: {Modular} {Elaboration} of {Higher}-{Order} {Algebraic} {Effects}},
	volume = {7},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Bach Poulsen, Casper and van der Rest, Cas},
	year = {2023},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1801--1831},
	file = {Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:/home/tim/Zotero/storage/XJ4BLYW9/Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:application/pdf},
}

@inproceedings{pinckney_wasmk_2020,
	title = {Wasm/k: delimited continuations for {WebAssembly}},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} {International} {Symposium} on {Dynamic} {Languages}},
	author = {Pinckney, Donald and Guha, Arjun and Brun, Yuriy},
	year = {2020},
	pages = {16--28},
}

@article{convent_adaptive_nodate,
	title = {Adaptive {Effect} {Handling} in {Frank}},
	author = {Convent, Lukas},
	keywords = {to-read},
}

@article{kammar_no_2017,
	title = {No value restriction is needed for algebraic effects and handlers},
	volume = {27},
	journal = {Journal of functional programming},
	author = {Kammar, Ohad and Pretnar, Matija},
	year = {2017},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {e7},
}

@article{pretnar_introduction_2015,
	title = {An introduction to algebraic effects and handlers. invited tutorial paper},
	volume = {319},
	journal = {Electronic notes in theoretical computer science},
	author = {Pretnar, Matija},
	year = {2015},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {19--35},
}

@article{bracevac_versatile_2018,
	title = {Versatile event correlation with algebraic effects},
	volume = {2},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Braƒçevac, Oliver and Amin, Nada and Salvaneschi, Guido and Erdweg, Sebastian and Eugster, Patrick and Mezini, Mira},
	year = {2018},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--31},
}

@article{biernacki_binders_2020,
	title = {Binders by {Day}, {Labels} by {Night}},
	author = {BIERNACKI, DARIUSZ and PIR√ìG, MACIEJ and POLESIUK, PIOTR and SIECZKOWSKI, FILIP},
	year = {2020},
	keywords = {to-read},
}

@article{biernacki_binders_2019,
	title = {Binders by day, labels by night: effect instances via lexically scoped handlers},
	volume = {4},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Biernacki, Dariusz and Pir√≥g, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
	file = {Biernacki et al. - 2019 - Binders by day, labels by night effect instances .pdf:/home/tim/Zotero/storage/P369EY33/Biernacki et al. - 2019 - Binders by day, labels by night effect instances .pdf:application/pdf},
}

@article{kung_survey_2018,
	title = {A {Survey} of {Algebraic} {Effect} {System}},
	author = {Kung, Ryan J},
	year = {2018},
	keywords = {to-read},
}

@article{zhang_abstraction-safe_2019,
	title = {Abstraction-safe effect handlers via tunneling},
	volume = {3},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Zhang, Yizhou and Myers, Andrew C},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--29},
	file = {Zhang and Myers - 2019 - Abstraction-safe effect handlers via tunneling.pdf:/home/tim/Zotero/storage/W8H2BV7H/Zhang and Myers - 2019 - Abstraction-safe effect handlers via tunneling.pdf:application/pdf},
}

@article{convent_doo_2020,
	title = {Doo bee doo bee doo},
	volume = {30},
	journal = {Journal of Functional Programming},
	author = {Convent, Lukas and Lindley, Sam and McBride, Conor and McLaughlin, Craig},
	year = {2020},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {e9},
	file = {Convent et al. - 2020 - Doo bee doo bee doo.pdf:/home/tim/Zotero/storage/KXPKZN22/Convent et al. - 2020 - Doo bee doo bee doo.pdf:application/pdf},
}

@article{sigal_automatic_2021,
	title = {Automatic differentiation via effects and handlers: {An} implementation in {Frank}},
	journal = {arXiv preprint arXiv:2101.08095},
	author = {Sigal, Jesse},
	year = {2021},
	keywords = {to-read},
}

@inproceedings{chandrasekaran_algebraic_2018,
	title = {Algebraic effect handlers go mainstream (dagstuhl seminar 18172)},
	volume = {8},
	booktitle = {Dagstuhl reports},
	publisher = {Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik},
	author = {Chandrasekaran, Sivaramakrishnan Krishnamoorthy and Leijen, Daan and Pretnar, Matija and Schrijvers, Tom},
	year = {2018},
	note = {Issue: 4},
	keywords = {to-read},
}

@article{lindley_be_nodate,
	title = {Do {Be} {Do}. {In}: {POPL}'2017. {ACM}, {New} {York}, pp. 500-514. {ISBN} 9781450346603, http://dx. doi. org/10.1145/3009837.3009897},
	author = {Lindley, Sam and McBride, Conor and McLaughlin, Craig},
	keywords = {to-read},
}

@inproceedings{xie_effect_2020,
	title = {Effect handlers in {Haskell}, evidently},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} {International} {Symposium} on {Haskell}},
	author = {Xie, Ningning and Leijen, Daan},
	year = {2020},
	keywords = {to-read},
	pages = {95--108},
	file = {Xie and Leijen - 2020 - Effect handlers in Haskell, evidently.pdf:/home/tim/Zotero/storage/7APFIGLE/Xie and Leijen - 2020 - Effect handlers in Haskell, evidently.pdf:application/pdf},
}

@article{kiselyov_implementing_2014,
	title = {Implementing, and {Understanding} {Type} {Classes}},
	journal = {updated November},
	author = {Kiselyov, Oleg},
	year = {2014},
	keywords = {to-read},
}

@inproceedings{dreyer_modular_2007,
	title = {Modular type classes},
	booktitle = {Proceedings of the 34th annual {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Dreyer, Derek and Harper, Robert and Chakravarty, Manuel MT and Keller, Gabriele},
	year = {2007},
	keywords = {to-read},
	pages = {63--70},
	file = {Dreyer et al. - 2007 - Modular type classes.pdf:/home/tim/Zotero/storage/LHQH9U9K/Dreyer et al. - 2007 - Modular type classes.pdf:application/pdf},
}

@article{white_modular_2015,
	title = {Modular implicits},
	journal = {arXiv preprint arXiv:1512.01895},
	author = {White, Leo and Bour, Fr√©d√©ric and Yallop, Jeremy},
	year = {2015},
	keywords = {to-read},
	file = {White et al. - 2015 - Modular implicits.pdf:/home/tim/Zotero/storage/Y7PLEQJ7/White et al. - 2015 - Modular implicits.pdf:application/pdf},
}

@article{peterson_implementing_1993,
	title = {Implementing type classes},
	volume = {28},
	number = {6},
	journal = {ACM SIGPLAN Notices},
	author = {Peterson, John and Jones, Mark},
	year = {1993},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {227--236},
	file = {Peterson and Jones - 1993 - Implementing type classes.pdf:/home/tim/Zotero/storage/UMIHJLGR/Peterson and Jones - 1993 - Implementing type classes.pdf:application/pdf},
}

@article{thompson_reflections_1984,
	title = {Reflections on trusting trust},
	volume = {27},
	number = {8},
	journal = {Communications of the ACM},
	author = {Thompson, Ken},
	year = {1984},
	note = {Publisher: ACM New York, NY, USA},
	pages = {761--763},
}

@inproceedings{damas_principal_1982,
	title = {Principal type-schemes for functional programs},
	booktitle = {Proceedings of the 9th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
	author = {Damas, Luis and Milner, Robin},
	year = {1982},
	keywords = {to-read},
	pages = {207--212},
	file = {Damas and Milner - 1982 - Principal type-schemes for functional programs.pdf:/home/tim/Zotero/storage/VGF8QRXU/Damas and Milner - 1982 - Principal type-schemes for functional programs.pdf:application/pdf;Damas_Milner_1982_Principal type-schemes for functional programs.pdf:/home/tim/Zotero/storage/Z8YHM369/Damas_Milner_1982_Principal type-schemes for functional programs.pdf:application/pdf},
}

@article{stanley_generatingfunctionology_1990,
	title = {Generatingfunctionology. by herbert swilf},
	volume = {97},
	number = {9},
	journal = {The American Mathematical Monthly},
	author = {Stanley, Richard P},
	year = {1990},
	note = {Publisher: Taylor \& Francis},
	pages = {864--866},
}

@inproceedings{jones_hindley-milner_1995,
	title = {From {Hindley}-{Milner} types to first-class structures},
	booktitle = {Proceedings of the {Haskell} {Workshop}},
	author = {Jones, Mark P},
	year = {1995},
	keywords = {to-read},
}

@article{mcbride_dependently_2000,
	title = {Dependently typed functional programs and their proofs},
	author = {McBride, Conor},
	year = {2000},
	note = {Publisher: University of Edinburgh. College of Science and Engineering. School of ‚Ä¶},
	keywords = {to-read},
}

@inproceedings{van_horn_abstracting_2010,
	title = {Abstracting abstract machines},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} international conference on {Functional} programming},
	author = {Van Horn, David and Might, Matthew},
	year = {2010},
	keywords = {to-read},
	pages = {51--62},
	file = {Van Horn_Might_2010_Abstracting abstract machines2.pdf:/home/tim/Zotero/storage/9DCMRDTT/Van Horn_Might_2010_Abstracting abstract machines2.pdf:application/pdf},
}

@inproceedings{leijen_type_2017,
	title = {Type directed compilation of row-typed algebraic effects},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} {Symposium} on {Principles} of {Programming} {Languages}},
	author = {Leijen, Daan},
	year = {2017},
	keywords = {to-read, continuation passing style},
	pages = {486--499},
	file = {Leijen - 2017 - Type directed compilation of row-typed algebraic e.pdf:/home/tim/Zotero/storage/CXW23ZCF/Leijen - 2017 - Type directed compilation of row-typed algebraic e.pdf:application/pdf},
}

@inproceedings{leijen_implementing_2017,
	title = {Implementing {Algebraic} {Effects} in {C}: ‚Äú{Monads} for {Free} in {C}‚Äù},
	booktitle = {Programming {Languages} and {Systems}: 15th {Asian} {Symposium}, {APLAS} 2017, {Suzhou}, {China}, {November} 27-29, 2017, {Proceedings} 15},
	publisher = {Springer International Publishing},
	author = {Leijen, Daan},
	year = {2017},
	keywords = {to-read},
	pages = {339--363},
	file = {Leijen - 2017 - Implementing Algebraic Effects in C ‚ÄúMonads for F.pdf:/home/tim/Zotero/storage/JXYHSFZJ/Leijen - 2017 - Implementing Algebraic Effects in C ‚ÄúMonads for F.pdf:application/pdf},
}

@article{xie_first-class_2022,
	title = {First-class names for effect handlers},
	volume = {6},
	number = {OOPSLA2},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
	year = {2022},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {30--59},
	file = {Xie et al_2022_First-class names for effect handlers.pdf:/home/tim/Zotero/storage/E2AULZYI/Xie et al_2022_First-class names for effect handlers.pdf:application/pdf;Xie et al_2022_First-class names for effect handlers2.pdf:/home/tim/Zotero/storage/93BGXZAT/Xie et al_2022_First-class names for effect handlers2.pdf:application/pdf},
}

@article{xie_generalized_2021-1,
	title = {Generalized evidence passing for effect handlers: efficient compilation of effect handlers to {C}},
	volume = {5},
	number = {ICFP},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xie, Ningning and Leijen, Daan},
	year = {2021},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read},
	pages = {1--30},
}

@inproceedings{reinking_perceus_2021,
	title = {Perceus: {Garbage} free reference counting with reuse},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Reinking, Alex and Xie, Ningning and de Moura, Leonardo and Leijen, Daan},
	year = {2021},
	keywords = {to-read},
	pages = {96--111},
	file = {Reinking et al_2021_Perceus.pdf:/home/tim/Zotero/storage/X3G5MLZS/Reinking et al_2021_Perceus.pdf:application/pdf;Reinking et al_2021_Perceus2.pdf:/home/tim/Zotero/storage/E3IHWH7I/Reinking et al_2021_Perceus2.pdf:application/pdf},
}

@article{mcbride_derivative_2001,
	title = {The derivative of a regular type is its type of one-hole contexts},
	journal = {Unpublished manuscript},
	author = {McBride, Conor},
	year = {2001},
	note = {Publisher: Citeseer},
	keywords = {to-read},
	pages = {74--88},
}

@article{huet_zipper_1997,
	title = {The zipper},
	volume = {7},
	number = {5},
	journal = {Journal of functional programming},
	author = {Huet, G√©rard},
	year = {1997},
	note = {Publisher: Cambridge University Press},
	keywords = {to-read},
	pages = {549--554},
}

@techreport{leijen_algebraic_2018,
	title = {Algebraic effect handlers with resources and deep finalization},
	institution = {Technical Report MSR-TR-2018-10. Microsoft Research},
	author = {Leijen, Daan},
	year = {2018},
	keywords = {to-read},
	file = {Leijen - 2018 - Algebraic effect handlers with resources and deep .pdf:/home/tim/Zotero/storage/X9UHKZHS/Leijen - 2018 - Algebraic effect handlers with resources and deep .pdf:application/pdf},
}

@article{leijen_what_nodate,
	title = {What {About} the {Integer} {Numbers}?},
	author = {LEIJEN, DAAN},
	keywords = {to-read},
	file = {LEIJEN - What About the Integer Numbers.pdf:/home/tim/Zotero/storage/WHQJLT29/LEIJEN - What About the Integer Numbers.pdf:application/pdf},
}

@article{hindley_principal_1969,
	title = {The principal type-scheme of an object in combinatory logic},
	volume = {146},
	journal = {Transactions of the american mathematical society},
	author = {Hindley, Roger},
	year = {1969},
	note = {Publisher: JSTOR},
	keywords = {to-read},
	pages = {29--60},
	file = {Hindley - 1969 - The principal type-scheme of an object in combinat.pdf:/home/tim/Zotero/storage/UHHR4S2B/Hindley - 1969 - The principal type-scheme of an object in combinat.pdf:application/pdf;PDF:/home/tim/Zotero/storage/AHCK8NRL/Hindley - 1969 - The Principal Type-Scheme of an Object in Combinatory Logic.pdf:application/pdf},
}

@article{milner_theory_1978,
	title = {A theory of type polymorphism in programming},
	volume = {17},
	number = {3},
	journal = {Journal of computer and system sciences},
	author = {Milner, Robin},
	year = {1978},
	note = {Publisher: Elsevier},
	keywords = {to-read},
	pages = {348--375},
	file = {Milner - 1978 - A theory of type polymorphism in programming.pdf:/home/tim/Zotero/storage/Z38GG6VU/Milner - 1978 - A theory of type polymorphism in programming.pdf:application/pdf},
}

@article{zabalza_novel_2016,
	title = {Novel segmented stacked autoencoder for effective dimensionality reduction and feature extraction in hyperspectral imaging},
	volume = {185},
	journal = {Neurocomputing},
	author = {Zabalza, Jaime and Ren, Jinchang and Zheng, Jiangbin and Zhao, Huimin and Qing, Chunmei and Yang, Zhijing and Du, Peijun and Marshall, Stephen},
	year = {2016},
	note = {Publisher: Elsevier},
	pages = {1--10},
}

@article{biernacki_abstracting_2019,
	title = {Abstracting algebraic effects},
	volume = {3},
	number = {POPL},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Biernacki, Dariusz and Pir√≥g, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	year = {2019},
	note = {Publisher: ACM New York, NY, USA},
	keywords = {to-read, extra-to-read, abstract machines},
	pages = {1--28},
	file = {Biernacki et al. - 2019 - Abstracting algebraic effects.pdf:/home/tim/Zotero/storage/F5TH9A97/Biernacki et al. - 2019 - Abstracting algebraic effects.pdf:application/pdf},
}

@article{bracevac_graph_2023,
	title = {Graph {IRs} for {Impure} {Higher}-{Order} {Languages}: {Making} {Aggressive} {Optimizations} {Affordable} with {Precise} {Effect} {Dependencies}},
	volume = {7},
	issn = {2475-1421},
	shorttitle = {Graph {IRs} for {Impure} {Higher}-{Order} {Languages}},
	url = {https://dl.acm.org/doi/10.1145/3622813},
	doi = {10.1145/3622813},
	abstract = {Graph-based intermediate representations (IRs) are widely used for powerful compiler optimizations, either interprocedurally in pure functional languages, or intraprocedurally in imperative languages. Yet so far, no suitable graph IR exists for aggressive global optimizations in languages with both effects and higher-order functions: aliasing and indirect control transfers make it difficult to maintain sufficiently granular dependency information for optimizations to be effective. To close this long-standing gap, we propose a novel typed graph IR combining a notion of reachability types with an expressive effect system to compute precise and granular effect dependencies at an affordable cost while supporting local reasoning and separate compilation. Our high-level graph IR imposes lexical structure to represent structured control flow and nesting, enabling aggressive and yet inexpensive code motion and other optimizations for impure higher-order programs. We formalize the new graph IR based on a Œª-calculus with a reachability type-and-effect system along with a specification of various optimizations. We present performance case studies for tensor loop fusion, CUDA kernel fusion, symbolic execution of LLVM IR, and SQL query compilation in the Scala LMS compiler framework using the new graph IR. We observe significant speedups of up to 21
              x
              .},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-03-09},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Braƒçevac, Oliver and Wei, Guannan and Jia, Songlin and Abeysinghe, Supun and Jiang, Yuxuan and Bao, Yuyan and Rompf, Tiark},
	month = oct,
	year = {2023},
	keywords = {to-read},
	pages = {400--430},
	file = {Braƒçevac et al. - 2023 - Graph IRs for Impure Higher-Order Languages Makin.pdf:/home/tim/Zotero/storage/SLHD2XVN/Braƒçevac et al. - 2023 - Graph IRs for Impure Higher-Order Languages Makin.pdf:application/pdf},
}

@article{wu_type-_nodate,
	title = {Type- and {Control}-flow {Analysis} for {System} {Fw}},
	abstract = {Type- and control-Ô¨Çow analysis combines control-Ô¨Çow analysis and type-Ô¨Çow analysis. It improves the approximation given by control-Ô¨Çow analysis by using type-Ô¨Çow information to Ô¨Ålter out abstract values with incompatible types. Type-Ô¨Çow analysis and control-Ô¨Çow analysis are mutually beneÔ¨Åcial since the control-Ô¨Çow analysis approximates the -expressions in type applications. Previously, a type- and control-Ô¨Çow analysis for System F has been deÔ¨Åned. However, System F only has limited support for polymorphism. System F√ä, a more sophisticated type system, augments System F with type-level functions, thereby introducing abstract type constructors. It enables the use of generic functions that are parameterized by polymorphic data structures. In this work, a new type- and control-Ô¨Çow analysis for System F√ä is deÔ¨Åned. This work includes a speciÔ¨Åcation-based formulation of the type- and controlÔ¨Çow analysis for System F√ä and a proof of the soundness of the analysis. This work presents a Ô¨Çow-graph-based formulation. The soundness of the Ô¨Çow-graph-based formulation is proved by relating to the speciÔ¨Åcation-based formulation.},
	language = {en},
	author = {Wu, Dongyu},
	keywords = {to-read},
	file = {Wu - Type- and Control-flow Analysis for System Fw.pdf:/home/tim/Zotero/storage/4VYZAE3Q/Wu - Type- and Control-flow Analysis for System Fw.pdf:application/pdf},
}

@article{alur_analysis_nodate,
	title = {Analysis of recursive state machines},
	volume = {27},
	language = {en},
	number = {4},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Alur, Rajeev},
	keywords = {to-read},
	file = {Alur - Analysis of recursive state machines.pdf:/home/tim/Zotero/storage/Z8JLDNP8/Alur - Analysis of recursive state machines.pdf:application/pdf},
}

@incollection{silva_algebraic_2021,
	address = {Cham},
	title = {Algebraic {Program} {Analysis}},
	volume = {12759},
	isbn = {978-3-030-81684-1 978-3-030-81685-8},
	url = {https://link.springer.com/10.1007/978-3-030-81685-8_3},
	abstract = {This paper is a tutorial on algebraic program analysis. It explains the foundations of algebraic program analysis, its strengths and limitations, and gives examples of algebraic program analyses for numerical invariant generation and termination analysis.},
	language = {en},
	urldate = {2024-03-21},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer International Publishing},
	author = {Kincaid, Zachary and Reps, Thomas and Cyphert, John},
	editor = {Silva, Alexandra and Leino, K. Rustan M.},
	year = {2021},
	doi = {10.1007/978-3-030-81685-8_3},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {46--83},
	file = {Full Text:/home/tim/Zotero/storage/6SJIJXQ4/Kincaid et al. - 2021 - Algebraic Program Analysis.pdf:application/pdf},
}

@inproceedings{kincaid_compositional_2017,
	address = {Barcelona Spain},
	title = {Compositional recurrence analysis revisited},
	isbn = {978-1-4503-4988-8},
	url = {https://dl.acm.org/doi/10.1145/3062341.3062373},
	doi = {10.1145/3062341.3062373},
	abstract = {Compositional recurrence analysis (CRA) is a static-analysis method based on a combination of symbolic analysis and abstract interpretation. This paper addresses the problem of creating a context-sensitive interprocedural version of CRA that handles recursive procedures. The problem is non-trivial because there is an ‚Äúimpedance mismatch‚Äù between CRA, which relies on analysis techniques based on regular languages (i.e., Tarjan‚Äôs path-expression method), and the context-free-language underpinnings of contextsensitive analysis.},
	language = {en},
	urldate = {2024-03-21},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Kincaid, Zachary and Breck, Jason and Boroujeni, Ashkan Forouhi and Reps, Thomas},
	month = jun,
	year = {2017},
	keywords = {to-read},
	pages = {248--262},
	file = {Full Text:/home/tim/Zotero/storage/96G34ZYI/Kincaid et al. - 2017 - Compositional recurrence analysis revisited.pdf:application/pdf},
}

@inproceedings{breck_templates_2020,
	address = {London UK},
	title = {Templates and recurrences: better together},
	isbn = {978-1-4503-7613-6},
	shorttitle = {Templates and recurrences},
	url = {https://dl.acm.org/doi/10.1145/3385412.3386035},
	doi = {10.1145/3385412.3386035},
	abstract = {This paper is the confluence of two streams of ideas in the literature on generating numerical invariants, namely: (1) template-based methods, and (2) recurrence-based methods. A template-based method begins with a template that contains unknown quantities, and finds invariants that match the template by extracting and solving constraints on the unknowns. A disadvantage of template-based methods is that they require fixing the set of terms that may appear in an invariant in advance. This disadvantage is particularly prominent for non-linear invariant generation, because the user must supply maximum degrees on polynomials, bases for exponents, etc.},
	language = {en},
	urldate = {2024-03-21},
	booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Breck, Jason and Cyphert, John and Kincaid, Zachary and Reps, Thomas},
	month = jun,
	year = {2020},
	keywords = {to-read},
	pages = {688--702},
	file = {Breck et al. - 2020 - Templates and recurrences better together.pdf:/home/tim/Zotero/storage/IZHNCZYH/Breck et al. - 2020 - Templates and recurrences better together.pdf:application/pdf},
}

@misc{nagy_automating_2024,
	title = {Automating {Unrealizability} {Logic}: {Hoare}-style {Proof} {Synthesis} for {Infinite} {Sets} of {Programs}},
	shorttitle = {Automating {Unrealizability} {Logic}},
	url = {http://arxiv.org/abs/2401.13244},
	abstract = {Unrealizability logic (UL) was proposed by Kim et al. as the first Hoare-style proof system for proving properties that hold for an infinite set of programs (defined by a regular tree grammar). The goal of our work is to automate reasoning and proof generation for UL. A key ingredient in UL is the notion of nonterminal summaries-inductive facts that characterize recursive nonterminals in the grammar that defines the set of programs. They are analogous to procedure summaries in Hoare logic. The goal of automating UL led us to reformulate the inference rules-in particular, introducing a unified rule for nonterminal summaries, called the rule of adaptation, which draws inspiration from how procedure summaries are handled in Hoare logic. In the same way that verification conditions can be used to synthesize loop invariants for Hoare logic proofs, our reformulation of UL reduces the problem of synthesizing a nonterminal summary to a Syntax-Guided Synthesis problem. We implement Wuldo, the first checker and synthesizer for UL. Wuldo can express proofs beyond the reach of existing tools, including proofs that establish how infinitely many programs behave on infinitely many inputs, and in some cases Wuldo can even synthesize the needed nonterminal summaries.},
	language = {en},
	urldate = {2024-03-21},
	publisher = {arXiv},
	author = {Nagy, Shaan and Kim, Jinwoo and D'Antoni, Loris and Reps, Thomas},
	month = jan,
	year = {2024},
	note = {arXiv:2401.13244 [cs]},
	keywords = {Computer Science - Programming Languages, to-read},
	file = {Nagy et al. - 2024 - Automating Unrealizability Logic Hoare-style Proo.pdf:/home/tim/Zotero/storage/UC999GNQ/Nagy et al. - 2024 - Automating Unrealizability Logic Hoare-style Proo.pdf:application/pdf},
}

@article{xie_effect_2020-1,
	title = {Effect handlers, evidently},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3408981},
	doi = {10.1145/3408981},
	abstract = {Algebraic effect handlers are a powerful way to incorporate effects in a programming language. Sometimes perhaps even \_too\_ powerful. In this article we define a restriction of general effect handlers with \_scoped resumptions\_. We argue one can still express all important effects, while improving reasoning about effect handlers. Using the newly gained guarantees, we define a sound and coherent evidence translation for effect handlers, which directly passes the handlers as evidence to each operation. We prove full soundness and coherence of the translation into plain lambda calculus. The evidence in turn enables efficient implementations of effect operations; in particular, we show we can execute tail-resumptive operations \_in place\_ (without needing to capture the evaluation context), and how we can replace the runtime search for a handler by indexing with a constant offset.},
	language = {en},
	number = {ICFP},
	urldate = {2024-03-21},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Xie, Ningning and Brachth√§user, Jonathan Immanuel and Hillerstr√∂m, Daniel and Schuster, Philipp and Leijen, Daan},
	month = aug,
	year = {2020},
	keywords = {to-read},
	pages = {1--29},
	file = {Xie et al. - 2020 - Effect handlers, evidently.pdf:/home/tim/Zotero/storage/66PFYG4K/Xie et al. - 2020 - Effect handlers, evidently.pdf:application/pdf},
}

@inproceedings{brachthauser_effekt_2017,
	address = {Vancouver BC Canada},
	title = {Effekt: extensible algebraic effects in {Scala} (short paper)},
	isbn = {978-1-4503-5529-2},
	shorttitle = {Effekt},
	url = {https://dl.acm.org/doi/10.1145/3136000.3136007},
	doi = {10.1145/3136000.3136007},
	abstract = {Algebraic effects are an interesting way to structure effectful programs and offer new modularity properties. We present the Scala library Effekt, which is implemented in terms of a monad for multi-prompt delimited continuations and centered around capability passing. This makes the newly proposed feature of implicit function types a perfect fit for the syntax of our library. Basing the library design on capability passing and a polymorphic embedding of effect handlers furthermore opens up interesting dimensions of extensibility. Preliminary benchmarks comparing Effekt with an established library suggest significant speedups.},
	language = {en},
	urldate = {2024-03-22},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {International} {Symposium} on {Scala}},
	publisher = {ACM},
	author = {Brachth√§user, Jonathan Immanuel and Schuster, Philipp},
	month = oct,
	year = {2017},
	keywords = {to-read},
	pages = {67--72},
	file = {Brachth√§user_Schuster_2017_Effekt.pdf:/home/tim/gdrive/Zotero/Brachth√§user_Schuster_2017_Effekt2.pdf:application/pdf},
}

@article{darais_constructive_2019,
	title = {Constructive {Galois} {Connections}},
	volume = {29},
	issn = {0956-7968, 1469-7653},
	url = {http://arxiv.org/abs/1807.08711},
	doi = {10.1017/S0956796819000066},
	abstract = {Galois connections are a foundational tool for structuring abstraction in semantics and their use lies at the heart of the theory of abstract interpretation. Yet, mechanization of Galois connections using proof assistants remains limited to restricted modes of use, preventing their general application in mechanized metatheory and certified programming. This paper presents constructive Galois connections, a variant of Galois connections that is effective both on paper and in proof assistants; is complete with respect to a large subset of classical Galois connections; and enables more general reasoning principles, including the ‚Äúcalculational‚Äù style advocated by Cousot. To design constructive Galois connections we identify a restricted mode of use of classical ones which is both general and amenable to mechanization in dependently-typed functional programming languages. Crucial to our metatheory is the addition of monadic structure to Galois connections to control a ‚Äúspecification effect.‚Äù Effectful calculations may reason classically, while pure calculations have extractable computational content. Explicitly moving between the worlds of specification and implementation is enabled by our metatheory. To validate our approach, we provide two case studies in mechanizing existing proofs from the literature: the first uses calculational abstract interpretation to design a static analyzer; the second forms a semantic basis for gradual typing. Both mechanized proofs closely follow their original paper-and-pencil counterparts, employ reasoning principles not captured by previous mechanization approaches, support the extraction of verified algorithms, and are novel.},
	language = {en},
	urldate = {2024-05-07},
	journal = {Journal of Functional Programming},
	author = {Darais, David and Van Horn, David},
	year = {2019},
	note = {arXiv:1807.08711 [cs]},
	keywords = {Computer Science - Programming Languages},
	pages = {e11},
	file = {Darais and Van Horn - 2019 - Constructive Galois Connections.pdf:/home/tim/Zotero/storage/HH9BXYBV/Darais and Van Horn - 2019 - Constructive Galois Connections.pdf:application/pdf},
}

@article{sergey_monadic_nodate,
	title = {Monadic abstract interpreters},
	abstract = {Recent developments in the systematic construction of abstract interpreters hinted at the possibility of a broad uniÔ¨Åcation of concepts in static analysis. We deliver that uniÔ¨Åcation by showing context-sensitivity, polyvariance, Ô¨Çow-sensitivity, reachabilitypruning, heap-cloning and cardinality-bounding to be independent of any particular semantics. Monads become the unifying agent between these concepts and between semantics. For instance, by plugging the same ‚Äúcontext-insensitivity monad‚Äù into a monadicallyparameterized semantics for Java or for the lambda calculus, it yields the expected context-insensitive analysis.},
	language = {en},
	author = {Sergey, Ilya and Devriese, Dominique and Might, Matthew and Midtgaard, Jan and Darais, David and Clarke, Dave and Piessens, Frank},
	keywords = {to-read},
	file = {Sergey et al. - Monadic abstract interpreters.pdf:/home/tim/Zotero/storage/LLMZ6GK2/Sergey et al. - Monadic abstract interpreters.pdf:application/pdf},
}

@article{danvy_defunctionalized_nodate,
	title = {Defunctionalized interpreters for programming languages},
	abstract = {This document illustrates how functional implementations of formal semantics (structural operational semantics, reduction semantics, small-step and big-step abstract machines, natural semantics, and denotational semantics) can be transformed into each other. These transformations were foreshadowed by Reynolds in ‚ÄúDefinitional Interpreters for Higher-Order Programming Languages‚Äù for functional implementations of denotational semantics, natural semantics, and big-step abstract machines using closure conversion, CPS transformation, and defunctionalization. Over the last few years, the author and his students have further observed that functional implementations of small-step and of big-step abstract machines are related using fusion by Ô¨Åxed-point promotion and that functional implementations of reduction semantics and of smallstep abstract machines are related using refocusing and transition compression. It furthermore appears that functional implementations of structural operational semantics and of reduction semantics are related as well, also using CPS transformation and defunctionalization. This further relation provides an element of answer to Felleisen‚Äôs conjecture that any structural operational semantics can be expressed as a reduction semantics: for deterministic languages, a reduction semantics is a structural operational semantics in continuation style, where the reduction context is a defunctionalized continuation. As the defunctionalized counterpart of the continuation of a one-step reduction function, a reduction context represents the rest of the reduction, just as an evaluation context represents the rest of the evaluation since it is the defunctionalized counterpart of the continuation of an evaluation function.},
	language = {en},
	author = {Danvy, Olivier},
	keywords = {to-read},
	file = {Danvy - Defunctionalized interpreters for programming lang.pdf:/home/tim/Zotero/storage/X6PDCJRG/Danvy - Defunctionalized interpreters for programming lang.pdf:application/pdf},
}

@article{wei_refunctionalization_2018,
	title = {Refunctionalization of abstract abstract machines: bridging the gap between abstract abstract machines and abstract definitional interpreters (functional pearl)},
	volume = {2},
	issn = {2475-1421},
	shorttitle = {Refunctionalization of abstract abstract machines},
	url = {https://dl.acm.org/doi/10.1145/3236800},
	doi = {10.1145/3236800},
	abstract = {Abstracting abstract machines is a systematic methodology for constructing sound static analyses for higher-order languages, by deriving small-step abstract abstract machines (AAMs) that perform abstract interpretation from abstract machines that perform concrete evaluation. Darais et al. apply the same underlying idea to monadic definitional interpreters, and obtain monadic abstract definitional interpreters (ADIs) that perform abstract interpretation in big-step style using monads. Yet, the relation between small-step abstract abstract machines and big-step abstract definitional interpreters is not well studied.
            In this paper, we explain their functional correspondence and demonstrate how to systematically transform small-step abstract abstract machines into big-step abstract definitional interpreters. Building on known semantic interderivation techniques from the concrete evaluation setting, the transformations include linearization, lightweight fusion, disentanglement, refunctionalization, and the left inverse of the CPS transform. Linearization expresses nondeterministic choice through first-order data types, after which refunctionalization transforms the first-order data types that represent continuations into higher-order functions. The refunctionalized AAM is an abstract interpreter written in continuation-passing style (CPS) with two layers of continuations, which can be converted back to direct style with delimited control operators. Based on the known correspondence between delimited control and monads, we demonstrate that the explicit use of monads in abstract definitional interpreters is optional.
            All transformations properly handle the collecting semantics and nondeterminism of abstract interpretation. Remarkably, we reveal how precise call/return matching in control-flow analysis can be obtained by refunctionalizing a small-step abstract abstract machine with proper caching.},
	language = {en},
	number = {ICFP},
	urldate = {2024-05-07},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Wei, Guannan and Decker, James and Rompf, Tiark},
	month = jul,
	year = {2018},
	keywords = {to-read},
	pages = {1--28},
	file = {Wei et al. - 2018 - Refunctionalization of abstract abstract machines.pdf:/home/tim/Zotero/storage/25TYPWR2/Wei et al. - 2018 - Refunctionalization of abstract abstract machines.pdf:application/pdf},
}

@article{hinze_functional_nodate,
	title = {Functional {Pearl}: {Streams} and {Unique} {Fixed} {Points}},
	abstract = {Streams, inÔ¨Ånite sequences of elements, live in a coworld: they are given by a coinductive data type, operations on streams are implemented by corecursive programs, and proofs are conducted using coinduction. But there is more to it: suitably restricted, stream equations possess unique solutions, a fact that is not very widely appreciated. We show that this property gives rise to a simple and attractive proof technique essentially bringing equational reasoning to the coworld. In fact, we redevelop the theory of recurrences, Ô¨Ånite calculus and generating functions using streams and stream operators building on the cornerstone of unique solutions. The development is constructive: streams and stream operators are implemented in Haskell, usually by one-liners. The resulting calculus or library, if you wish, is elegant and fun to use. Finally, we rephrase the proof of uniqueness using generalised algebraic data types.},
	language = {en},
	author = {Hinze, Ralf},
	file = {Hinze - Functional Pearl Streams and Unique Fixed Points.pdf:/home/tim/Zotero/storage/NPNNMCI3/Hinze - Functional Pearl Streams and Unique Fixed Points.pdf:application/pdf},
}

@article{dolan_algebraic_nodate,
	title = {Algebraic {Subtyping}},
	abstract = {Type inference gives programmers the beneÔ¨Åt of static, compile-time type checking without the cost of manually specifying types, and has long been a standard feature of functional programming languages. However, it has proven difÔ¨Åcult to integrate type inference with subtyping, since the uniÔ¨Åcation engine at the core of classical type inference accepts only equations, not subtyping constraints.},
	language = {en},
	author = {Dolan, Stephen},
	file = {Dolan - Algebraic Subtyping.pdf:/home/tim/Zotero/storage/R46IVVZI/Dolan - Algebraic Subtyping.pdf:application/pdf},
}

@article{gilray_unied_nodate,
	title = {A {UniÔ¨Åed} {Approach} to {Polyvariance} in {Abstract} {Interpretations}},
	abstract = {We describe an approach to exploring polyvariance in abstract interpretations by exposing the allocation of abstract bindings as an analysis parameter. This allocation policy is a method for selecting abstract addresses based on the current state of execution. As addresses are chosen from a Ô¨Ånite set, the allocation policy is responsible for determining the exact degree of merging which occurs between different values at a given point in the analysis. This approach allows us to select any kind of polyvariance desired through the selection of an abstract allocation function. We show how this can be done for an intermediate representation of Scheme, implementing a sound parametric framework for such analyses. We distinguish three disparate interpretations of the k-CFA hierarchy and compare them, instantiating each within our framework and motivating our approach.},
	language = {en},
	journal = {T ime},
	author = {Gilray, Thomas and Might, Matthew},
	file = {Gilray and Might - A UniÔ¨Åed Approach to Polyvariance in Abstract Inte.pdf:/home/tim/Zotero/storage/7HQU9WCN/Gilray and Might - A UniÔ¨Åed Approach to Polyvariance in Abstract Inte.pdf:application/pdf},
}

@inproceedings{gope_hash_2016,
	address = {Haifa Israel},
	title = {Hash {Map} {Inlining}},
	isbn = {978-1-4503-4121-9},
	url = {https://dl.acm.org/doi/10.1145/2967938.2967949},
	doi = {10.1145/2967938.2967949},
	abstract = {Scripting languages like Javascript and PHP are widely used to implement application logic for dynamically-generated web pages. Their popularity is due in large part to their Ô¨Çexible syntax and dynamic type system, which enable rapid turnaround time for prototyping, releasing, and updating web site features and capabilities. The most common complex data structure in these languages is the hash map, which is used to store key-value pairs. In many cases, hash maps with a Ô¨Åxed set of keys are used in lieu of explicitly deÔ¨Åned classes or structures, as would be common in compiled languages like Java or C++. Unfortunately, the runtime overhead of key lookup and value retrieval is quite high, especially relative to the direct offsets that compiled languages can use to access class members. Furthermore, key lookup and value retrieval incur high microarchitectural costs as well, since the paths they execute contain unpredictable branches and many cache accesses, leading to substantially higher numbers of branch mispredicts and cache misses per access to the hashmap. This paper quantiÔ¨Åes these overheads, describes a compiler algorithm that discovers common use cases for hash maps and inlines them so that keys are accessed with direct offsets, and reports measured performance beneÔ¨Åts on real hardware. A prototype implementation in the HipHop VM infrastructure shows promising performance beneÔ¨Åts for a broad array of hash map-intensive server-side PHP applications, up to 37.6\% and averaging 18.81\%, improves SPECWeb throughput by 7.71\% (banking) and 11.71\% (e-commerce).},
	language = {en},
	urldate = {2024-05-07},
	booktitle = {Proceedings of the 2016 {International} {Conference} on {Parallel} {Architectures} and {Compilation}},
	publisher = {ACM},
	author = {Gope, Dibakar and Lipasti, Mikko H.},
	month = sep,
	year = {2016},
	keywords = {to-read},
	pages = {235--246},
	file = {Gope and Lipasti - 2016 - Hash Map Inlining.pdf:/home/tim/Zotero/storage/EMMMPARN/Gope and Lipasti - 2016 - Hash Map Inlining.pdf:application/pdf},
}

@article{hillerstrom_foundations_nodate,
	title = {Foundations for {Programming} and {Implementing} {Effect} {Handlers}},
	language = {en},
	author = {Hillerstr√∂m, Daniel},
	keywords = {to-read, extra-to-read, abstract machines},
	file = {Hillerstr√∂m - Foundations for Programming and Implementing Effec.pdf:/home/tim/Zotero/storage/KZFN8LGX/Hillerstr√∂m - Foundations for Programming and Implementing Effec.pdf:application/pdf},
}

@article{keidel_sound_2019,
	title = {Sound and reusable components for abstract interpretation},
	volume = {3},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3360602},
	doi = {10.1145/3360602},
	abstract = {Abstract interpretation is a methodology for defining sound static analysis. Yet, building sound static analyses for modern programming languages is difficult, because these static analyses need to combine sophisticated abstractions for values, environments, stores, etc. However, static analyses often tightly couple these abstractions in the implementation, which not only complicates the implementation, but also makes it hard to decide which parts of the analyses can be proven sound independently from each other. Furthermore, this coupling makes it hard to combine soundness lemmas for parts of the analysis to a soundness proof of the complete analysis.
            
              To solve this problem, we propose to construct static analyses modularly from
              reusable analysis components
              . Each analysis component encapsulates a single analysis concern and can be proven sound independently from the analysis where it is used. We base the design of our analysis components on
              arrow transformers
              , which allows us to compose analysis components. This composition preserves soundness, which guarantees that a static analysis is sound, if all its analysis components are sound. This means that analysis developers do not have to worry about soundness as long as they reuse sound analysis components. To evaluate our approach, we developed a library of 13 reusable analysis components in Haskell. We use these components to define a
              k
              -CFA analysis for PCF and an interval and reaching definition analysis for a While language.},
	language = {en},
	number = {OOPSLA},
	urldate = {2024-05-07},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Keidel, Sven and Erdweg, Sebastian},
	month = oct,
	year = {2019},
	keywords = {to-read},
	pages = {1--28},
	file = {Keidel and Erdweg - 2019 - Sound and reusable components for abstract interpr.pdf:/home/tim/Zotero/storage/U585QFQF/Keidel and Erdweg - 2019 - Sound and reusable components for abstract interpr.pdf:application/pdf},
}

@inproceedings{leijen_structured_2017,
	address = {Oxford UK},
	title = {Structured asynchrony with algebraic effects},
	isbn = {978-1-4503-5183-6},
	url = {https://dl.acm.org/doi/10.1145/3122975.3122977},
	doi = {10.1145/3122975.3122977},
	abstract = {Algebraic effect handlers generalize many control-flow abstractions that are implemented specially in most languages, like exception handling, iterators, or backtracking. In this article, we show how we can implement full support for asynchronous programming as a library using just algebraic effect handlers. The consistent type driven approach also leads naturally to powerful abstractions like block-scoped interleaving, cancellation, and timeout‚Äôs that are lacking in other major asynchronous frameworks. We also introduce the concept of ambient state to reason about state that is local to the current strand of asynchronous execution.},
	language = {en},
	urldate = {2024-05-07},
	booktitle = {Proceedings of the 2nd {ACM} {SIGPLAN} {International} {Workshop} on {Type}-{Driven} {Development}},
	publisher = {ACM},
	author = {Leijen, Daan},
	month = sep,
	year = {2017},
	keywords = {to-read},
	pages = {16--29},
	file = {Leijen - 2017 - Structured asynchrony with algebraic effects.pdf:/home/tim/Zotero/storage/SQ95L55I/Leijen - 2017 - Structured asynchrony with algebraic effects.pdf:application/pdf},
}

@article{owens_structures_nodate,
	title = {From structures and functors to modules and units},
	abstract = {Component programming techniques encourage abstraction and reuse through external linking. Some parts of a program, however, must use concrete, internally speciÔ¨Åed references, so a pure component system is not a sufÔ¨Åcient mechanism for structuring programs. We present the combination of a static, internally-linked module system and a purely abstractive component system. The latter extends our previous model of typed units to properly account for translucency and sharing. We also show how units and modules can express an SML-style system of structures and functors, and we explore the consequences for recursive structures and functors.},
	language = {en},
	author = {Owens, Scott and Flatt, Matthew},
	keywords = {to-read},
	file = {Owens and Flatt - From structures and functors to modules and units.pdf:/home/tim/Zotero/storage/H24C578A/Owens and Flatt - From structures and functors to modules and units.pdf:application/pdf},
}

@article{swierstra_data_2008,
	title = {Data types √† la carte},
	volume = {18},
	issn = {0956-7968, 1469-7653},
	url = {http://www.journals.cambridge.org/abstract_S0956796808006758},
	doi = {10.1017/S0956796808006758},
	abstract = {This paper describes a technique for assembling both data types and functions from isolated individual components. We also explore how the same technology can be used to combine free monads and, as a result, structure Haskell‚Äôs monolithic IO monad.},
	language = {en},
	number = {04},
	urldate = {2024-05-07},
	journal = {Journal of Functional Programming},
	author = {Swierstra, Wouter},
	month = jul,
	year = {2008},
	file = {Swierstra - 2008 - Data types √† la carte.pdf:/home/tim/Zotero/storage/K66433J3/Swierstra - 2008 - Data types √† la carte.pdf:application/pdf},
}

@incollection{hutchison_pointer-range_2004,
	address = {Berlin, Heidelberg},
	title = {Pointer-{Range} {Analysis}},
	volume = {3148},
	isbn = {978-3-540-22791-5 978-3-540-27864-1},
	url = {http://link.springer.com/10.1007/978-3-540-27864-1_12},
	abstract = {Array-Range Analysis computes at compile time the range of possible index values for each array-index expression in a program. This information can be used to detect potential out-of-bounds array accesses and to identify non-aliasing array accesses. In a language like C, where arrays can be accessed indirectly via pointers, and where pointer arithmetic is allowed, range analysis must be extended to compute the range of possible values for each pointer dereference.},
	language = {en},
	urldate = {2024-05-07},
	booktitle = {Static {Analysis}},
	publisher = {Springer Berlin Heidelberg},
	author = {Yong, Suan Hsi and Horwitz, Susan},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Giacobazzi, Roberto},
	year = {2004},
	doi = {10.1007/978-3-540-27864-1_12},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {133--148},
	file = {Yong and Horwitz - 2004 - Pointer-Range Analysis.pdf:/home/tim/Zotero/storage/P4R6MKQJ/Yong and Horwitz - 2004 - Pointer-Range Analysis.pdf:application/pdf},
}

@article{pirog_typed_2019,
	title = {Typed {Equivalence} of {Effect} {Handlers} and {Delimited} {Control}},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	issn = {1868-8969},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2019.30},
	doi = {10.4230/LIPICS.FSCD.2019.30},
	abstract = {It is folklore that eÔ¨Äect handlers and delimited control operators are closely related: recently, this relationship has been proved in an untyped setting for deep handlers and the shift0 delimited control operator. We positively resolve the conjecture that in an appropriately polymorphic type system this relationship can be extended to the level of types, by identifying the necessary forms of polymorphism, thus extending the deÔ¨Ånability result to the typed context. In the process, we identify a novel and potentially interesting type system feature for delimited control operators. Moreover, we extend these results to substantiate the folklore connection between shallow handlers and control0 Ô¨Çavour of delimited control, both in an untyped and typed settings.},
	language = {en},
	urldate = {2024-05-08},
	author = {Pir√≥g, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
	collaborator = {Geuvers, Herman},
	year = {2019},
	note = {Artwork Size: 16 pages, 500253 bytes
ISBN: 9783959771078
Medium: application/pdf
Publisher: [object Object]
Version Number: 1.0},
	keywords = {algebraic effects, delimited control, macro expressibility, Software and its engineering ‚Üí Polymorphism, Theory of computation ‚Üí Control primitives, Theory of computation ‚Üí Operational semantics, type-and-effect systems, abstract machines},
	pages = {16 pages, 500253 bytes},
	file = {Pir√≥g et al. - 2019 - Typed Equivalence of Effect Handlers and Delimited.pdf:/home/tim/Zotero/storage/9Z4FMZGH/Pir√≥g et al. - 2019 - Typed Equivalence of Effect Handlers and Delimited.pdf:application/pdf},
}

@article{brachthauser_programming_nodate,
	title = {Programming with {Implicit} {Values}, {Functions}, and {Controlor}, {Implicit} {Functions}: {Dynamic} {Binding} with {Lexical} {ScopingMicrosoft} {Technical} {Report}, {MSR}-{TR}-2019-7, v2.},
	abstract = {We introduce two new language features, called implicit functions and implicit control. Both generalize implicit values which are a typed implementation of dynamic binding. Implicit functions are bound dynamically but evaluated in the lexical scope of their binding. We show how this small generalization from regular implicit values leads to better abstraction. In particular, implicit functions encapsulate (side) effects at the definition site, as opposed to leaking them to the call site. Implicit control further generalizes implicit functions by adding the ability to return into the lexical scope of the binding or to resume to the call-site. We formalize the new features as an extension to Moreau‚Äôs calculus of dynamic binding (1998). Unifying all three language features in one framework guarantees that the interaction between implicit values, functions, and control is well-defined. We also show how our semantics correspond to a macro-translation into algebraic effect handlers.},
	language = {en},
	author = {Brachth√§user, Jonathan and Leijen, Daan},
	file = {Brachth√§user and Leijen - Programming with Implicit Values, Functions, and C.pdf:/home/tim/Zotero/storage/EBU6EIUZ/Brachth√§user and Leijen - Programming with Implicit Values, Functions, and C.pdf:application/pdf},
}

@article{materzok_subtyping_nodate,
	title = {Subtyping delimited continuations},
	abstract = {We present a type system with subtyping for Ô¨Årst-class delimited continuations that generalizes Danvy and Filinski‚Äôs type system for shift and reset by maintaining explicit information about the types of contexts in the metacontext. We exploit this generalization by considering the control operators known as shift0 and reset0 that can access arbitrary contexts in the metacontext. We use subtyping to control the level of information about the metacontext the expression actually requires and in particular to coerce pure expressions into effectful ones. For this type system we prove strong type soundness and termination of evaluation and we present a provably correct type reconstruction algorithm. We also introduce two CPS translations for shift0 and reset0: one targeting the untyped lambda calculus, and another‚Äîtype-directed‚Äîtargeting the simply-typed lambda calculus. The latter translation preserves typability and is selective in that it keeps pure expressions in direct style.},
	language = {en},
	author = {Materzok, Marek and Biernacki, Dariusz},
	keywords = {delimited control, extra-to-read, abstract machines},
	file = {Materzok and Biernacki - Subtyping delimited continuations.pdf:/home/tim/Zotero/storage/ATYB5AIT/Materzok and Biernacki - Subtyping delimited continuations.pdf:application/pdf},
}

@article{biernacka_generalized_2017,
	title = {Generalized {Refocusing}: {From} {Hybrid} {Strategies} to {Abstract} {Machines}},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	issn = {1868-8969},
	shorttitle = {Generalized {Refocusing}},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2017.10},
	doi = {10.4230/LIPICS.FSCD.2017.10},
	abstract = {We present a generalization of the refocusing procedure that provides a generic method for deriving an abstract machine from a speciÔ¨Åcation of a reduction semantics satisfying simple initial conditions. The proposed generalization is applicable to a class of reduction semantics encoding hybrid strategies as well as uniform strategies handled by the original refocusing method. The resulting machine is proved to correctly trace (i.e., bisimulate in smaller steps) the input reduction semantics. The procedure and the correctness proofs have been formalized in the Coq proof assistant.},
	language = {en},
	urldate = {2024-05-14},
	author = {Biernacka, Malgorzata and Charatonik, Witold and Zielinska, Klara},
	collaborator = {Miller, Dale},
	year = {2017},
	note = {Artwork Size: 17 pages, 507137 bytes
ISBN: 9783959770477
Medium: application/pdf
Publisher: [object Object]},
	keywords = {extra-to-read, abstract machines, Coq, formal verification, reduction semantics},
	pages = {17 pages, 507137 bytes},
	file = {Biernacka et al. - 2017 - Generalized Refocusing From Hybrid Strategies to .pdf:/home/tim/Zotero/storage/LBQQMP9K/Biernacka et al. - 2017 - Generalized Refocusing From Hybrid Strategies to .pdf:application/pdf},
}

@article{saleh_efficient_nodate,
	title = {Efficient {Algebraic} {Effect} {Handlers}},
	language = {en},
	author = {Saleh, Amr Hany},
	keywords = {extra-to-read},
	file = {Saleh - Efficient Algebraic Effect Handlers.pdf:/home/tim/Zotero/storage/4BDQZBG5/Saleh - Efficient Algebraic Effect Handlers.pdf:application/pdf},
}

@inproceedings{biernacki_reflecting_2021,
	address = {Tallinn Estonia},
	title = {Reflecting {Stacked} {Continuations} in a {Fine}-{Grained} {Direct}-{Style} {Reduction} {Theory}},
	isbn = {978-1-4503-8689-0},
	url = {https://dl.acm.org/doi/10.1145/3479394.3479399},
	doi = {10.1145/3479394.3479399},
	abstract = {The delimited-control operator shift0 has been formally shown to capture the operational semantics of deep handlers for algebraic effects. Its CPS translation generates Œª-terms in which continuation composition is not expressed in terms of nested function calls, as is typical of other delimited-control operators, e.g. shift, but with function applications consuming a sequence of continuations one at a time, as if they formed a stack.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {23rd {International} {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	publisher = {ACM},
	author = {Biernacki, Dariusz and Pyzik, Mateusz and Sieczkowski, Filip},
	month = sep,
	year = {2021},
	keywords = {delimited control, extra-to-read},
	pages = {1--13},
	file = {Biernacki et al. - 2021 - Reflecting Stacked Continuations in a Fine-Grained.pdf:/home/tim/Zotero/storage/BZU3HJDH/Biernacki et al. - 2021 - Reflecting Stacked Continuations in a Fine-Grained.pdf:application/pdf},
}

@incollection{swierstra_understanding_2022,
	address = {Cham},
	title = {Understanding {Algebraic} {Effect} {Handlers} via {Delimited} {Control} {Operators}},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_4},
	abstract = {Algebraic eÔ¨Äects and handlers are a powerful and convenient abstraction for user-deÔ¨Åned eÔ¨Äects. We aim to understand eÔ¨Äect handlers through the lens of control operators, a similar but more well-studied tool for expressing eÔ¨Äects. In this paper, we establish two program transformations and a type system for eÔ¨Äect handlers, all by reusing the existing results about control operators and their relationship to eÔ¨Äect handlers.},
	language = {en},
	urldate = {2024-05-14},
	booktitle = {Trends in {Functional} {Programming}},
	publisher = {Springer International Publishing},
	author = {Cong, Youyou and Asai, Kenichi},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4_4},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {delimited control, extra-to-read},
	pages = {59--79},
	file = {Cong and Asai - 2022 - Understanding Algebraic Effect Handlers via Delimi.pdf:/home/tim/Zotero/storage/M64HZQRS/Cong and Asai - 2022 - Understanding Algebraic Effect Handlers via Delimi.pdf:application/pdf},
}

@book{swierstra_trends_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Trends in {Functional} {Programming}: 23rd {International} {Symposium}, {TFP} 2022, {Virtual} {Event}, {March} 17‚Äì18, 2022, {Revised} {Selected} {Papers}},
	volume = {13401},
	copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	shorttitle = {Trends in {Functional} {Programming}},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4},
	language = {en},
	urldate = {2024-05-14},
	publisher = {Springer International Publishing},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	year = {2022},
	doi = {10.1007/978-3-031-21314-4},
	keywords = {to-read},
	file = {Swierstra and Wu - 2022 - Trends in Functional Programming 23rd Internation.pdf:/home/tim/Zotero/storage/ZGBD6TF6/Swierstra and Wu - 2022 - Trends in Functional Programming 23rd Internation.pdf:application/pdf},
}

@inproceedings{kammar_handlers_2013,
	address = {Boston Massachusetts USA},
	title = {Handlers in action},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500590},
	doi = {10.1145/2500365.2500590},
	abstract = {Plotkin and Pretnar‚Äôs handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types.},
	language = {en},
	urldate = {2024-05-09},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {ACM},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	month = sep,
	year = {2013},
	keywords = {delimited control},
	pages = {145--158},
	file = {Kammar et al. - 2013 - Handlers in action.pdf:/home/tim/Zotero/storage/B7QNWHC9/Kammar et al. - 2013 - Handlers in action.pdf:application/pdf},
}

@article{hillerstrom_effect_2020,
	title = {Effect handlers via generalised continuations},
	volume = {30},
	copyright = {https://www.cambridge.org/core/terms},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796820000040/type/journal_article},
	doi = {10.1017/S0956796820000040},
	abstract = {Plotkin and Pretnar‚Äôs effect handlers offer a versatile abstraction for modular programming with user-deÔ¨Åned effects. This paper focuses on foundations for implementing effect handlers, for the three different kinds of effect handlers that have been proposed in the literature: deep, shallow, and parameterised.},
	language = {en},
	urldate = {2024-05-15},
	journal = {Journal of Functional Programming},
	author = {Hillerstr√∂m, Daniel and Lindley, Sam and Atkey, Robert},
	year = {2020},
	keywords = {extra-to-read, continuation passing style},
	pages = {e5},
	file = {Hillerstr√∂m et al. - 2020 - Effect handlers via generalised continuations.pdf:/home/tim/Zotero/storage/J8UHRIAK/Hillerstr√∂m et al. - 2020 - Effect handlers via generalised continuations.pdf:application/pdf;Hillerstr√∂m et al. - 2020 - Effect handlers via generalised continuations.pdf:/home/tim/Zotero/storage/V2RPXFQ7/Hillerstr√∂m et al. - 2020 - Effect handlers via generalised continuations.pdf:application/pdf},
}

@article{kameyama_sound_nodate,
	title = {A {Sound} and {Complete} {Axiomatization} of {Delimited} {Continuations}},
	abstract = {The shift and reset operators, proposed by Danvy and Filinski, are powerful control primitives for capturing delimited continuations. Delimited continuation is a similar concept as the standard (unlimited) continuation, but it represents part of the rest of the computation, rather than the whole rest of computation. In the literature, the semantics of shift and reset has been given by a CPS-translation only. This paper gives a direct axiomatization of calculus with shift and reset, namely, we introduce a set of equations, and prove that it is sound and complete with respect to the CPS-translation. We also introduce a calculus with control operators which is as expressive as the calculus with shift and reset, has a sound and complete axiomatization, and is conservative over Sabry and Felleisen‚Äôs theory for Ô¨Årst-class continuations.},
	language = {en},
	author = {Kameyama, Yukiyoshi and Hasegawa, Masahito},
	keywords = {extra-to-read},
	file = {Kameyama and Hasegawa - A Sound and Complete Axiomatization of Delimited C.pdf:/home/tim/Zotero/storage/35553A4Z/Kameyama and Hasegawa - A Sound and Complete Axiomatization of Delimited C.pdf:application/pdf},
}

@article{kameyama_axioms_2007,
	title = {Axioms for control operators in the {CPS} hierarchy},
	volume = {20},
	copyright = {http://www.springer.com/tdm},
	issn = {1388-3690, 1573-0557},
	url = {http://link.springer.com/10.1007/s10990-007-9009-x},
	doi = {10.1007/s10990-007-9009-x},
	abstract = {A CPS translation is a syntactic translation of programs, which is useful for describing their operational behavior. By iterating the standard call-by-value CPS translation, Danvy and Filinski discovered the CPS hierarchy and proposed a family of control operators, shift and reset, that make it possible to capture successive delimited continuations in a CPS hierarchy.},
	language = {en},
	number = {4},
	urldate = {2024-05-15},
	journal = {Higher-Order and Symbolic Computation},
	author = {Kameyama, Yukiyoshi},
	month = nov,
	year = {2007},
	keywords = {extra-to-read},
	pages = {339--369},
	file = {Kameyama - 2007 - Axioms for control operators in the CPS hierarchy.pdf:/home/tim/Zotero/storage/DZIY7DNE/Kameyama - 2007 - Axioms for control operators in the CPS hierarchy.pdf:application/pdf},
}

@incollection{selinger_survey_2010,
	title = {A survey of graphical languages for monoidal categories},
	volume = {813},
	url = {http://arxiv.org/abs/0908.3347},
	abstract = {This article is intended as a reference guide to various notions of monoidal categories and their associated string diagrams. It is hoped that this will be useful not just to mathematicians, but also to physicists, computer scientists, and others who use diagrammatic reasoning. We have opted for a somewhat informal treatment of topological notions, and have omitted most proofs. Nevertheless, the exposition is sufÔ¨Åciently detailed to make it clear what is presently known, and to serve as a starting place for more in-depth study. Where possible, we provide pointers to more rigorous treatments in the literature. Where we include results that have only been proved in special cases, we indicate this in the form of caveats.},
	language = {en},
	urldate = {2024-05-17},
	author = {Selinger, Peter},
	year = {2010},
	doi = {10.1007/978-3-642-12821-9_4},
	note = {arXiv:0908.3347 [math]},
	keywords = {to-read, 18D10, Mathematics - Category Theory},
	pages = {289--355},
	file = {Selinger - 2010 - A survey of graphical languages for monoidal categ.pdf:/home/tim/Zotero/storage/EZ8CV8S6/Selinger - 2010 - A survey of graphical languages for monoidal categ.pdf:application/pdf},
}

@article{guerrini_sharing_2005,
	title = {Sharing {Implementations} of {Graph} {Rewriting} {Systems}},
	volume = {127},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066105050164},
	doi = {10.1016/j.entcs.2005.04.020},
	abstract = {Sharing graphs are a brilliant solution to the implementation of L¬¥evy optimal reductions of Œªcalculus. Sharing graphs are interesting on their own and optimal sharing reductions are just a particular reduction strategy of a more general sharing reduction system.},
	language = {en},
	number = {5},
	urldate = {2024-05-17},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Guerrini, Stefano},
	month = may,
	year = {2005},
	keywords = {to-read},
	pages = {113--132},
	file = {Guerrini - 2005 - Sharing Implementations of Graph Rewriting Systems.pdf:/home/tim/Zotero/storage/MVUXQ75B/Guerrini - 2005 - Sharing Implementations of Graph Rewriting Systems.pdf:application/pdf},
}

@incollection{hutchison_call-by-name_2005,
	address = {Berlin, Heidelberg},
	title = {Call-by-{Name} and {Call}-by-{Value} as {Token}-{Passing} {Interaction} {Nets}},
	volume = {3461},
	isbn = {978-3-540-25593-2 978-3-540-32014-2},
	url = {http://link.springer.com/10.1007/11417170_28},
	abstract = {Two common misbeliefs about encodings of the Œª-calculus in interaction nets (INs) are that they are good only for strategies that are not very well understood (e.g. optimal reduction) and that they always have to deal in a complex way with boxes. In brief, the theory of interaction nets is more or less disconnected from the standard theory: we can do things in INs that we cannot do with terms, which is true [5, 10]; and we cannot do in INs things that can easily be done with terms. This paper contributes to Ô¨Åghting this misbelief by showing that the standard call-by-name and call-by-value strategies of the Œª-calculus are encoded in interaction nets in a very simple and extensible way, and in particular that these encodings do not need any notion of box. This work can also be seen as a Ô¨Årst step towards a generic approach to derive graph-based abstract machines.},
	language = {en},
	urldate = {2024-05-17},
	booktitle = {Typed {Lambda} {Calculi} and {Applications}},
	publisher = {Springer Berlin Heidelberg},
	author = {Sinot, Fran√ßois-R√©gis},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Urzyczyn, Pawe≈Ç},
	year = {2005},
	doi = {10.1007/11417170_28},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {to-read},
	pages = {386--400},
	file = {Sinot - 2005 - Call-by-Name and Call-by-Value as Token-Passing In.pdf:/home/tim/Zotero/storage/9HYN9SMQ/Sinot - 2005 - Call-by-Name and Call-by-Value as Token-Passing In.pdf:application/pdf},
}

@misc{alvarez-picallo_functorial_2021,
	title = {Functorial {String} {Diagrams} for {Reverse}-{Mode} {Automatic} {Differentiation}},
	url = {http://arxiv.org/abs/2107.13433},
	abstract = {We enhance the calculus of string diagrams for monoidal categories with hierarchical features in order to capture closed monoidal (and cartesian closed) structure. Using this new syntax we formulate an automatic differentiation algorithm for (applied) simply typed lambda calculus in the style of [Pearlmutter and Siskind 2008] and we prove for the first time its soundness. To give an efficient yet principled implementation of the AD algorithm we define a sound and complete representation of hierarchical string diagrams as a class of hierarchical hypergraphs we call hypernets.},
	language = {en},
	urldate = {2024-05-17},
	publisher = {arXiv},
	author = {Alvarez-Picallo, Mario and Ghica, Dan R. and Sprunger, David and Zanasi, Fabio},
	month = jul,
	year = {2021},
	note = {arXiv:2107.13433 [cs]},
	keywords = {Computer Science - Programming Languages, to-read, Computer Science - Machine Learning, I.2.5},
	file = {Alvarez-Picallo et al. - 2021 - Functorial String Diagrams for Reverse-Mode Automa.pdf:/home/tim/Zotero/storage/Y3BIQK9M/Alvarez-Picallo et al. - 2021 - Functorial String Diagrams for Reverse-Mode Automa.pdf:application/pdf},
}

@inproceedings{mackie_compiling_1998,
	title = {Compiling the {Lambda} {Calculus} into {Interaction} {Combinators}},
	booktitle = {Logical {Abstract} {Machines} workshop},
	author = {Mackie, Ian and Pinto, Jorge Sousa},
	year = {1998},
	keywords = {to-read},
}

@article{mackie_encoding_nodate,
	title = {Encoding {Linear} {Logic} with {Interaction} {Combinators}},
	abstract = {The purpose of this paper is to demonstrate how Lafont‚Äôs interaction combinators, a system of three symbols and six interaction rules, can be used to encode linear logic. SpeciÔ¨Åcally, we give a translation of the multiplicative, exponential and additive fragments of linear logic together with a strategy for cut-elimination which can be faithfully simulated. Finally, we show brieÔ¨Çy how this encoding can be used for evaluating -terms. In addition to offering a very simple, perhaps the simplest, system of rewriting for linear logic and the -calculus, the interaction net implementation that we present has been shown by experimental testing to offer a good level of sharing, in terms of the number of cut-elimination steps (resp. ¬¨reduction steps). In particular it performs better than all extant Ô¨Ånite systems of interaction nets.},
	language = {en},
	author = {Mackie, Ian},
	keywords = {to-read},
	file = {Mackie - Encoding Linear Logic with Interaction Combinators.pdf:/home/tim/Zotero/storage/YC6NSVZ6/Mackie - Encoding Linear Logic with Interaction Combinators.pdf:application/pdf},
}

@misc{yoshioka_abstracting_2024,
	title = {Abstracting {Effect} {Systems} for {Algebraic} {Effect} {Handlers}},
	url = {http://arxiv.org/abs/2404.16381},
	abstract = {Many effect systems for algebraic effect handlers are designed to guarantee that all invoked effects are handled adequately. However, respective researchers have developed their own effect systems that differ in how to represent the collections of effects that may happen. This situation results in blurring what is required for the representation and manipulation of effect collections in a safe effect system. In this work, we present a language \$\{{\textbackslash}lambda\_\{{\textbackslash}mathrm\{EA\}\}\}\$ equipped with an effect system that abstracts the existing effect systems for algebraic effect handlers. The effect system of \$\{{\textbackslash}lambda\_\{{\textbackslash}mathrm\{EA\}\}\}\$ is parameterized over effect algebras, which abstract the representation and manipulation of effect collections in safe effect systems. We prove the type-and-effect safety of \$\{{\textbackslash}lambda\_\{{\textbackslash}mathrm\{EA\}\}\}\$ by assuming that a given effect algebra meets certain properties called safety conditions. As a result, we can obtain the safety properties of a concrete effect system by proving that an effect algebra corresponding to the concrete system meets the safety conditions. We also show that effect algebras meeting the safety conditions are expressive enough to accommodate some existing effect systems, each of which represents effect collections in a different style. Our framework can also differentiate the safety aspects of the effect collections of the existing effect systems. To this end, we extend \$\{{\textbackslash}lambda\_\{{\textbackslash}mathrm\{EA\}\}\}\$ and the safety conditions to lift coercions and type-erasure semantics, propose other effect algebras including ones for which no effect system has been studied in the literature, and compare which effect algebra is safe and which is not for the extensions.},
	language = {en},
	urldate = {2024-05-17},
	publisher = {arXiv},
	author = {Yoshioka, Takuma and Sekiyama, Taro and Igarashi, Atsushi},
	month = apr,
	year = {2024},
	note = {arXiv:2404.16381 [cs]},
	keywords = {Computer Science - Programming Languages, extra-to-read, D.3.1, D.3.2, D.3.3, F.3.3},
	file = {Yoshioka et al. - 2024 - Abstracting Effect Systems for Algebraic Effect Ha.pdf:/home/tim/Zotero/storage/RRPSS7JT/Yoshioka et al. - 2024 - Abstracting Effect Systems for Algebraic Effect Ha.pdf:application/pdf},
}

@inproceedings{vytiniotis_let_2010,
	address = {Madrid Spain},
	title = {Let should not be generalized},
	isbn = {978-1-60558-891-9},
	url = {https://dl.acm.org/doi/10.1145/1708016.1708023},
	doi = {10.1145/1708016.1708023},
	abstract = {From the dawn of time, all derivatives of the classic Hindley-Milner type system have supported implicit generalisation of local letbindings. Yet, as we will show, for more sophisticated type systems implicit let-generalisation imposes a disproportionate complexity burden. Moreover, it turns out that the feature is very seldom used, so we propose to eliminate it. The payoff is a substantial simpliÔ¨Åcation, both of the speciÔ¨Åcation of the type system, and of its implementation.},
	language = {en},
	urldate = {2024-05-22},
	booktitle = {Proceedings of the 5th {ACM} {SIGPLAN} workshop on {Types} in language design and implementation},
	publisher = {ACM},
	author = {Vytiniotis, Dimitrios and Peyton Jones, Simon and Schrijvers, Tom},
	month = jan,
	year = {2010},
	keywords = {extra-to-read},
	pages = {39--50},
	file = {Vytiniotis et al. - 2010 - Let should not be generalized.pdf:/home/tim/Zotero/storage/IVL8BIUX/Vytiniotis et al. - 2010 - Let should not be generalized.pdf:application/pdf},
}

@article{flatt_rhombus_2023,
	title = {Rhombus: {A} {New} {Spin} on {Macros} without {All} the {Parentheses}},
	volume = {7},
	issn = {2475-1421},
	shorttitle = {Rhombus},
	url = {https://dl.acm.org/doi/10.1145/3622818},
	doi = {10.1145/3622818},
	abstract = {MATTHEW FLATT, University of Utah, USA TAYLOR ALLRED, University of Utah, USA NIA ANGLE, independent, USA STEPHEN DE GABRIELLE, independent, UK ROBERT BRUCE FINDLER, Northwestern University, USA JACK FIRTH, independent, USA KIRAN GOPINATHAN, National University of Singapore, Singapore BEN GREENMAN, Brown University, USA SIDDHARTHA KASIVAJHULA, independent, USA ALEX KNAUTH, independent, USA JAY MCCARTHY, Reach, USA SAM PHILLIPS, independent, USA SORAWEE PORNCHAROENWASE, University of Washington, USA JENS AXEL S√òGAARD, independent, Denmark SAM TOBIN-HOCHSTADT, Indiana University, USA Rhombus is a new language that is built on Racket. It oÔ¨Äers the same kind of language extensibility as Racket itself, but using conventional (inÔ¨Åx) notation. Although Rhombus is far from the Ô¨Årst language to support Lisp-style macros without Lisp-style parentheses, Rhombus oÔ¨Äers a novel synthesis of macro technology that is practical and expressive. A key element is the use of multiple binding spaces for context-speciÔ¨Åc sublanguages. For example, expressions and pattern-matching forms can use the same operators with diÔ¨Äerent meanings and without creating conÔ¨Çicts. Context-sensitive bindings, in turn, facilitate a language design that reduces the notational distance between the core language and macro facilities. For example, repetitions can be deÔ¨Åned and used in binding and expression contexts generally, which enables a smoother transition from programming to metaprogramming. Finally, since handling static information (such as types) is also a necessary part of growing macros beyond Lisp, Rhombus includes support in its expansion protocol for communicating static information among bindings and expressions. The Rhombus implementation demonstrates that all of these pieces can work together in a coherent and user-friendly language. CCS Concepts: ‚Ä¢ Software and its engineering ‚Üí Extensible languages.},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-05-24},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Flatt, Matthew and Allred, Taylor and Angle, Nia and De Gabrielle, Stephen and Findler, Robert Bruce and Firth, Jack and Gopinathan, Kiran and Greenman, Ben and Kasivajhula, Siddhartha and Knauth, Alex and McCarthy, Jay and Phillips, Sam and Porncharoenwase, Sorawee and S√∏gaard, Jens Axel and Tobin-Hochstadt, Sam},
	month = oct,
	year = {2023},
	pages = {574--603},
	file = {Flatt et al. - 2023 - Rhombus A New Spin on Macros without All the Pare.pdf:/home/tim/Zotero/storage/L2VPQALN/Flatt et al. - 2023 - Rhombus A New Spin on Macros without All the Pare.pdf:application/pdf},
}

@article{levy_modelling_2003,
	title = {Modelling environments in call-by-value programming languages},
	volume = {185},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {08905401},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0890540103000889},
	doi = {10.1016/S0890-5401(03)00088-9},
	abstract = {In categorical semantics, there have traditionally been two approaches to modelling environments, one by use of Ô¨Ånite products in cartesian closed categories, the other by use of the base categories of indexed categories with structure. Each requires modiÔ¨Åcations in order to account for environments in call-by-value programming languages. There have been two more general deÔ¨Ånitions along both of these lines: the Ô¨Årst generalising from cartesian to symmetric premonoidal categories, the second generalising from indexed categories with speciÔ¨Åed structure to Œ∫-categories. In this paper, we investigate environments in call-by-value languages by analysing a Ô¨Ånegrain variant of Moggi‚Äôs computational Œª-calculus, giving two equivalent sound and complete classes of models: one given by closed Freyd categories, which are based on symmetric premonoidal categories, the other given by closed Œ∫-categories.},
	language = {en},
	number = {2},
	urldate = {2024-06-07},
	journal = {Information and Computation},
	author = {Levy, PaulBlain and Power, John and Thielecke, Hayo},
	month = sep,
	year = {2003},
	pages = {182--210},
	file = {Levy et al. - 2003 - Modelling environments in call-by-value programmin.pdf:/home/tim/Zotero/storage/34KGW785/Levy et al. - 2003 - Modelling environments in call-by-value programmin.pdf:application/pdf},
}

@article{biernacki_static_2006,
	title = {On the static and dynamic extents of delimited continuations},
	volume = {60},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167642306000177},
	doi = {10.1016/j.scico.2006.01.002},
	abstract = {We show that breadth-Ô¨Årst traversal exploits the difference between the static delimited-control operator shift (alias S) and the dynamic delimited-control operator control (alias F). For the last 15 years, this difference has been repeatedly mentioned in the literature but it has only been illustrated with one-line toy examples. Breadth-Ô¨Årst traversal Ô¨Ålls this vacuum.},
	language = {en},
	number = {3},
	urldate = {2024-06-10},
	journal = {Science of Computer Programming},
	author = {Biernacki, Dariusz and Danvy, Olivier and Shan, Chung-chieh},
	month = may,
	year = {2006},
	keywords = {delimited control, abstract machines},
	pages = {274--297},
	file = {Biernacki et al. - 2006 - On the static and dynamic extents of delimited con.pdf:/home/tim/Zotero/storage/R45UB886/Biernacki et al. - 2006 - On the static and dynamic extents of delimited con.pdf:application/pdf},
}

@misc{ghiasi-shirazi_revisiting_2022,
	title = {Revisiting 2-3 {Red}-{Black} {Trees} with a {Pedagogically} {Sound} yet {Efficient} {Deletion} {Algorithm}: {The} {Parity}-{Seeking} {Delete} {Algorithm}},
	shorttitle = {Revisiting 2-3 {Red}-{Black} {Trees} with a {Pedagogically} {Sound} yet {Efficient} {Deletion} {Algorithm}},
	url = {http://arxiv.org/abs/2004.04344},
	abstract = {Red-black (RB) trees are one of the most eÔ¨Écient variants of balanced binary search trees. However, they have always been blamed for being too complicated, hard to explain, and not suitable for pedagogical purposes. In the pioneering work of Guibas \& Sedgewick (1978), both 2-3 and 2-3-4 variants of RB trees had been considered, but further study of the former had been abandoned due to the higher number of rotations in the insert algorithm. Sedgewick (2008) proposed a variant of 2-3 RB trees, viz. left-leaning red-black (LLRB) trees, in which red links are restricted to left children and proposed concise recursive insert and delete algorithms. However, the top-down deletion algorithm of LLRB is still very complicated and highly ineÔ¨Écient. In this paper, we reconsider 2-3 red-black trees in which both children of a node cannot be red. We propose a parity-seeking delete algorithm with the basic idea of making the deÔ¨Åcient subtree on a par with its sibling: either by Ô¨Åxing the deÔ¨Åcient subtree or by turning the sibling deÔ¨Åcient as well, ascending deÔ¨Åciency to the parent node. Interestingly, the proposed parity-seeking delete algorithm works for 2-3-4 RB trees as well. Our experiments show that 2-3 RB trees are almost as eÔ¨Écient as RB trees and twice faster than LLRB trees. Besides, RB trees with the proposed parity-seeking delete algorithm have the same number of rotations and almost identical running time as the classical delete algorithm. While being extremely eÔ¨Écient, the proposed parity-seeking delete algorithm is easily understandable and suitable for pedagogical purposes.},
	language = {en},
	urldate = {2024-06-18},
	publisher = {arXiv},
	author = {Ghiasi-Shirazi, Kamaledin and Ghandi, Taraneh and Taghizadeh, Ali and Rahimi-Baigi, Ali},
	month = jun,
	year = {2022},
	note = {arXiv:2004.04344 [cs]},
	keywords = {Computer Science - Data Structures and Algorithms},
	file = {Ghiasi-Shirazi et al. - 2022 - Revisiting 2-3 Red-Black Trees with a Pedagogicall.pdf:/home/tim/Zotero/storage/76NKBJ2N/Ghiasi-Shirazi et al. - 2022 - Revisiting 2-3 Red-Black Trees with a Pedagogicall.pdf:application/pdf},
}

@inproceedings{xhakaj_new_2015,
	address = {Vilnius Lithuania},
	title = {A {New} {Approach} {To} {Teaching} {Red} {Black} {Tree}},
	isbn = {978-1-4503-3440-2},
	url = {https://dl.acm.org/doi/10.1145/2729094.2742624},
	doi = {10.1145/2729094.2742624},
	abstract = {Red black trees are considered an important data structure and students can Ô¨Ånd it to be challenging and diÔ¨Écult to learn. Many approaches to teaching red black trees have been tried but not very successfully. This paper describes our new approach, the granularity approach, to teaching the top-down insertion algorithm for red black trees. Past approaches have focused on teaching the mechanics of applying the rules (color Ô¨Çip, single rotation and double rotation). The new approach is based on the hypothesis that students have more diÔ¨Éculty selecting the correct rule than in applying a selected rule. Our approach focuses on helping students learn how to correctly select the rules to be applied We supplement classroom lectures with an intelligent tutoring system that incorporates our approach. The approach and the tutoring system were used and evaluated in a small data structures class in the fall semester of 2014. The early results indicate that our approach and tutoring system are eÔ¨Äective at helping students learn the top-down insertion algorithm.},
	language = {en},
	urldate = {2024-06-16},
	booktitle = {Proceedings of the 2015 {ACM} {Conference} on {Innovation} and {Technology} in {Computer} {Science} {Education}},
	publisher = {ACM},
	author = {Xhakaj, Franceska and Liew, Chun W.},
	month = jun,
	year = {2015},
	keywords = {extra-to-read},
	pages = {278--283},
	file = {Xhakaj and Liew - 2015 - A New Approach To Teaching Red Black Tree.pdf:/home/tim/Zotero/storage/9CUYFJTJ/Xhakaj and Liew - 2015 - A New Approach To Teaching Red Black Tree.pdf:application/pdf},
}

@article{chaudhuri_subcubic_nodate,
	title = {Subcubic {Algorithms} for {Recursive} {State} {Machines}},
	abstract = {We show that the reachability problem for recursive state machines (or equivalently, pushdown systems), believed for long to have cubic worst-case complexity, can be solved in slightly subcubic time. All that is necessary for the new bound is a simple adaptation of a known technique. We also show that a better algorithm exists if the input machine does not have inÔ¨Ånite recursive loops.},
	language = {en},
	author = {Chaudhuri, Swarat},
	file = {Chaudhuri - Subcubic Algorithms for Recursive State Machines.pdf:/home/tim/Zotero/storage/I3KCHY9Z/Chaudhuri - Subcubic Algorithms for Recursive State Machines.pdf:application/pdf},
}

@misc{germane_galois_nodate,
	title = {Galois {Connections} and {ADI}},
	abstract = {Galois},
	author = {Germane, Kimball},
	keywords = {extra-to-read},
	file = {paper.pdf:/home/tim/Zotero/storage/3YWQ9MQG/paper.pdf:application/pdf},
}

@incollection{muller_liberate_2020,
	address = {Cham},
	title = {Liberate {Abstract} {Garbage} {Collection} from the {Stack} by {Decomposing} the {Heap}},
	volume = {12075},
	isbn = {978-3-030-44913-1 978-3-030-44914-8},
	url = {https://link.springer.com/10.1007/978-3-030-44914-8_8},
	abstract = {Abstract garbage collection and the use of pushdown systems each enhance the precision of control-Ô¨Çow analysis (CFA). However, their respective needs conÔ¨Çict: abstract garbage collection requires the stack but pushdown systems obscure it. Though several existing techniques address this conÔ¨Çict, none take full advantage of the underlying interplay. In this paper, we dissolve this conÔ¨Çict with a technique which exploits the precision of pushdown systems to decompose the heap across the continuation. This technique liberates abstract garbage collection from the stack, increasing its eÔ¨Äectiveness and the compositionality of its host analysis. We generalize our approach to apply compositional treatment to abstract timestamps which induces the context abstraction of m-CFA, an abstraction more precise than k-CFA‚Äôs for many common programming patterns.},
	language = {en},
	urldate = {2024-06-21},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Germane, Kimball and Adams, Michael D.},
	editor = {M√ºller, Peter},
	year = {2020},
	doi = {10.1007/978-3-030-44914-8_8},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {extra-to-read},
	pages = {197--223},
	file = {Germane and Adams - 2020 - Liberate Abstract Garbage Collection from the Stac.pdf:/home/tim/Zotero/storage/GW4373VS/Germane and Adams - 2020 - Liberate Abstract Garbage Collection from the Stac.pdf:application/pdf},
}

@article{dillig_precise_nodate,
	title = {Precise and compact modular procedure summaries for heap manipulating programs},
	abstract = {We present a strictly bottom-up, summary-based, and precise heap analysis targeted for program veriÔ¨Åcation that performs strong updates to heap locations at call sites. We Ô¨Årst present a theory of heap decompositions that forms the basis of our approach; we then describe a full analysis algorithm that is fully symbolic and efÔ¨Åcient. We demonstrate the precision and scalability of our approach for veriÔ¨Åcation of real C and C++ programs.},
	language = {en},
	author = {Dillig, Isil and Dillig, Thomas and Aiken, Alex and Sagiv, Mooly},
	file = {Dillig et al. - Precise and compact modular procedure summaries fo.pdf:/home/tim/Zotero/storage/X4HP76CT/Dillig et al. - Precise and compact modular procedure summaries fo.pdf:application/pdf},
}

@incollection{germane_m-cfa_2023,
	address = {Singapore},
	title = {m-{CFA} {Exhibits} {Perfect} {Stack} {Precision}},
	volume = {14405},
	isbn = {978-981-9983-10-0 978-981-9983-11-7},
	url = {https://link.springer.com/10.1007/978-981-99-8311-7_14},
	language = {en},
	urldate = {2024-06-21},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Nature Singapore},
	author = {Germane, Kimball},
	editor = {Hur, Chung-Kil},
	year = {2023},
	doi = {10.1007/978-981-99-8311-7_14},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {290--309},
	file = {Germane - 2023 - m-CFA Exhibits Perfect Stack Precision.pdf:/home/tim/Zotero/storage/Q7Y5EWBN/Germane - 2023 - m-CFA Exhibits Perfect Stack Precision.pdf:application/pdf},
}

@article{vardoulakis_pushdown_nodate,
	title = {Pushdown flow analysis of first-class control},
	abstract = {Pushdown models are better than control-Ô¨Çow graphs for higherorder Ô¨Çow analysis. They faithfully model the call/return structure of a program, which results in fewer spurious Ô¨Çows and increased precision. However, pushdown models require that calls and returns in the analyzed program nest properly. As a result, they cannot be used to analyze language constructs that break call/return nesting such as generators, coroutines, call/cc, etc.},
	language = {en},
	author = {Vardoulakis, Dimitrios and Shivers, Olin},
	keywords = {extra-to-read},
	file = {Vardoulakis and Shivers - Pushdown flow analysis of first-class control.pdf:/home/tim/Zotero/storage/QPKBN34Z/Vardoulakis and Shivers - Pushdown flow analysis of first-class control.pdf:application/pdf},
}

@article{biernacki_dynamic_nodate,
	title = {On the {Dynamic} {Extent} of {Delimited} {Continuations}},
	abstract = {We show that breadth-Ô¨Årst traversal exploits the diÔ¨Äerence between the static delimited-control operator shift (alias S) and the dynamic delimited-control operator control (alias F). For the last 15 years, this diÔ¨Äerence has been repeatedly mentioned in the literature but it has only been illustrated with one-line toy examples. Breadth-Ô¨Årst traversal Ô¨Ålls this vacuum.},
	language = {en},
	author = {Biernacki, Dariusz and Danvy, Olivier},
	file = {Biernacki and Danvy - On the Dynamic Extent of Delimited Continuations.pdf:/home/tim/Zotero/storage/W4HB5VGX/Biernacki and Danvy - On the Dynamic Extent of Delimited Continuations.pdf:application/pdf},
}

@incollection{kokinov_delimited_2007,
	address = {Berlin, Heidelberg},
	title = {Delimited {Continuations} in {Operating} {Systems}},
	volume = {4635},
	isbn = {978-3-540-74254-8},
	url = {http://link.springer.com/10.1007/978-3-540-74255-5_22},
	abstract = {Delimited continuations are the meanings of delimited evaluation contexts in programming languages. We show they oÔ¨Äer a uniform view of many scenarios that arise in systems programming, such as a request for a system service, an event handler for input/output, a snapshot of a process, a Ô¨Åle system being read and updated, and a Web page. Explicitly recognizing these uses of delimited continuations helps us design a system of concurrent, isolated transactions where desirable features such as snapshots, undo, copy-on-write, reconciliation, and interposition fall out by default. It also lets us take advantage of eÔ¨Écient implementation techniques from programming-language research. The Zipper File System prototypes these ideas.},
	language = {en},
	urldate = {2024-06-27},
	booktitle = {Modeling and {Using} {Context}},
	publisher = {Springer Berlin Heidelberg},
	author = {Kiselyov, Oleg and Shan, Chung-chieh},
	editor = {Kokinov, Boicho and Richardson, Daniel C. and Roth-Berghofer, Thomas R. and Vieu, Laure},
	year = {2007},
	doi = {10.1007/978-3-540-74255-5_22},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {291--302},
	file = {Kiselyov and Shan - 2007 - Delimited Continuations in Operating Systems.pdf:/home/tim/Zotero/storage/N8NLP583/Kiselyov and Shan - 2007 - Delimited Continuations in Operating Systems.pdf:application/pdf},
}

@article{queinnec_continuations_2004,
	title = {Continuations and {Web} {Servers}},
	volume = {17},
	issn = {1388-3690, 1573-0557},
	url = {http://link.springer.com/10.1007/s10990-004-4866-z},
	doi = {10.1007/s10990-004-4866-z},
	abstract = {Programming web applications in direct style with the help of continuations is a much simpler, safer, modular and better-performing technology than the current dominating ‚Äúpage-centric‚Äù technology combining CGI scripts, active pages or servlets. This paper discusses the use of continuations in the context of web applications, the problems they solve as well as some new problems they introduce.},
	language = {en},
	number = {4},
	urldate = {2024-06-27},
	journal = {Higher-Order and Symbolic Computation},
	author = {Queinnec, Christian},
	month = dec,
	year = {2004},
	pages = {277--295},
	file = {Queinnec - 2004 - Continuations and Web Servers.pdf:/home/tim/Zotero/storage/5PH43WYN/Queinnec - 2004 - Continuations and Web Servers.pdf:application/pdf},
}

@inproceedings{filinski_representing_1994,
	address = {Portland, Oregon, United States},
	title = {Representing monads},
	isbn = {978-0-89791-636-3},
	url = {http://portal.acm.org/citation.cfm?doid=174675.178047},
	doi = {10.1145/174675.178047},
	language = {en},
	urldate = {2024-06-27},
	booktitle = {Proceedings of the 21st {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '94},
	publisher = {ACM Press},
	author = {Filinski, Andrzej},
	year = {1994},
	pages = {446--457},
	file = {Filinski - 1994 - Representing monads.pdf:/home/tim/Zotero/storage/G8JGJ6S5/Filinski - 1994 - Representing monads.pdf:application/pdf},
}

@article{earl_introspective_nodate,
	title = {Introspective pushdown analysis of higher-order programs},
	abstract = {In the static analysis of functional programs, pushdown Ô¨Çow analysis and abstract garbage collection skirt just inside the boundaries of soundness and decidability. Alone, each method reduces analysis times and boosts precision by orders of magnitude. This work illuminates and conquers the theoretical challenges that stand in the way of combining the power of these techniques. The challenge in marrying these techniques is not subtle: computing the reachable control states of a pushdown system relies on limiting access during transition to the top of the stack; abstract garbage collection, on the other hand, needs full access to the entire stack to compute a root set, just as concrete collection does. Introspective pushdown systems resolve this conÔ¨Çict. Introspective pushdown systems provide enough access to the stack to allow abstract garbage collection, but they remain restricted enough to compute control-state reachability, thereby enabling the sound and precise product of pushdown analysis and abstract garbage collection. Experiments reveal synergistic interplay between the techniques, and the fusion demonstrates ‚Äúbetter-than-both-worlds‚Äù precision.},
	language = {en},
	author = {Earl, Christopher and Sergey, Ilya and Might, Matthew and Horn, David Van},
	file = {Earl et al. - Introspective pushdown analysis of higher-order pr.pdf:/home/tim/Zotero/storage/F9D52CCJ/Earl et al. - Introspective pushdown analysis of higher-order pr.pdf:application/pdf},
}

@misc{earl_pushdown_2010,
	title = {Pushdown {Control}-{Flow} {Analysis} of {Higher}-{Order} {Programs}},
	url = {http://arxiv.org/abs/1007.4268},
	abstract = {Context-free approaches to static analysis gain precision over classical approaches by perfectly matching returns to call sites‚Äîa property that eliminates spurious interprocedural paths. Vardoulakis and Shivers‚Äôs recent formulation of CFA2 showed that it is possible (if expensive) to apply context-free methods to higherorder languages and gain the same boost in precision achieved over Ô¨Årst-order programs.},
	language = {en},
	urldate = {2024-06-27},
	publisher = {arXiv},
	author = {Earl, Christopher and Might, Matthew and Van Horn, David},
	month = jul,
	year = {2010},
	note = {arXiv:1007.4268 [cs]},
	keywords = {Computer Science - Programming Languages, F.3.2, F.4.1},
	file = {Earl et al. - 2010 - Pushdown Control-Flow Analysis of Higher-Order Pro.pdf:/home/tim/Zotero/storage/48FT9U9J/Earl et al. - 2010 - Pushdown Control-Flow Analysis of Higher-Order Pro.pdf:application/pdf},
}

@inproceedings{parkinson_reference_2024,
	address = {Copenhagen Denmark},
	title = {Reference {Counting} {Deeply} {Immutable} {Data} {Structures} with {Cycles}: {An} {Intellectual} {Abstract}},
	isbn = {9798400706158},
	shorttitle = {Reference {Counting} {Deeply} {Immutable} {Data} {Structures} with {Cycles}},
	url = {https://dl.acm.org/doi/10.1145/3652024.3665507},
	doi = {10.1145/3652024.3665507},
	abstract = {Immutable data structures are a powerful tool for building concurrent programs. They allow the sharing of data without the need for locks or other synchronisation mechanisms. This makes it much easier to reason about the correctness of the program. In this paper, we focus on what we call deep immutability from freeze, that is, objects are initially mutable, and then can be frozen, and from that point on the object and everything it refers to (transitively) can no longer be mutated. A key challenge with this form of immutability is ‚Äúhow to manage the memory of cyclic data structures?‚Äù The standard approach is to use a garbage collector (GC), or a back-up cycle detector. These approaches sacri ce the promptness of memory reclamation, and the determinism of memory usage.},
	language = {en},
	urldate = {2024-06-30},
	booktitle = {Proceedings of the 2024 {ACM} {SIGPLAN} {International} {Symposium} on {Memory} {Management}},
	publisher = {ACM},
	author = {Parkinson, Matthew J. and Clebsch, Sylvan and Wrigstad, Tobias},
	month = jun,
	year = {2024},
	pages = {131--141},
	file = {Parkinson et al. - 2024 - Reference Counting Deeply Immutable Data Structure.pdf:/home/tim/Zotero/storage/XS64JJSP/Parkinson et al. - 2024 - Reference Counting Deeply Immutable Data Structure.pdf:application/pdf},
}

@article{lesbre_compiling_2024,
	title = {Compiling with {Abstract} {Interpretation}},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3656392},
	doi = {10.1145/3656392},
	abstract = {DORIAN LESBRE, Universit√© Paris-Saclay, CEA, List, France MATTHIEU LEMERRE, Universit√© Paris-Saclay, CEA, List, France Rewriting and static analyses are mutually beneÔ¨Åcial techniques: program transformations change the intensional aspects of the program, and can thus improve analysis precision, while some eÔ¨Écient transformations are enabled by speciÔ¨Åc knowledge of some program invariants. Despite the strong interaction between these techniques, they are usually considered distinct. In this paper, we demonstrate that we can turn abstract interpreters into compilers, using a simple free algebra over the standard signature of abstract domains. Functor domains correspond to compiler passes, for which soundness is translated to a proof of forward simulation, and completeness to backward simulation. We achieve translation to SSA using an abstract domain with a non-standard SSA signature. Incorporating such an SSA translation to an abstract interpreter improves its precision; in particular we show that an SSA-based non-relational domain is always more precise than a standard non-relational domain for similar time and memory complexity. Moreover, such a domain allows recovering from precision losses that occur when analyzing low-level machine code instead of source code. These results help implement analyses or compilation passes where symbolic and semantic methods simultaneously reÔ¨Åne each other, and improves precision when compared to doing the passes in sequence. CCS Concepts: ‚Ä¢ Software and its engineering ‚Üí Compilers; Formal software veriÔ¨Åcation; ‚Ä¢ Theory of computation ‚Üí Program analysis; Program veriÔ¨Åcation; Abstraction; Equational logic and rewriting.},
	language = {en},
	number = {PLDI},
	urldate = {2024-06-30},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Lesbre, Dorian and Lemerre, Matthieu},
	month = jun,
	year = {2024},
	pages = {368--393},
	file = {Lesbre and Lemerre - 2024 - Compiling with Abstract Interpretation.pdf:/home/tim/Zotero/storage/WLSXFQVZ/Lesbre and Lemerre - 2024 - Compiling with Abstract Interpretation.pdf:application/pdf},
}

@article{lutze_associated_2024,
	title = {Associated {Effects}: {Flexible} {Abstractions} for {Effectful} {Programming}},
	volume = {8},
	issn = {2475-1421},
	shorttitle = {Associated {Effects}},
	url = {https://dl.acm.org/doi/10.1145/3656393},
	doi = {10.1145/3656393},
	abstract = {We present associated effects, a programming language feature that enables type 
classes to abstract over the effects of their function signatures, allowing each 
type class instance to specify its concrete effects.
            Associated effects significantly increase the flexibility and expressive power 
of a programming language that combines a type and effect system with type 
classes. In particular, associated effects allow us to 
(i) abstract over total and partial functions, where partial functions may throw exceptions, 
(ii) abstract over immutable data structures and mutable data structures that have heap effects, and 
(iii) implement adaptors that combine type classes with algebraic effects.
            We implement associated effects as an extension of the Flix programming language 
and refactor the Flix Standard Library to use associated effects, significantly 
increasing its flexibility and expressive power. Specifically, we add associated 
effects to 11 type classes, which enables us to add 
28 new type class instances.},
	language = {en},
	number = {PLDI},
	urldate = {2024-06-30},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Lutze, Matthew and Madsen, Magnus},
	month = jun,
	year = {2024},
	pages = {394--416},
	file = {Lutze and Madsen - 2024 - Associated Effects Flexible Abstractions for Effe.pdf:/home/tim/Zotero/storage/IR2AR7PA/Lutze and Madsen - 2024 - Associated Effects Flexible Abstractions for Effe.pdf:application/pdf},
}

@article{jia_v-star_2024,
	title = {V-{Star}: {Learning} {Visibly} {Pushdown} {Grammars} from {Program} {Inputs}},
	volume = {8},
	issn = {2475-1421},
	shorttitle = {V-{Star}},
	url = {https://dl.acm.org/doi/10.1145/3656458},
	doi = {10.1145/3656458},
	abstract = {Accurate description of program inputs remains a critical challenge in the field of programming languages. Active learning, as a well-established field, achieves exact learning for regular languages. We offer an innovative grammar inference tool, V-Star, based on the active learning of visibly pushdown automata. V-Star deduces nesting structures of program input languages from sample inputs, employing a novel inference mechanism based on nested patterns. This mechanism identifies token boundaries and converts languages such as XML documents into VPLs. We then adapted Angluin's L-Star, an exact learning algorithm, for VPA learning, which improves the precision of our tool. Our evaluation demonstrates that V-Star effectively and efficiently learns a variety of practical grammars, including S-Expressions, JSON, and XML, and outperforms other state-of-the-art tools.},
	language = {en},
	number = {PLDI},
	urldate = {2024-06-30},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Jia, Xiaodong and Tan, Gang},
	month = jun,
	year = {2024},
	pages = {2003--2026},
	file = {Jia and Tan - 2024 - V-Star Learning Visibly Pushdown Grammars from Pr.pdf:/home/tim/Zotero/storage/62RQTDXQ/Jia and Tan - 2024 - V-Star Learning Visibly Pushdown Grammars from Pr.pdf:application/pdf},
}

@article{hong_recursive_2024,
	title = {Recursive {Program} {Synthesis} using {Paramorphisms}},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3656381},
	doi = {10.1145/3656381},
	abstract = {QIANTAN HONG, Stanford University, USA ALEX AIKEN, Stanford University, USA We show that synthesizing recursive functional programs using a class of primitive recursive combinators is both simpler and solves more benchmarks from the literature than previously proposed approaches. Our method synthesizes paramorphisms, a class of programs that includes the most common recursive programming patterns on algebraic data types. The crux of our approach is to split the synthesis problem into two parts: a multi-hole template that xes the recursive structure, and a search for non-recursive program fragments to ll the template holes. CCS Concepts: ‚Ä¢ Software and its engineering ‚Üí General programming languages; Programming by example; Search-based software engineering; Automatic programming.},
	language = {en},
	number = {PLDI},
	urldate = {2024-06-30},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Hong, Qiantan and Aiken, Alex},
	month = jun,
	year = {2024},
	pages = {102--125},
	file = {Hong and Aiken - 2024 - Recursive Program Synthesis using Paramorphisms.pdf:/home/tim/Zotero/storage/46SRX7F6/Hong and Aiken - 2024 - Recursive Program Synthesis using Paramorphisms.pdf:application/pdf},
}

@article{stein_interactive_2024,
	title = {Interactive {Abstract} {Interpretation} with {Demanded} {Summarization}},
	volume = {46},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/3648441},
	doi = {10.1145/3648441},
	abstract = {We consider the problem of making expressive, interactive static analyzers
              compositional
              . Such a technique could help bring the power of server-based static analyses to integrated development environments (IDEs), updating their results live as the code is modified. Compositionality is key for this scenario, as it enables reuse of already-computed analysis results for unmodified code. Previous techniques for interactive static analysis either lack compositionality, cannot express arbitrary abstract domains, or are not from-scratch consistent.
            
            We present demanded summarization, the first algorithm for incremental compositional analysis in arbitrary abstract domains that guarantees from-scratch consistency. Our approach analyzes individual procedures using a recent technique for demanded analysis, computing summaries on demand for procedure calls. A dynamically updated summary dependency graph enables precise result invalidation after program edits, and the algorithm is carefully designed to guarantee from-scratch-consistent results after edits, even in the presence of recursion and in arbitrary abstract domains. We formalize our technique and prove soundness, termination, and from-scratch consistency. An experimental evaluation of a prototype implementation on synthetic and real-world program edits provides evidence for the feasibility of this theoretical framework, showing potential for major performance benefits over non-demanded compositional analyses.},
	language = {en},
	number = {1},
	urldate = {2024-06-30},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Stein, Benno and Chang, Bor-Yuh Evan and Sridharan, Manu},
	month = mar,
	year = {2024},
	pages = {1--40},
	file = {Stein et al. - 2024 - Interactive Abstract Interpretation with Demanded .pdf:/home/tim/Zotero/storage/RCKQURIG/Stein et al. - 2024 - Interactive Abstract Interpretation with Demanded .pdf:application/pdf},
}

@article{rivera_floating-point_2024,
	title = {Floating-{Point} {TVPI} {Abstract} {Domain}},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3656395},
	doi = {10.1145/3656395},
	abstract = {JOAO RIVERA, ETH Zurich, Switzerland FRANZ FRANCHETTI, Carnegie Mellon University, USA MARKUS P√úSCHEL, ETH Zurich, Switzerland Floating-point arithmetic is natively supported in hardware and the preferred choice when implementing numerical software in scientiÔ¨Åc or engineering applications. However, such programs are notoriously hard to analyze due to round-oÔ¨Ä errors and the frequent use of elementary functions such as log, arctan, or sqrt. In this work, we present the Two Variables per Inequality Floating-Point (TVPI-FP) domain, a numerical and constraint-based abstract domain designed for the analysis of Ô¨Çoating-point programs. TVPI-FP supports all features of real-world Ô¨Çoating-point programs including conditional branches, loops, and elementary functions and it is eÔ¨Écient asymptotically and in practice. Thus it overcomes limitations of prior tools that often are restricted to straight-line programs or require the use of expensive solvers. The key idea is the consistent use of interval arithmetic in inequalities and an associated redesign of all operators. Our extensive experiments show that TVPI-FP is often orders of magnitudes faster than more expressive tools at competitive, or better precision while also providing broader support for realistic programs with loops and conditionals. CCS Concepts: ‚Ä¢ Software and its engineering ‚Üí Automated static analysis.},
	language = {en},
	number = {PLDI},
	urldate = {2024-06-30},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Rivera, Joao and Franchetti, Franz and P√ºschel, Markus},
	month = jun,
	year = {2024},
	pages = {442--466},
	file = {Rivera et al. - 2024 - Floating-Point TVPI Abstract Domain.pdf:/home/tim/Zotero/storage/4KPEX59G/Rivera et al. - 2024 - Floating-Point TVPI Abstract Domain.pdf:application/pdf},
}

@article{laursen_reducing_2024,
	title = {Reducing {Static} {Analysis} {Unsoundness} with {Approximate} {Interpretation}},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3656424},
	doi = {10.1145/3656424},
	abstract = {MATHIAS RUD LAURSEN, Aarhus University, Denmark WENYUAN XU, Aarhus University, Denmark ANDERS M√òLLER, Aarhus University, Denmark Static program analysis for JavaScript is more diÔ¨Écult than for many other programming languages. One of the main reasons is the presence of dynamic property accesses that read and write object properties via dynamically computed property names. To ensure scalability and precision, existing state-of-the-art analyses for JavaScript mostly ignore these operations although it results in missed call edges and aliasing relations. We present a novel dynamic analysis technique named approximate interpretation that is designed to eÔ¨Éciently and fully automatically infer likely determinate facts about dynamic property accesses, in particular those that occur in complex library API initialization code, and how to use the produced information in static analysis to recover much of the abstract information that is otherwise missed. Our implementation of the technique and experiments on 141 real-world Node.js-based JavaScript applications and libraries show that the approach leads to signiÔ¨Åcant improvements in call graph construction. On average the use of approximate interpretation leads to 55.1\% more call edges, 21.8\% more reachable functions, 17.7\% more resolved call sites, and only 1.5\% fewer monomorphic call sites. For 36 JavaScript projects where dynamic call graphs are available, average analysis recall is improved from 75.9\% to 88.1\% with a negligible reduction in precision. CCS Concepts: ‚Ä¢ Theory of computation ‚Üí Program analysis.},
	language = {en},
	number = {PLDI},
	urldate = {2024-06-30},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Laursen, Mathias Rud and Xu, Wenyuan and M√∏ller, Anders},
	month = jun,
	year = {2024},
	pages = {1165--1188},
	file = {Laursen et al. - 2024 - Reducing Static Analysis Unsoundness with Approxim.pdf:/home/tim/Zotero/storage/UIVLJVYF/Laursen et al. - 2024 - Reducing Static Analysis Unsoundness with Approxim.pdf:application/pdf},
}

@article{group_webassembly_nodate,
	title = {{WebAssembly} {Specification}},
	language = {en},
	author = {Group, WebAssembly Community and Rossberg, Andreas},
	file = {Group and Rossberg - WebAssembly Specification.pdf:/home/tim/Zotero/storage/B9QWU9J4/Group and Rossberg - WebAssembly Specification.pdf:application/pdf},
}

@article{rompf_lightweight_nodate,
	title = {Lightweight modular staging: a pragmatic approach to runtime code generation and compiled {DSLs}},
	abstract = {Software engineering demands generality and abstraction, performance demands specialization and concretization. Generative programming can provide both, but developing high-quality program generators takes a large effort, even if a multi-stage programming language is used.},
	language = {en},
	author = {Rompf, Tiark and Odersky, Martin},
	file = {Rompf and Odersky - Lightweight modular staging a pragmatic approach .pdf:/home/tim/Zotero/storage/EPC4VBY8/Rompf and Odersky - Lightweight modular staging a pragmatic approach .pdf:application/pdf},
}

@book{jhala_programming_2012,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Programming {Languages} and {Systems}: 10th {Asian} {Symposium}, {APLAS} 2012, {Kyoto}, {Japan}, {December} 11-13, 2012. {Proceedings}},
	volume = {7705},
	copyright = {http://www.springer.com/tdm},
	isbn = {978-3-642-35181-5 978-3-642-35182-2},
	shorttitle = {Programming {Languages} and {Systems}},
	url = {http://link.springer.com/10.1007/978-3-642-35182-2},
	language = {en},
	urldate = {2024-07-12},
	publisher = {Springer Berlin Heidelberg},
	editor = {Jhala, Ranjit and Igarashi, Atsushi and Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	year = {2012},
	doi = {10.1007/978-3-642-35182-2},
	file = {Jhala and Igarashi - 2012 - Programming Languages and Systems 10th Asian Symp.pdf:/home/tim/Zotero/storage/NMTVIHIE/Jhala and Igarashi - 2012 - Programming Languages and Systems 10th Asian Symp.pdf:application/pdf},
}

@incollection{hutchison_dynamic_2012,
	address = {Berlin, Heidelberg},
	title = {A {Dynamic} {Interpretation} of the {CPS} {Hierarchy}},
	volume = {7705},
	isbn = {978-3-642-35181-5 978-3-642-35182-2},
	url = {http://link.springer.com/10.1007/978-3-642-35182-2_21},
	abstract = {The CPS hierarchy of control operators shifti/reseti of Danvy and Filinski is a natural generalization of the shift and reset static control operators that allow for abstracting delimited control in a structured and CPS-guided manner. In this article we show that a dynamic variant of shift/reset, known as shift0/reset0, where the discipline of static access to the stack of delimited continuations is relaxed, can fully express the CPS hierarchy. This result demonstrates the expressive power of shift0/reset0 and it offers a new perspective on practical applications of the CPS hierarchy.},
	language = {en},
	urldate = {2024-07-12},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Materzok, Marek and Biernacki, Dariusz},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Jhala, Ranjit and Igarashi, Atsushi},
	year = {2012},
	doi = {10.1007/978-3-642-35182-2_21},
	note = {Series Title: Lecture Notes in Computer Science},
	keywords = {delimited control, abstract machines},
	pages = {296--311},
	file = {Materzok and Biernacki - 2012 - A Dynamic Interpretation of the CPS Hierarchy.pdf:/home/tim/Zotero/storage/6KCXWLDT/Materzok and Biernacki - 2012 - A Dynamic Interpretation of the CPS Hierarchy.pdf:application/pdf},
}

@article{shan_static_2007,
	title = {A static simulation of dynamic delimited control},
	volume = {20},
	copyright = {http://www.springer.com/tdm},
	issn = {1388-3690, 1573-0557},
	url = {http://link.springer.com/10.1007/s10990-007-9010-4},
	doi = {10.1007/s10990-007-9010-4},
	abstract = {We present a continuation-passing-style (CPS) transformation for some dynamic delimited-control operators, including Felleisen‚Äôs control and prompt, that extends a standard call-by-value CPS transformation. Based on this new transformation, we show how Danvy and Filinski‚Äôs static delimited-control operators shift and reset simulate dynamic operators, allaying in passing some skepticism in the literature about the existence of such a simulation. The new CPS transformation and simulation use recursive delimited continuations to avoid undelimited control and the overhead it incurs in implementation and reasoning.},
	language = {en},
	number = {4},
	urldate = {2024-07-12},
	journal = {Higher-Order and Symbolic Computation},
	author = {Shan, Chung-chieh},
	month = nov,
	year = {2007},
	keywords = {delimited control, abstract machines},
	pages = {371--401},
	file = {Shan - 2007 - A static simulation of dynamic delimited control.pdf:/home/tim/Zotero/storage/P6VHHGT5/Shan - 2007 - A static simulation of dynamic delimited control.pdf:application/pdf},
}

@article{biernacki_dynamic_2015,
	title = {A {Dynamic} {Continuation}-{Passing} {Style} for {Dynamic} {Delimited} {Continuations}},
	volume = {38},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/2794078},
	doi = {10.1145/2794078},
	abstract = {We put a preexisting definitional abstract machine for dynamic delimited continuations in defunctionalized form, and we present the consequences of this adjustment. We first prove the correctness of the adjusted abstract machine. Because it is in defunctionalized form, we can refunctionalize it into a higher-order evaluation function. This evaluation function, which is compositional, is in continuation+state-passing style and threads a trail of delimited continuations and a meta-continuation. Since this style accounts for dynamic delimited continuations, we refer to it as ‚Äúdynamic continuation-passing style‚Äù and we present the corresponding dynamic CPS transformation. We show that the notion of computation induced by dynamic CPS takes the form of a continuation monad with a recursive answer type. This continuation monad suggests a new simulation of dynamic delimited continuations in terms of static ones. Finally, we present new applications of dynamic delimited continuations, including a meta-circular evaluator. The significance of the present work is that the computational artifacts surrounding dynamic CPS are not independent designs: they are mechanical consequences of having put the definitional abstract machine in defunctionalized form.},
	language = {en},
	number = {1},
	urldate = {2024-07-12},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Biernacki, Dariusz and Danvy, Olivier and Millikin, Kevin},
	month = oct,
	year = {2015},
	keywords = {delimited control, abstract machines},
	pages = {1--25},
	file = {Biernacki et al. - 2015 - A Dynamic Continuation-Passing Style for Dynamic D.pdf:/home/tim/Zotero/storage/DW4546UY/Biernacki et al. - 2015 - A Dynamic Continuation-Passing Style for Dynamic D.pdf:application/pdf},
}

@article{danvy_functional_nodate,
	title = {A {Functional} {Abstraction} of {Typed} {Contexts}},
	abstract = {This report investigates abstracting control with functions. This is achieved by deÔ¨Åning continuations as functions abstracting lexically a delimited context [C[ ]] rather than dynamically an unlimited one C[ ], as it is usually the case. Because their co-domain is distinguished from the Ô¨Ånal domain of Answers, such continuations can be composed, and this contrasts with the simple exceptions of ML and Lisp and the unlimited Ô¨Årst-class continuations of Scheme. Making these functional control abstractions Ô¨Årst-class oÔ¨Äers a new area in programming which this paper explores.},
	language = {en},
	author = {Danvy, Olivier and Filinski, Andrzej},
	keywords = {abstract machines},
	file = {Danvy and Filinski - A Functional Abstraction of Typed Contexts.pdf:/home/tim/Zotero/storage/T9IHRWWQ/Danvy and Filinski - A Functional Abstraction of Typed Contexts.pdf:application/pdf},
}

@misc{hutchison_pika_2020,
	title = {Pika parsing: reformulating packrat parsing as a dynamic programming algorithm solves the left recursion and error recovery problems},
	shorttitle = {Pika parsing},
	url = {http://arxiv.org/abs/2005.06444},
	abstract = {A recursive descent parser is built from a set of mutually-recursive functions, where each function directly implements one of the nonterminals of a grammar. A packrat parser uses memoization to reduce the time complexity for recursive descent parsing from exponential to linear in the length of the input. Recursive descent parsers are extremely simple to write, but suffer from two significant problems: (i) left-recursive grammars cause the parser to get stuck in infinite recursion, and (ii) it can be difficult or impossible to optimally recover the parse state and continue parsing after a syntax error. Both problems are solved by the pika parser, a novel reformulation of packrat parsing as a dynamic programming algorithm, which requires parsing the input in reverse: bottom-up and right to left, rather than top-down and left to right. This reversed parsing order enables pika parsers to handle grammars that use either direct or indirect left recursion to achieve left associativity, simplifying grammar writing, and also enables optimal recovery from syntax errors, which is a crucial property for IDEs and compilers. Pika parsing maintains the linear-time performance characteristics of packrat parsing as a function of input length. The pika parser was benchmarked against the widely-used Parboiled2 and ANTLR4 parsing libraries. The pika parser performed significantly better than the other parsers for an expression grammar, although for a complex grammar implementing the Java language specification, a large constant performance impact was incurred per input character. Therefore, if performance is important, pika parsing is best applied to simple to moderate-sized grammars, or to very large inputs, if other parsing alternatives do not scale linearly in the length of the input. Several new insights into precedence, associativity, and left recursion are presented.},
	language = {en},
	urldate = {2024-07-15},
	publisher = {arXiv},
	author = {Hutchison, Luke A. D.},
	month = jul,
	year = {2020},
	note = {arXiv:2005.06444 [cs]},
	keywords = {Computer Science - Programming Languages, D.3.4, F.4.2},
	file = {Hutchison - 2020 - Pika parsing reformulating packrat parsing as a d.pdf:/home/tim/Zotero/storage/2MT89SMG/Hutchison - 2020 - Pika parsing reformulating packrat parsing as a d.pdf:application/pdf},
}

@article{dyvbig_monadic_2007,
	title = {A monadic framework for delimited continuations},
	volume = {17},
	copyright = {https://www.cambridge.org/core/terms},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796807006259/type/journal_article},
	doi = {10.1017/S0956796807006259},
	abstract = {Delimited continuations are more expressive than traditional abortive continuations and they apparently require a framework beyond traditional continuation-passing style (CPS). We show that this is not the case: standard CPS is suÔ¨Écient to explain the common control operators for delimited continuations. We demonstrate this fact and present an implementation as a Scheme library. We then investigate a typed account of delimited continuations that makes explicit where control eÔ¨Äects can occur. This results in a monadic framework for typed and encapsulated delimited continuations which we design and implement as a Haskell library.},
	language = {en},
	number = {6},
	urldate = {2024-07-16},
	journal = {Journal of Functional Programming},
	author = {Dyvbig, R. Kent and Jones, Simon Peyton and Sabry, Amr},
	month = nov,
	year = {2007},
	keywords = {delimited control},
	pages = {687--730},
	file = {Dyvbig et al. - 2007 - A monadic framework for delimited continuations.pdf:/home/tim/Zotero/storage/JZDBUPD5/Dyvbig et al. - 2007 - A monadic framework for delimited continuations.pdf:application/pdf},
}

@misc{noauthor_cs_nodate,
	title = {{CS} 3520/6520: {Schedule} and {Homework}},
	url = {https://my.eng.utah.edu/~cs3520/schedule.html},
	urldate = {2024-07-17},
	file = {CS 3520/6520\: Schedule and Homework:/home/tim/Zotero/storage/QE8FTL6Y/schedule.html:text/html},
}

@article{leijen_parsec_nodate,
	title = {Parsec: {Direct} {Style} {Monadic} {Parser} {Combinators} {For} {The} {Real} {World}},
	abstract = {Despite the long list of publications on parser combinators, there does not yet exist a monadic parser combinator library that is applicable in real world situations. In particular naive implementations of parser combinators are likely to suÔ¨Äer from space leaks and are often unable to report precise error messages in case of parse errors. The Parsec parser combinator library described in this paper, utilizes a novel implementation technique for space and time eÔ¨Écient parser combinators that in case of a parse error, report both the position of the error as well as all grammar productions that would have been legal at that point in the input.},
	language = {en},
	author = {Leijen, Daan},
	file = {Leijen - Parsec Direct Style Monadic Parser Combinators Fo.pdf:/home/tim/Zotero/storage/CD4VHR5L/Leijen - Parsec Direct Style Monadic Parser Combinators Fo.pdf:application/pdf},
}

@article{hillerstrom_continuation_2017,
	title = {Continuation {Passing} {Style} for {Effect} {Handlers}},
	volume = {84},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	issn = {1868-8969},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2017.18},
	doi = {10.4230/LIPICS.FSCD.2017.18},
	abstract = {We present Continuation Passing Style (CPS) translations for Plotkin and Pretnar‚Äôs eÔ¨Äect handlers with Hillerstr√∂m and Lindley‚Äôs row-typed Ô¨Åne-grain call-by-value calculus of eÔ¨Äect handlers as the source language. CPS translations of handlers are interesting theoretically, to explain the semantics of handlers, and also oÔ¨Äer a practical implementation technique that does not require special support in the target language‚Äôs runtime.},
	language = {en},
	urldate = {2024-07-17},
	journal = {LIPIcs, Volume 84, FSCD 2017},
	author = {Hillerstr√∂m, Daniel and Lindley, Sam and Atkey, Robert and Sivaramakrishnan, K. C.},
	collaborator = {Miller, Dale},
	year = {2017},
	note = {Artwork Size: 19 pages, 774356 bytes
ISBN: 9783959770477
Medium: application/pdf
Publisher: Schloss Dagstuhl ‚Äì Leibniz-Zentrum f√ºr Informatik},
	keywords = {effect handlers, delimited control, extra-to-read, continuation passing style},
	pages = {18:1--18:19},
	file = {Hillerstr√∂m et al. - 2017 - Continuation Passing Style for Effect Handlers.pdf:/home/tim/Zotero/storage/2UGEUCZS/Hillerstr√∂m et al. - 2017 - Continuation Passing Style for Effect Handlers.pdf:application/pdf},
}

@article{kiselyov_eff_2018,
	title = {Eff {Directly} in {OCaml}},
	volume = {285},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1812.11664v1},
	doi = {10.4204/EPTCS.285.2},
	language = {en},
	urldate = {2024-07-17},
	journal = {Electronic Proceedings in Theoretical Computer Science},
	author = {Kiselyov, Oleg and Sivaramakrishnan, Kc},
	month = dec,
	year = {2018},
	keywords = {delimited control, extra-to-read},
	pages = {23--58},
	file = {Kiselyov and Sivaramakrishnan - 2018 - Eff Directly in OCaml.pdf:/home/tim/Zotero/storage/XMF2698G/Kiselyov and Sivaramakrishnan - 2018 - Eff Directly in OCaml.pdf:application/pdf},
}

@article{hieb_subcontinuations_1994,
	title = {Subcontinuations},
	volume = {7},
	copyright = {http://www.springer.com/tdm},
	issn = {0892-4635, 1573-0557},
	url = {http://link.springer.com/10.1007/BF01019946},
	doi = {10.1007/BF01019946},
	abstract = {Continuations have proven to be useful for implementing a variety of control structures, including exception handling facilities and breadth-Ô¨Årst searching algorithms. However, traditional continuations are not useful in the presence of concurrency, because the notion of the rest of the computation represented by a continuation does not in general make sense. Traditional continuations can also be diÔ¨Écult to use in nonconcurrent settings, since their global nature is sometimes problematic. This article presents a new type of continuation, called a subcontinuation. Just as a traditional continuation represents the rest of a computation from a given point in the computation, a subcontinuation represents the rest of a subcomputation from a given point in the subcomputation. Subcontinuations may be used to control tree-structured concurrency by allowing nonlocal exits to arbitrary points in a process tree and allowing the capture of a subtree of a computation as a composable continuation for later use. In the absence of concurrency the localized control achievable with subcontinuations makes them more useful than traditional continuations.},
	language = {en},
	number = {1},
	urldate = {2024-07-17},
	journal = {LISP and Symbolic Computation},
	author = {Hieb, Robert and Dybvig, R. Kent and Anderson, Claude W.},
	month = jan,
	year = {1994},
	keywords = {delimited control},
	pages = {83--109},
	file = {Hieb et al. - 1994 - Subcontinuations.pdf:/home/tim/Zotero/storage/CDTCK7FK/Hieb et al. - 1994 - Subcontinuations.pdf:application/pdf},
}

@article{ikemori_translation_nodate,
	title = {Translation {Between} {Effect} {Instances} and {Multi}-prompt {Control} {Operators}},
	language = {en},
	author = {Ikemori, Kazuki},
	file = {Ikemori - Translation Between Effect Instances and Multi-pro.pdf:/home/tim/Zotero/storage/A5YPYRXX/Ikemori - Translation Between Effect Instances and Multi-pro.pdf:application/pdf},
}

@article{bal_environmental_nodate,
	title = {{ENVIRONMENTAL} {BISIMULATIONS} {FOR} {DELIMITED}-{CONTROL} {OPERATORS} {WITH} {DYNAMIC} {PROMPT} {GENERATION}},
	abstract = {We present sound and complete environmental bisimilarities for a variant of Dybvig et al.‚Äôs calculus of multi-prompted delimited-control operators with dynamic prompt generation. The reasoning principles that we obtain generalize and advance the existing techniques for establishing program equivalence in calculi with single-prompted delimited control.},
	language = {en},
	author = {Bal, Andres Aristiza and Biernacki, Dariusz and Lenglet, Serguei and Polesiuk, Piotr},
	file = {Bal et al. - ENVIRONMENTAL BISIMULATIONS FOR DELIMITED-CONTROL .pdf:/home/tim/Zotero/storage/PGINLFSK/Bal et al. - ENVIRONMENTAL BISIMULATIONS FOR DELIMITED-CONTROL .pdf:application/pdf},
}

@inproceedings{gunter_generalization_1995,
	title = {A generalization of exceptions and control in {ML}-like languages},
	booktitle = {Proceedings of the seventh international conference on functional programming languages and computer architecture},
	author = {Gunter, Carl A and R√©my, Didier and Riecke, Jon G},
	year = {1995},
	pages = {12--23},
	file = {AGeneralizationOfExceptionsandControlinML.pdf:/home/tim/Zotero/storage/NSCP98D8/AGeneralizationOfExceptionsandControlinML.pdf:application/pdf},
}

@article{kiselyov_delimited_2012,
	title = {Delimited control in {OCaml}, abstractly and concretely},
	volume = {435},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0304397512001661},
	doi = {10.1016/j.tcs.2012.02.025},
	language = {en},
	urldate = {2024-07-22},
	journal = {Theoretical Computer Science},
	author = {Kiselyov, Oleg},
	month = jun,
	year = {2012},
	pages = {56--76},
	file = {Kiselyov - 2012 - Delimited control in OCaml, abstractly and concret.pdf:/home/tim/Zotero/storage/HJ7CIYTY/Kiselyov - 2012 - Delimited control in OCaml, abstractly and concret.pdf:application/pdf},
}

@article{wright_syntactic_1994,
	title = {A syntactic approach to type soundness},
	volume = {115},
	number = {1},
	journal = {Information and computation},
	author = {Wright, Andrew K and Felleisen, Matthias},
	year = {1994},
	note = {Publisher: Elsevier},
	pages = {38--94},
	file = {1-s2.0-S0890540184710935-main.pdf:/home/tim/Zotero/storage/GAAVNEHH/1-s2.0-S0890540184710935-main.pdf:application/pdf},
}

@misc{donham_jake_mixing_2010,
	title = {Mixing {Monadic} and {Direct}-{Style} {Code} with {Delimited} {Continuations}},
	url = {https://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html},
	urldate = {2024-07-23},
	journal = {Ambassador to the Computers},
	author = {Donham, Jake},
	month = aug,
	year = {2010},
}

@article{balat_extensional_nodate,
	title = {Extensional {Normalisation} and {Type}-{Directed} {Partial} {Evaluation} for {Typed} {Lambda} {Calculus} with {Sums}},
	abstract = {We present a notion of Œ∑-long Œ≤-normal term for the typed lambda calculus with sums and prove, using Grothendieck logical relations, that every term is equivalent to one in normal form. Based on this development we give the Ô¨Årst type-directed partial evaluator that constructs normal forms of terms in this calculus.},
	language = {en},
	author = {Balat, Vincent},
	file = {Balat - Extensional Normalisation and Type-Directed Partia.pdf:/home/tim/Zotero/storage/XDK9EZXW/Balat - Extensional Normalisation and Type-Directed Partia.pdf:application/pdf},
}

@article{kiselyov_staging_nodate,
	title = {Staging with {Delimited} {Control}},
	abstract = {It is often hard to write programs that are efÔ¨Åcient yet reusable. For example, an efÔ¨Åcient implementation of Gaussian elimination should be specialized to the structure and known static properties of the input matrix. The most proÔ¨Åtable optimizations, such as choosing the best pivoting or memoization, cannot be expected of even an advanced compiler because they are speciÔ¨Åc to the domain, but expressing these optimizations directly makes for ungainly source code. Instead, a promising and popular way to reconcile efÔ¨Åciency with reusability is for a domain expert to write code generators.},
	language = {en},
	author = {Kiselyov, Oleg and Shan, Chung-chieh},
	file = {Kiselyov and Shan - Staging with Delimited Control.pdf:/home/tim/Zotero/storage/XX9RGS7X/Kiselyov and Shan - Staging with Delimited Control.pdf:application/pdf},
}

@article{kiselyov_lifted_nodate,
	title = {Lifted inference: normalizing loops by evaluation},
	language = {en},
	author = {Kiselyov, Oleg and Shan, Chung-chieh},
	file = {Kiselyov and Shan - Lifted inference normalizing loops by evaluation.pdf:/home/tim/Zotero/storage/Q9BESKPJ/Kiselyov and Shan - Lifted inference normalizing loops by evaluation.pdf:application/pdf},
}

@inproceedings{felleisen_theory_1988,
	address = {San Diego, California, United States},
	title = {The theory and practice of first-class prompts},
	isbn = {978-0-89791-252-5},
	url = {http://portal.acm.org/citation.cfm?doid=73560.73576},
	doi = {10.1145/73560.73576},
	language = {en},
	urldate = {2024-07-23},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '88},
	publisher = {ACM Press},
	author = {Felleisen, M.},
	year = {1988},
	keywords = {abstract machines},
	pages = {180--190},
	file = {Felleisen - 1988 - The theory and practice of first-class prompts.pdf:/home/tim/Zotero/storage/ET6VF5SN/Felleisen - 1988 - The theory and practice of first-class prompts.pdf:application/pdf},
}

@article{downen_delimited_2014,
	title = {Delimited control and computational effects},
	volume = {24},
	copyright = {https://www.cambridge.org/core/terms},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796813000312/type/journal_article},
	doi = {10.1017/S0956796813000312},
	abstract = {We give a framework for delimited control with multiple prompts, in the style of Parigot‚Äôs Œª ¬µcalculus, through a series of incremental extensions by starting with the pure Œª -calculus. Each language inherits the semantics and reduction theory of its parent, giving a systematic way to describe each level of control. For each language of interest, we fully characterize its semantics in terms of a reduction semantics, operational semantics, continuation-passing style transform, and abstract machine. Furthermore, the control operations are expressed in terms of Ô¨Åne-grained primitives that can be used to build well-known, higher-level control operators. In order to illustrate the expressive power provided by the various languages, we show how other computational effects can be encoded in terms of these control operators.},
	language = {en},
	number = {1},
	urldate = {2024-07-23},
	journal = {Journal of Functional Programming},
	author = {Downen, Paul and Ariola, Zena M.},
	month = jan,
	year = {2014},
	keywords = {abstract machines},
	pages = {1--55},
	file = {Downen and Ariola - 2014 - Delimited control and computational effects.pdf:/home/tim/Zotero/storage/GVAZ37B4/Downen and Ariola - 2014 - Delimited control and computational effects.pdf:application/pdf},
}

@book{association_for_computing_machinery_conference_1995,
	address = {New York, NY},
	title = {Conference record of {FPCA} '95: papers presented at the conference},
	isbn = {978-0-89791-719-3},
	shorttitle = {Conference record of {FPCA} '95},
	language = {en},
	publisher = {ACM Press},
	editor = {{Association for Computing Machinery} and {Association for Computing Machinery} and {IFIP Working Group 2.8 on Functional Programming}},
	year = {1995},
	note = {Meeting Name: International Conference on Functional Programming Languages and Computer Architecture},
	keywords = {abstract machines},
	file = {Association for Computing Machinery et al. - 1995 - Conference record of FPCA '95 papers presented at.pdf:/home/tim/Zotero/storage/FJ9FQJT6/Association for Computing Machinery et al. - 1995 - Conference record of FPCA '95 papers presented at.pdf:application/pdf},
}

@inproceedings{ikemori_typed_2023,
	address = {Lisboa Portugal},
	title = {Typed {Equivalence} of {Labeled} {Effect} {Handlers} and {Labeled} {Delimited} {Control} {Operators}},
	isbn = {9798400708121},
	url = {https://dl.acm.org/doi/10.1145/3610612.3610616},
	doi = {10.1145/3610612.3610616},
	abstract = {Algebraic effect handlers and delimited control operators are language facilities for expressing computational effects. Their labeled variations can express multiple kinds of exceptions, multiple states, and so on. We prove that labeled effect handlers and labeled control operators have equal expressive power. To show this, we develop a type-sound calculus for each facility and define macro translations between the typed calculi. The established equivalence can be used to understand and implement one facility in terms of the other.},
	language = {en},
	urldate = {2024-07-25},
	booktitle = {International {Symposium} on {Principles} and {Practice} of {Declarative} {Programming}},
	publisher = {ACM},
	author = {Ikemori, Kazuki and Cong, Youyou and Masuhara, Hidehiko},
	month = oct,
	year = {2023},
	keywords = {macro expressibility},
	pages = {1--13},
	file = {Ikemori et al. - 2023 - Typed Equivalence of Labeled Effect Handlers and L.pdf:/home/tim/Zotero/storage/PCXZLG5R/Ikemori et al. - 2023 - Typed Equivalence of Labeled Effect Handlers and L.pdf:application/pdf},
}

@article{abe_typed_2023,
	title = {A typed lambda-calculus with first-class configurations},
	volume = {33},
	copyright = {https://academic.oup.com/journals/pages/open\_access/funder\_policies/chorus/standard\_publication\_model},
	issn = {0955-792X, 1465-363X},
	url = {https://academic.oup.com/logcom/article/33/7/1527/6748727},
	doi = {10.1093/logcom/exac062},
	abstract = {Filinski and Griffin have independently succeeded in extending the formulae-as-types notion to deal with continuations. Whereas Griffin adopted control operators primitively, Filinski adopted the duality of functions to construct a symmetric lambda-calculus in which continuations are first-class objects. In this paper, we construct a typed lambda-calculus with firstclass configurations consisting of expressions and continuations of the same types. Our calculus corresponds to a natural deduction based on Rumfitt‚Äôs bilateralism. Function types are represented as the implication and but-not connectives in intuitionistic and paraconsistent logics, respectively. Our calculus is not only logically consistent, but also computationally consistent. Our calculus with call-by-value and call-by-name strategies correspond to Wadler‚Äôs call-by-value and call-byname dual calculi, respectively. Furthermore, we propose a notion of relaxed configurations, which loosely take expressions and continuations of different types. We confirm that the relaxedness defines control operators for delimited continuations.},
	language = {en},
	number = {7},
	urldate = {2024-07-25},
	journal = {Journal of Logic and Computation},
	author = {Abe, Tatsuya and Kimura, Daisuke},
	month = oct,
	year = {2023},
	pages = {1527--1565},
	file = {Abe and Kimura - 2023 - A typed lambda-calculus with first-class configura.pdf:/home/tim/Zotero/storage/VY9E2QG7/Abe and Kimura - 2023 - A typed lambda-calculus with first-class configura.pdf:application/pdf},
}

@inproceedings{downen_compositional_2014,
	address = {Gothenburg Sweden},
	title = {Compositional semantics for composable continuations: from abortive to delimited control},
	isbn = {978-1-4503-2873-9},
	shorttitle = {Compositional semantics for composable continuations},
	url = {https://dl.acm.org/doi/10.1145/2628136.2628147},
	doi = {10.1145/2628136.2628147},
	abstract = {Parigot‚Äôs Œª¬µ-calculus, a system for computational reasoning about classical proofs, serves as a foundation for control operations embodied by operators like Scheme‚Äôs callcc. We demonstrate that the call-by-value theory of the Œª¬µ-calculus contains a latent theory of delimited control, and that a known variant of Œª¬µ which unshackles the syntax yields a calculus of composable continuations from the existing constructs and rules for classical control. To relate to the various formulations of control effects, and to continuationpassing style, we use a form of compositional program transformations which preserves the underlying structure of equational theories, contexts, and substitution. Finally, we generalize the callby-name and call-by-value theories of the Œª¬µ-calculus by giving a single parametric theory that encompasses both, allowing us to generate a call-by-need instance that deÔ¨Ånes a calculus of classical and delimited control with lazy evaluation and sharing.},
	language = {en},
	urldate = {2024-07-25},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {ACM},
	author = {Downen, Paul and Ariola, Zena M.},
	month = aug,
	year = {2014},
	pages = {109--122},
	file = {Downen and Ariola - 2014 - Compositional semantics for composable continuatio.pdf:/home/tim/Zotero/storage/LLVG6T26/Downen and Ariola - 2014 - Compositional semantics for composable continuatio.pdf:application/pdf},
}

@phdthesis{downen_sequent_2017,
	type = {{PhD} {Thesis}},
	title = {Sequent {Calculus}: {A} {Logic} and a {Language} for {Computation} and {Duality}},
	url = {https://byu.idm.oclc.org/login/?url=https://www.proquest.com/dissertations-theses/sequent-calculus-logic-language-computation/docview/1949853176/se-2},
	abstract = {Truth and falsehood, questions and answers, construction and deconstruction; most things come in dual pairs. Duality is a mirror that reveals the new from the old via opposition. This idea appears pervasively in logic, where duality inverts "true" with "false" and "and" with "or." However, even though programming languages are closely connected to logics, this kind of strong duality is not so apparent in practice. Sum types (disjoint tagged unions) and product types (structures) are dual concepts, but in the realm of programming, natural biases obscure their duality. To better understand the role of duality in programming, we shift our perspective. Our approach is based on the Curry-Howard isomorphism which says that programs following a specification are the same as proofs for mathematical theorems. This thesis explores Gentzen's sequent calculus, a logic steeped in duality, as a model for computational duality. By applying the Curry-Howard isomorphism to the sequent calculus, we get a language that combines dual programming concepts as equal opposites: data types found in functional languages are dual to co-data types (interface-based objects) found in object-oriented languages, control flow is dual to information flow, induction is dual to co-induction. This gives a duality-based semantics for reasoning about programs via orthogonality : checking safety and correctness based on a comprehensive test suite. We use the language of the sequent calculus to apply ideas from logic to issues relevant to program compilation. The idea of logical polarity reveals a symmetric basis of primitive programming constructs that can faithfully represent all user-defined data and co-data types. We reflect the lessons learned back into a core language for functional languages, at the cost of symmetry, with the relationship between the sequent calculus and natural deduction. This relationship lets us derive a pure Œª-calculus with user-defined data and co-data which we further extend by bringing out the implicit control-flow in functional programs. Explicit control-flow lets us share and name control the same way we share and name data, enabling a direct representation of join points, which are essential for tractable optimization and compilation.},
	language = {English},
	author = {Downen, Paul},
	year = {2017},
	note = {ISBN: 978-0-355-14335-5
Publication Title: ProQuest Dissertations and Theses},
	keywords = {0984:Computer science, Applied sciences, Computer science, Control, Curry-Howard, Duality, Recursion, Sequent calculus, Type systems},
	file = {out.pdf:/home/tim/Zotero/storage/NTFBJ9XM/out.pdf:application/pdf},
}

@article{schuster_typed_2022,
	title = {Typed {Continuation}-{Passing} for {Lexical} {Handlers}},
	abstract = {EÔ¨Äect handlers are a language feature which enjoys popularity in academia and is also gaining traction in industry. Programs use abstract eÔ¨Äect operations and handlers provide meaning to them in a delimited scope. Each eÔ¨Äect operation is handled by the dynamically closest handler. Using an eÔ¨Äect operation outside of a matching handler is meaningless and results in an error. A type-and-eÔ¨Äect system prevents such errors from happening. Lexical eÔ¨Äect handlers are a recent variant of eÔ¨Äect handlers with a number of attractive properties. Just as with traditional eÔ¨Äect handlers, programs use eÔ¨Äect operations and handlers give meaning to them. But unlike with traditional eÔ¨Äect handlers, the connection between eÔ¨Äect operations and their handler is lexical. Consequently, they typically have diÔ¨Äerent type-and-eÔ¨Äect systems.},
	language = {en},
	author = {Schuster, Philipp and Brachth√§user, Jonathan Immanuel and M√ºller, Marius and Ostermann, Klaus},
	year = {2022},
	keywords = {abstract machines},
	file = {Schuster et al. - 2022 - Typed Continuation-Passing for Lexical Handlers.pdf:/home/tim/Zotero/storage/GYM4N42Y/Schuster et al. - 2022 - Typed Continuation-Passing for Lexical Handlers.pdf:application/pdf},
}

@article{garcia_lazy_nodate,
	title = {Lazy evaluation and delimited control},
	abstract = {The call-by-need lambda calculus provides an equational framework for reasoning syntactically about lazy evaluation. This paper examines its operational characteristics.},
	language = {en},
	author = {Garcia, Ronald and Lumsdaine, Andrew and Sabry, Amr},
	file = {Garcia et al. - Lazy evaluation and delimited control.pdf:/home/tim/Zotero/storage/2Q7XBB9E/Garcia et al. - Lazy evaluation and delimited control.pdf:application/pdf},
}

@phdthesis{barbagiannis_non-strict_2017,
	type = {{PhD} {Thesis}},
	title = {Non-{Strict} {Pattern} {Matching} and {Delimited} {Control}},
	school = {National and Kapodistrian University of Athens},
	author = {Barbagiannis, Petros},
	year = {2017},
	file = {thesis.pdf:/home/tim/Zotero/storage/2CI3AC6X/thesis.pdf:application/pdf},
}

@article{ghuloum_incremental_nodate,
	title = {An {Incremental} {Approach} to {Compiler} {Construction}},
	abstract = {Compilers are perceived to be magical artifacts, carefully crafted by the wizards, and unfathomable by the mere mortals. Books on compilers are better described as wizard-talk: written by and for a clique of all-knowing practitioners. Real-life compilers are too complex to serve as an educational tool. And the gap between real-life compilers and the educational toy compilers is too wide. The novice compiler writer stands puzzled facing an impenetrable barrier, ‚Äúbetter write an interpreter instead.‚Äù The goal of this paper is to break that barrier. We show that building a compiler can be as easy as building an interpreter. The compiler we construct accepts a large subset of the Scheme programming language and produces assembly code for the Intel-x86 architecture, the dominant architecture of personal computing. The development of the compiler is broken into many small incremental steps. Every step yields a fully working compiler for a progressively expanding subset of Scheme. Every compiler step produces real assembly code that can be assembled then executed directly by the hardware. We assume that the reader is familiar with the basic computer architecture: its components and execution model. Detailed knowledge of the Intel-x86 architecture is not required.},
	language = {en},
	author = {Ghuloum, Abdulaziz},
	file = {PDF:/home/tim/Zotero/storage/RQD2X6FQ/Ghuloum - An Incremental Approach to Compiler Construction.pdf:application/pdf},
}

@article{leijen_robust_nodate,
	title = {Robust type inference for Ô¨Årst-class polymorphism},
	abstract = {We present HML, a type inference system that supports full Ô¨Årstclass polymorphism where few annotations are needed: only function parameters with a polymorphic type need to be annotated. HML is a simpliÔ¨Åcation of MLF where only Ô¨Çexibly quantiÔ¨Åed types are used. This makes the types easier to work with from a programmers perspective, and we found that it simpliÔ¨Åes the implementation of the type inference algorithm. Still, HML retains much of the expressiveness of MLF, it is robust with respect to small program transformations, and has a simple speciÔ¨Åcation of the type rules with an effective type inference algorithm that infers principal types. A reference implementation of the type system is available at: http://research.microsoft.com/users/daan/ pubs.html.},
	language = {en},
	author = {Leijen, Daan},
	file = {PDF:/home/tim/Zotero/storage/GW94KYU2/Leijen - Robust type inference for Ô¨Årst-class polymorphism.pdf:application/pdf},
}

@article{re_extension_nodate,
	title = {{EXTENSION} {OF} {ML} {TYPE} {SYSTEM} {WITH} {A} {SORTED} {EQUATIONAL} {THEORY} {ON} {TYPES}},
	abstract = {We extend the ML language by allowing a sorted regular equational theory on types for which uni cation is decidable and unitary. We prove that the extension keeps principal typings and subject reduction. A new set of typing rules is proposed so that type generalization is simpler and more e cient. We consider typing problems as general uni cation problems, which we solve with a formalism of uni cands. Uni cands naturally deal with sharing between types and lead to a more e cient type inference algorithm. The use of uni cands also simpli es the proof of correctness of the algorithm by splitting it into more elementary steps.},
	language = {en},
	author = {Re, Didier},
	file = {PDF:/home/tim/Zotero/storage/RRF5H28L/Re - EXTENSION OF ML TYPE SYSTEM WITH A SORTED EQUATIONAL THEORY ON TYPES.pdf:application/pdf},
}

@article{kuan_efcient_nodate,
	title = {EfÔ¨Åcient {ML} {Type} {Inference} {Using} {Ranked} {Type} {Variables}},
	abstract = {The Damas-Milner type inference algorithm (commonly known as algorithm W) is at the core of all ML type checkers. Although the algorithm is known to have poor worst-case behavior [8], in practice well-engineered type checkers will run in approximately linear time. To achieve this efÔ¨Åciency, implementations need to improve on algorithm W‚Äôs method of scanning the complete type environment to determine whether a type variable can be generalized at a let binding. Following a suggestion of Damas, most ML type checkers use an alternative method based on ranking uniÔ¨Åcation variables to track their position in the type environment.},
	language = {en},
	author = {Kuan, George and MacQueen, David},
	file = {PDF:/home/tim/Zotero/storage/95JTKSM7/Kuan and MacQueen - EfÔ¨Åcient ML Type Inference Using Ranked Type Variables.pdf:application/pdf},
}

@article{remy_directeur_nodate,
	title = {Directeur de th√®se : {Didier} {R√©my} {INRIA} {Rocquencourt}},
	abstract = {We propose a type system MLF that generalizes ML with Ô¨Årst-class polymorphism as in System F. Expressions may contain second-order type annotations. Every typable expression admits a principal type, which however depends on type annotations. Principal types capture all other types that can be obtained by implicit type instantiation and they can be inferred.},
	language = {fr},
	author = {R√©my, Didier and Pierce, Benjamin and Garrigue, Jacques and Kirchner, Claude and Miller, Dale},
	file = {PDF:/home/tim/Zotero/storage/5QSNFHLD/R√©my et al. - Directeur de th√®se  Didier R√©my INRIA Rocquencourt.pdf:application/pdf},
}

@article{pottier_1_nodate,
	title = {1 {The} {Essence} of {ML} {Type} {Inference}},
	language = {en},
	author = {Pottier, Fran√ßois and R√©my, Didier},
	file = {PDF:/home/tim/Zotero/storage/FPP6D4SD/Pottier and R√©my - 1 The Essence of ML Type Inference.pdf:application/pdf},
}

@inproceedings{gundry_type_2010,
	address = {Baltimore Maryland USA},
	title = {Type inference in context},
	isbn = {978-1-4503-0255-5},
	url = {https://dl.acm.org/doi/10.1145/1863597.1863608},
	doi = {10.1145/1863597.1863608},
	abstract = {We consider the problems of Ô¨Årst-order uniÔ¨Åcation and type inference from a general perspective on problem-solving, namely that of information increase in the problem context. This leads to a powerful technique for implementing type inference algorithms. We describe a uniÔ¨Åcation algorithm and illustrate the technique for the familiar Hindley-Milner type system, but it can be applied to more advanced type systems. The algorithms depend on well-founded contexts: type variable bindings and type-schemes for terms may depend only on earlier bindings. We ensure that uniÔ¨Åcation yields a most general uniÔ¨Åer, and that type inference yields principal types, by advancing deÔ¨Ånitions earlier in the context only when necessary.},
	language = {en},
	urldate = {2024-08-25},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} workshop on {Mathematically} structured functional programming},
	publisher = {ACM},
	author = {Gundry, Adam and McBride, Conor and McKinna, James},
	month = sep,
	year = {2010},
	pages = {43--54},
	file = {PDF:/home/tim/Zotero/storage/VV9Y3K7U/Gundry et al. - 2010 - Type inference in context.pdf:application/pdf},
}

@article{gundry_type_nodate,
	title = {Type {Inference}, {Haskell} and {Dependent} {Types}},
	language = {en},
	author = {Gundry, Adam Michael},
	file = {PDF:/home/tim/Zotero/storage/EB36BULT/Gundry - Type Inference, Haskell and Dependent Types.pdf:application/pdf},
}

@article{emrich_constraint-based_2022,
	title = {Constraint-based type inference for {FreezeML}},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3547642},
	doi = {10.1145/3547642},
	abstract = {FreezeML is a new approach to first-class polymorphic type inference that  
employs term annotations to control when and how polymorphic types are  
instantiated and generalised. It conservatively extends Hindley-Milner type  
inference and was first presented as an extension to Algorithm W. More modern  
type inference techniques such as HM(X) and OutsideIn(X) employ constraints to  
support features such as type classes, type families, rows, and other  
extensions. We take the first step towards modernising FreezeML by presenting  
a constraint-based type inference algorithm. We introduce a new constraint  
language, inspired by the Pottier/R√©my presentation of HM(X), in order to allow  
FreezeML type inference problems to be expressed as constraints. We present a  
deterministic stack machine for solving FreezeML constraints and prove its  
termination and correctness.},
	language = {en},
	number = {ICFP},
	urldate = {2024-08-25},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Emrich, Frank and Stolarek, Jan and Cheney, James and Lindley, Sam},
	month = aug,
	year = {2022},
	pages = {570--595},
	file = {PDF:/home/tim/Zotero/storage/P6AFW2EX/Emrich et al. - 2022 - Constraint-based type inference for FreezeML.pdf:application/pdf},
}

@inproceedings{emrich_freezeml_2020,
	title = {{FreezeML}: {Complete} and {Easy} {Type} {Inference} for {First}-{Class} {Polymorphism}},
	shorttitle = {{FreezeML}},
	url = {http://arxiv.org/abs/2004.00396},
	doi = {10.1145/3385412.3386003},
	abstract = {ML is remarkable in providing statically typed polymorphism without the programmer ever having to write any type annotations. The cost of this parsimony is that the programmer is limited to a form of polymorphism in which quantifiers can occur only at the outermost level of a type and type variables can be instantiated only with monomorphic types.},
	language = {en},
	urldate = {2024-08-25},
	booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	author = {Emrich, Frank and Lindley, Sam and Stolarek, Jan and Cheney, James and Coates, Jonathan},
	month = jun,
	year = {2020},
	note = {arXiv:2004.00396 [cs]},
	keywords = {Computer Science - Programming Languages},
	pages = {423--437},
	file = {PDF:/home/tim/Zotero/storage/QB3CG6IM/Emrich et al. - 2020 - FreezeML Complete and Easy Type Inference for First-Class Polymorphism.pdf:application/pdf},
}

@article{vytiniotis_fph_nodate,
	title = {{FPH}: {First}-class {Polymorphism} for {Haskell}},
	abstract = {Languages supporting polymorphism typically have ad-hoc restrictions on where polymorphic types may occur. Supporting ‚ÄúÔ¨Årstclass‚Äù polymorphism, by lifting those restrictions, is obviously desirable, but it is hard to achieve this without sacriÔ¨Åcing type inference. We present a new type system for higher-rank and impredicative polymorphism that improves on earlier proposals: it is an extension of Damas-Milner; it relies only on System F types; it has a simple, declarative speciÔ¨Åcation; it is robust to program transformations; and it enjoys a complete and decidable type inference algorithm.},
	language = {en},
	author = {Vytiniotis, Dimitrios and Weirich, Stephanie and Jones, Simon Peyton},
	file = {PDF:/home/tim/Zotero/storage/R4IGVUTW/Vytiniotis et al. - FPH First-class Polymorphism for Haskell.pdf:application/pdf},
}

@article{damas_principal_nodate,
	title = {Principal {Type}-{Schemes} for {Functional} {Programs}},
	language = {en},
	author = {Damas, L and Milner, R},
	file = {PDF:/home/tim/Zotero/storage/IKPNJDGS/Damas and Milner - Principal Type-Schemes for Functional Programs.pdf:application/pdf},
}

@article{leijen_principal_nodate,
	title = {Principal {Type} {Inference} under a {Prefix}},
	language = {en},
	author = {Leijen, Daan and Whiting, Tim and Ye, Wenjia},
	file = {PDF:/home/tim/Zotero/storage/JQ2ASI53/Leijen et al. - Principal Type Inference under a Prefix.pdf:application/pdf},
}

@article{strachey_fundamental_nodate,
	title = {Fundamental {Concepts} in {Programming} {Languages}},
	abstract = {This paper forms the substance of a course of lectures given at the International Summer School in Computer Programming at Copenhagen in August, 1967. The lectures were originally given from notes and the paper was written after the course was Ô¨Ånished. In spite of this, and only partly because of the shortage of time, the paper still retains many of the shortcomings of a lecture course. The chief of these are an uncertainty of aim‚Äîit is never quite clear what sort of audience there will be for such lectures‚Äîand an associated switching from formal to informal modes of presentation which may well be less acceptable in print than it is natural in the lecture room. For these (and other) faults, I apologise to the reader.},
	language = {en},
	author = {Strachey, Christopher},
	file = {PDF:/home/tim/Zotero/storage/N7FVM5DL/Strachey - Fundamental Concepts in Programming Languages.pdf:application/pdf},
}

@incollection{leporati_context-free_2021,
	address = {Cham},
	title = {Context-{Free} {Grammars} with {Lookahead}},
	volume = {12638},
	isbn = {978-3-030-68194-4 978-3-030-68195-1},
	url = {http://link.springer.com/10.1007/978-3-030-68195-1_16},
	abstract = {We introduce context-free grammars with lookahead. The grammars are an extension of both context-free grammars and parsing expression grammars, hence we can handle the two grammars in a uniÔ¨Åed way. To accommodate lookahead, we use a language with lookahead, which is a set of string pairs. We considered the grammar as a system of equations and give the language with lookahead by the limit of iterations from the empty set. The language class is closed under union, intersection, complement, and a weak version of concatenation and Kleene star.},
	language = {en},
	urldate = {2024-09-11},
	booktitle = {Language and {Automata} {Theory} and {Applications}},
	publisher = {Springer International Publishing},
	author = {Miyazaki, Takayuki and Minamide, Yasuhiko},
	editor = {Leporati, Alberto and Mart√≠n-Vide, Carlos and Shapira, Dana and Zandron, Claudio},
	year = {2021},
	doi = {10.1007/978-3-030-68195-1_16},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {213--225},
	file = {PDF:/home/tim/Zotero/storage/LH8GERUK/Miyazaki and Minamide - 2021 - Context-Free Grammars with Lookahead.pdf:application/pdf},
}

@article{miyazaki_derivatives_2023,
	title = {Derivatives of {Context}-free {Grammars} with {Lookahead}},
	volume = {31},
	issn = {1882-6652},
	url = {https://www.jstage.jst.go.jp/article/ipsjjip/31/0/31_421/_article},
	doi = {10.2197/ipsjjip.31.421},
	abstract = {Context-free grammars with lookahead (CFGLAs) are context-free grammars with positive and negative lookahead. In this paper, we develop a recognition algorithm for CFGLA by combining derivatives of context-free grammars and derivatives of regular expressions with lookahead. The original semantics of CFGLA has some problems, and the recognition algorithm does not run in polynomial time. We introduce better semantics with the least Ô¨Åxed point of pairs of lower and upper bounds. Under the new semantics, the recognition algorithm runs in O(n3jGj) time and O(n2jGj) space for an input string of the length n and a given CFGLA G.},
	language = {en},
	number = {0},
	urldate = {2024-09-11},
	journal = {Journal of Information Processing},
	author = {Miyazaki, Takayuki and Minamide, Yasuhiko},
	year = {2023},
	pages = {421--431},
	file = {PDF:/home/tim/Zotero/storage/NILKDIYU/Miyazaki and Minamide - 2023 - Derivatives of Context-free Grammars with Lookahead.pdf:application/pdf},
}

@article{lee_proofs_1998,
	title = {Proofs about a folklore let-polymorphic type inference algorithm},
	volume = {20},
	issn = {0164-0925, 1558-4593},
	url = {https://dl.acm.org/doi/10.1145/291891.291892},
	doi = {10.1145/291891.291892},
	abstract = {The Hindley/Milner let-polymorphic type inference system has two different algorithms: one is the
              de facto
              standard Algorithm ùí≤ that is bottom-up (or context-insensitive), and the other is a ‚Äúfolklore‚Äù algorithm that is top-down (or context-sensitive). Because the latter algorithm has not been formally presented with its soundness and completeness proofs, and its relation with the ùí≤ algorithm has not been rigorously investigated, its use in place of (or in combination with) ùí≤ is not well founded. In this article, we formally define the context-sensitive, top-down type inference algorithm (named ‚ÄúM‚Äù), prove its soundness and completeness, and show a distinguishing property that M always stops earlier than ùí≤ if the input program is ill typed. Our proofs can be seen as theoretical justifications for various type-checking strategies being used in practice.},
	language = {en},
	number = {4},
	urldate = {2024-09-09},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Lee, Oukseh and Yi, Kwangkeun},
	month = jul,
	year = {1998},
	pages = {707--723},
	file = {PDF:/home/tim/Zotero/storage/U4HWCL3P/Lee and Yi - 1998 - Proofs about a folklore let-polymorphic type inference algorithm.pdf:application/pdf},
}

@book{heeren_top_2005,
	address = {S.l.},
	title = {Top quality type error messages},
	isbn = {978-90-393-4005-9},
	language = {eng},
	publisher = {s.n.},
	author = {Heeren, B.J.},
	year = {2005},
	note = {OCLC: 66448975},
	file = {PDF:/home/tim/Zotero/storage/A8VHL2VB/Heeren - 2005 - Top quality type error messages.pdf:application/pdf},
}

@article{lee_generalization_nodate,
	title = {A {Generalization} of {Hybrid} {Let}-{Polymorphic} {Type} {Inference} {Algorithms}},
	language = {en},
	author = {Lee, Oukseh},
	file = {PDF:/home/tim/Zotero/storage/SRT2BVCH/Lee - A Generalization of Hybrid Let-Polymorphic Type Inference Algorithms.pdf:application/pdf},
}

@incollection{goos_unification_1999,
	address = {Berlin, Heidelberg},
	title = {On the {Unification} of {Substitutions} in {Type} {Inference}},
	volume = {1595},
	isbn = {978-3-540-66229-7 978-3-540-48515-5},
	url = {http://link.springer.com/10.1007/3-540-48515-5_9},
	abstract = {Traditional type-inference and type-checking algorithms work well with correctly typed programs, but their results when given programs containing type-errors can be unpredictable. This leads to a problem with implementations of type-checkers: they are often inaccurate when announcing the apparent locations of mistakes in programs, tending to notice problems towards the end of the the program even if the source occurs much earlier. This is a particular problem with programming l anguages with Hindley-Milner type-systems such as used in Standard ML.},
	language = {en},
	urldate = {2024-09-09},
	booktitle = {Implementation of {Functional} {Languages}},
	publisher = {Springer Berlin Heidelberg},
	author = {McAdam, Bruce J.},
	editor = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan and Hammond, Kevin and Davie, Tony and Clack, Chris},
	year = {1999},
	doi = {10.1007/3-540-48515-5_9},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {137--152},
	file = {PDF:/home/tim/Zotero/storage/92MC5BH6/McAdam - 1999 - On the Unification of Substitutions in Type Inference.pdf:application/pdf},
}

@book{heeren_top_2005-1,
	address = {S.l.},
	title = {Top quality type error messages},
	isbn = {978-90-393-4005-9},
	language = {eng},
	publisher = {s.n.},
	author = {Heeren, B.J.},
	year = {2005},
	note = {OCLC: 66448975},
	file = {PDF:/home/tim/Zotero/storage/XLHUCALJ/Heeren - 2005 - Top quality type error messages.pdf:application/pdf},
}

@incollection{goos_essence_2002,
	address = {Berlin, Heidelberg},
	title = {The {Essence} of {Principal} {Typings}},
	volume = {2380},
	isbn = {978-3-540-43864-9 978-3-540-45465-6},
	url = {http://link.springer.com/10.1007/3-540-45465-9_78},
	abstract = {Let S be some type system. A typing in S for a typable term M is the collection of all of the information other than M which appears in the Ô¨Ånal judgement of a proof derivation showing that M is typable. For example, suppose there is a derivation in S ending with the judgement A ` M : œÑ meaning that M has result type œÑ when assuming the types of free variables are given by A. Then (A, œÑ ) is a typing for M .},
	language = {en},
	urldate = {2024-09-09},
	booktitle = {Automata, {Languages} and {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Wells, J. B.},
	editor = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan and Widmayer, Peter and Eidenbenz, Stephan and Triguero, Francisco and Morales, Rafael and Conejo, Ricardo and Hennessy, Matthew},
	year = {2002},
	doi = {10.1007/3-540-45465-9_78},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {913--925},
	file = {PDF:/home/tim/Zotero/storage/DYQEGVKM/Wells - 2002 - The Essence of Principal Typings.pdf:application/pdf},
}

@article{ketsman_datalog_2020,
	title = {Datalog with {Negation} and {Monotonicity}},
	volume = {155},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	issn = {1868-8969},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ICDT.2020.19},
	doi = {10.4230/LIPICS.ICDT.2020.19},
	abstract = {Positive Datalog has several nice properties that are lost when the language is extended with negation. One example is that Ô¨Åxpoints of positive Datalog programs are robust w.r.t. the order in which facts are inserted, which facilitates eÔ¨Écient evaluation of such programs in distributed environments. A natural question to ask, given a (stratiÔ¨Åed) Datalog program with negation, is whether an equivalent positive Datalog program exists.},
	language = {en},
	urldate = {2024-09-13},
	journal = {LIPIcs, Volume 155, ICDT 2020},
	author = {Ketsman, Bas and Koch, Christoph},
	collaborator = {Lutz, Carsten and Jung, Jean Christoph},
	year = {2020},
	note = {Artwork Size: 18 pages, 658699 bytes
ISBN: 9783959771399
Medium: application/pdf
Publisher: Schloss Dagstuhl ‚Äì Leibniz-Zentrum f√ºr Informatik},
	keywords = {Datalog, Information systems ‚Üí Relational database query languages, Monotonicity, Theory of computation ‚Üí Constraint and logic programming},
	pages = {19:1--19:18},
	file = {PDF:/home/tim/Zotero/storage/3STTJFZW/Ketsman and Koch - 2020 - Datalog with Negation and Monotonicity.pdf:application/pdf},
}

@inproceedings{adams_complexity_2016,
	address = {New York, NY, USA},
	series = {{PLDI} '16},
	title = {On the {Complexity} and {Performance} of {Parsing} with {Derivatives}},
	isbn = {978-1-4503-4261-2},
	doi = {10.1145/2908080.2908128},
	booktitle = {Proceedings of the 37th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Adams, Michael D. and Hollenbeck, Celeste and Might, Matthew},
	month = jun,
	year = {2016},
	file = {PDF:/home/tim/Zotero/storage/4A7ELFC9/Adams et al. - 2016 - On the Complexity and Performance of Parsing with Derivatives.pdf:application/pdf},
}

@article{ford_parsing_nodate,
	title = {Parsing {Expression} {Grammars}: {A} {Recognition}-{Based} {Syntactic} {Foundation}},
	abstract = {For decades we have been using Chomsky‚Äôs generative system of grammars, particularly context-free grammars (CFGs) and regular expressions (REs), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difÔ¨Åcult both to express and to parse machine-oriented languages using CFGs. Parsing Expression Grammars (PEGs) provide an alternative, recognition-based formal foundation for describing machineoriented syntax, which solves the ambiguity problem by not introducing ambiguity in the Ô¨Årst place. Where CFGs express nondeterministic choice between alternatives, PEGs instead use prioritized choice. PEGs address frequently felt expressiveness limitations of CFGs and REs, simplifying syntax deÔ¨Ånitions and making it unnecessary to separate their lexical and hierarchical components. A linear-time parser can be built for any PEG, avoiding both the complexity and Ô¨Åckleness of LR parsers and the inefÔ¨Åciency of generalized CFG parsing. While PEGs provide a rich set of operators for constructing grammars, they are reducible to two minimal recognition schemas developed around 1970, TS/TDPL and gTS/GTDPL, which are here proven equivalent in effective recognition power.},
	language = {en},
	author = {Ford, Bryan},
	file = {PDF:/home/tim/Zotero/storage/BC8PF96J/Ford - Parsing Expression Grammars A Recognition-Based Syntactic Foundation.pdf:application/pdf},
}

@article{koutris_lecture_nodate,
	title = {Lecture 9: {Datalog} with {Negation}},
	language = {en},
	author = {Koutris, Paris},
	file = {PDF:/home/tim/Zotero/storage/8TQWVCHP/Koutris - Lecture 9 Datalog with Negation.pdf:application/pdf},
}

@article{noauthor_principal_nodate,
	title = {Principal {Type} {Inference} under a {Prefix}},
	language = {en},
	file = {PDF:/home/tim/Zotero/storage/DEMJXTEE/Principal Type Inference under a Prefix.pdf:application/pdf},
}

@article{barrett_derivation_nodate,
	title = {Derivation of a {Pattern}-{Matching} {Compiler}},
	language = {en},
	author = {Barrett, GeoÔ¨Ä and Wadler, Philip},
	file = {PDF:/home/tim/Zotero/storage/6PXN7NEG/Barrett and Wadler - Derivation of a Pattern-Matching Compiler.pdf:application/pdf},
}

@inproceedings{odersky_implementing_2016,
	address = {Amsterdam Netherlands},
	title = {Implementing higher-kinded types in {Dotty}},
	isbn = {978-1-4503-4648-1},
	url = {https://dl.acm.org/doi/10.1145/2998392.2998400},
	doi = {10.1145/2998392.2998400},
	language = {en},
	urldate = {2024-09-26},
	booktitle = {Proceedings of the 2016 7th {ACM} {SIGPLAN} {Symposium} on {Scala}},
	publisher = {ACM},
	author = {Odersky, Martin and Martres, Guillaume and Petrashko, Dmitry},
	month = oct,
	year = {2016},
	pages = {51--60},
	file = {PDF:/home/tim/Zotero/storage/GZJ2UPIS/Odersky et al. - 2016 - Implementing higher-kinded types in Dotty.pdf:application/pdf},
}

@article{amin_towards_nodate,
	title = {Towards a foundation for {Scala}‚Äôs type system},
	abstract = {We propose a new type-theoretic foundation of Scala and languages like it: the Dependent Object Types (DOT) calculus. DOT models Scala‚Äôs path-dependent types, abstract type members and its mixture of nominal and structural typing through the use of reÔ¨Ånement types. The core formalism makes no attempt to model inheritance and mixin composition. DOT normalizes Scala‚Äôs type system by unifying the constructs for type members and by providing classical intersection and union types which simplify greatest lower bound and least upper bound computations.},
	language = {en},
	author = {Amin, Nada and Moors, Adriaan and Odersky, Martin},
	file = {PDF:/home/tim/Zotero/storage/3Y2PZI9Q/Amin et al. - Towards a foundation for Scala‚Äôs type system.pdf:application/pdf},
}

@incollection{lindley_essence_2016,
	address = {Cham},
	title = {The {Essence} of {Dependent} {Object} {Types}},
	volume = {9600},
	copyright = {http://www.springer.com/tdm},
	isbn = {978-3-319-30935-4 978-3-319-30936-1},
	url = {http://link.springer.com/10.1007/978-3-319-30936-1_14},
	abstract = {Focusing on path-dependent types, the paper develops foundations for Scala from Ô¨Årst principles. Starting from a simple calculus D{\textless}: of dependent functions, it adds records, intersections and recursion to arrive at DOT, a calculus for dependent object types. The paper shows an encoding of System F with subtyping in D{\textless}: and demonstrates the expressiveness of DOT by modeling a range of Scala constructs in it.},
	language = {en},
	urldate = {2024-09-26},
	booktitle = {A {List} of {Successes} {That} {Can} {Change} the {World}},
	publisher = {Springer International Publishing},
	author = {Amin, Nada and Gr√ºtter, Samuel and Odersky, Martin and Rompf, Tiark and Stucki, Sandro},
	editor = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
	year = {2016},
	doi = {10.1007/978-3-319-30936-1_14},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {249--272},
	file = {PDF:/home/tim/Zotero/storage/B2XGDRK5/Amin et al. - 2016 - The Essence of Dependent Object Types.pdf:application/pdf},
}

@misc{alviano_generative_2022,
	title = {Generative {Datalog} with {Stable} {Negation}},
	url = {http://arxiv.org/abs/2206.12247},
	abstract = {Extending programming languages with stochastic behaviour such as probabilistic choices or random sampling has a long tradition in computer science. A recent development in this direction is a declarative probabilistic programming language, proposed by B√°r√°ny et al. in 2017, which operates on standard relational databases. In particular, B√°r√°ny et al. proposed generative Datalog, a probabilistic extension of Datalog that allows sampling from discrete probability distributions. Intuitively, the output of a generative Datalog program Œ† on an input database ùê∑ is a probability space over the minimal models of ùê∑ and Œ†, the so-called possible outcomes. This is a natural generalization of the (deterministic) semantics of Datalog, where the output of a program on a database is their unique minimal model. A natural question to ask is how generative Datalog can be enriched with the useful feature of negation, which in turn leads to a strictly more expressive declarative probabilistic programming language. In particular, the challenging question is how the probabilistic semantics of generative Datalog with negation can be robustly deÔ¨Åned. Our goal is to provide an answer to this question by interpreting negation according to the stable model semantics.},
	language = {en},
	urldate = {2024-09-25},
	publisher = {arXiv},
	author = {Alviano, Mario and Lanzinger, Matthias and Morak, Michael and Pieris, Andreas},
	month = jun,
	year = {2022},
	note = {arXiv:2206.12247 [cs]},
	keywords = {Computer Science - Databases},
	file = {PDF:/home/tim/Zotero/storage/6RLQB3QN/Alviano et al. - 2022 - Generative Datalog with Stable Negation.pdf:application/pdf},
}

@article{koutris_lecture_nodate-1,
	title = {Lecture 9: {Datalog} with {Negation}},
	language = {en},
	author = {Koutris, Paris},
	file = {PDF:/home/tim/Zotero/storage/2ZBJIH4T/Koutris - Lecture 9 Datalog with Negation.pdf:application/pdf},
}

@article{ketsman_datalog_2020-1,
	title = {Datalog with {Negation} and {Monotonicity}},
	volume = {155},
	copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
	issn = {1868-8969},
	url = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ICDT.2020.19},
	doi = {10.4230/LIPICS.ICDT.2020.19},
	abstract = {Positive Datalog has several nice properties that are lost when the language is extended with negation. One example is that Ô¨Åxpoints of positive Datalog programs are robust w.r.t. the order in which facts are inserted, which facilitates eÔ¨Écient evaluation of such programs in distributed environments. A natural question to ask, given a (stratiÔ¨Åed) Datalog program with negation, is whether an equivalent positive Datalog program exists.},
	language = {en},
	urldate = {2024-09-25},
	journal = {LIPIcs, Volume 155, ICDT 2020},
	author = {Ketsman, Bas and Koch, Christoph},
	collaborator = {Lutz, Carsten and Jung, Jean Christoph},
	year = {2020},
	note = {Artwork Size: 18 pages, 658699 bytes
ISBN: 9783959771399
Medium: application/pdf
Publisher: Schloss Dagstuhl ‚Äì Leibniz-Zentrum f√ºr Informatik},
	keywords = {Datalog, Information systems ‚Üí Relational database query languages, Monotonicity, Theory of computation ‚Üí Constraint and logic programming},
	pages = {19:1--19:18},
	file = {PDF:/home/tim/Zotero/storage/PCAEJYJC/Ketsman and Koch - 2020 - Datalog with Negation and Monotonicity.pdf:application/pdf},
}

@article{koutris_lecture_nodate-2,
	title = {Lecture 9: {Datalog} with {Negation}},
	language = {en},
	author = {Koutris, Paris},
	file = {PDF:/home/tim/Zotero/storage/6P4YEGKW/Koutris - Lecture 9 Datalog with Negation.pdf:application/pdf},
}

@misc{noauthor_negation_nodate,
	title = {Negation as {Failure} 3},
	url = {https://www.cmi.ac.in/~madhavan/courses/pl2011/lecturenotes/lecture-notes/node122.html},
}

@incollection{fine_justification_1989,
	title = {The {Justification} of {Negation} as {Failure}},
	volume = {126},
	isbn = {978-0-444-70520-4},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0049237X08700508},
	language = {en},
	urldate = {2024-09-25},
	booktitle = {Studies in {Logic} and the {Foundations} of {Mathematics}},
	publisher = {Elsevier},
	author = {Fine, Kit},
	year = {1989},
	doi = {10.1016/S0049-237X(08)70050-8},
	pages = {263--301},
	file = {PDF:/home/tim/Zotero/storage/VZ9GZ2JI/Fine - 1989 - The Justification of Negation as Failure.pdf:application/pdf},
}

@misc{noauthor_negation_nodate-1,
	title = {Negation as {Failure} 2},
	url = {https://cs.union.edu/~striegnk/learn-prolog-now/html/node90.html},
}

@misc{noauthor_negation_nodate-2,
	title = {Negation as {Failure} 1},
	url = {https://cliplab.org/~vocal/public_info/seminar_notes/node52.html},
}

@inproceedings{wadler_theorems_1989,
	address = {Imperial College, London, United Kingdom},
	title = {Theorems for free!},
	isbn = {978-0-89791-328-7},
	url = {http://portal.acm.org/citation.cfm?doid=99370.99404},
	doi = {10.1145/99370.99404},
	abstract = {From the type of a polymorphic function we can derive a theorem that it satisfies. Every function of the same type satisfies the same theorem. This provides a free source of useful theorems, courtesy of Reynolds‚Äô abstraction theorem for the polymorphic lambda calculus.},
	language = {en},
	urldate = {2024-09-24},
	booktitle = {Proceedings of the fourth international conference on {Functional} programming languages and computer architecture  - {FPCA} '89},
	publisher = {ACM Press},
	author = {Wadler, Philip},
	year = {1989},
	pages = {347--359},
	file = {PDF:/home/tim/Zotero/storage/HN3KQXJM/Wadler - 1989 - Theorems for free!.pdf:application/pdf},
}

@incollection{goos_old_1986,
	address = {Berlin, Heidelberg},
	title = {{OLD} resolution with tabulation},
	volume = {225},
	isbn = {978-3-540-16492-0 978-3-540-39831-8},
	url = {http://link.springer.com/10.1007/3-540-16492-8_66},
	abstract = {To resolve the search-incompleteness of depth-first logic program interpreters, a new interpretation method based on the tabulation technique is developed and modeled as a refinement to SLD resolution. Its search space completeness is proved, and a complete search strategy consisting of iterated stages of depth-first search is presented. It is also proved that for programs defining finite relations only, the method under an arbitrary search strategy is terminating and complete.},
	language = {en},
	urldate = {2024-09-27},
	booktitle = {Third {International} {Conference} on {Logic} {Programming}},
	publisher = {Springer Berlin Heidelberg},
	author = {Tamaki, Hisao and Sato, Taisuke},
	editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegm√ºller, G. and Stoer, J. and Wirth, N. and Shapiro, Ehud},
	year = {1986},
	doi = {10.1007/3-540-16492-8_66},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {84--98},
	file = {PDF:/home/tim/Zotero/storage/5DBF97GF/Tamaki and Sato - 1986 - OLD resolution with tabulation.pdf:application/pdf},
}

@inproceedings{zhou_efficient_2003,
	address = {Uppsala Sweden},
	title = {Efficient fixpoint computation in linear tabling},
	isbn = {978-1-58113-705-7},
	url = {https://dl.acm.org/doi/10.1145/888251.888277},
	doi = {10.1145/888251.888277},
	abstract = {Early resolution mechanisms proposed for tabling such as OLDT rely on suspension and resumption of subgoals to compute Ô¨Åxpoints. Recently, a new resolution framework called linear tabling has emerged as an alternative tabling method. The idea of linear tabling is to use iterative computation rather than suspension to compute Ô¨Åxpoints. Although linear tabling is simple, easy to implement, and superior in space eÔ¨Éciency, the current implementations are several times slower than XSB, the state-of-the-art implementation of OLDT, due to re-evaluation of looping subgoals. In this paper, we present a new linear tabling method and propose several optimization techniques for fast computation of Ô¨Åxpoints. The optimization techniques signiÔ¨Åcantly improve the performance by avoiding redundant evaluation of subgoals, re-application of clauses, and reproduction of answers in iterative computation. Our implementation of the method in B-Prolog not only consumes an order of magnitude less stack space than XSB for some programs but also compares favorably well with XSB in speed.},
	language = {en},
	urldate = {2024-09-27},
	booktitle = {Proceedings of the 5th {ACM} {SIGPLAN} international conference on {Principles} and practice of declaritive programming},
	publisher = {ACM},
	author = {Zhou, Neng-Fa and Sato, Taisuke},
	month = aug,
	year = {2003},
	pages = {275--283},
	file = {PDF:/home/tim/Zotero/storage/RLE8GIXV/Zhou and Sato - 2003 - Efficient fixpoint computation in linear tabling.pdf:application/pdf},
}

@article{steffen_fixpoint-analysis_nodate,
	title = {The {Fixpoint}-{Analysis} {Machine}},
	language = {en},
	author = {Steffen, Bernhard and Claien, Andreas and Klein, Marion and Knoop, Jens and Margaria, Tiziana},
	file = {PDF:/home/tim/Zotero/storage/SEJP32AT/Steffen et al. - The Fixpoint-Analysis Machine.pdf:application/pdf},
}

@article{erhard_interactive_2024,
	title = {Interactive abstract interpretation: reanalyzing multithreaded {C} programs for cheap},
	issn = {1433-2779, 1433-2787},
	shorttitle = {Interactive abstract interpretation},
	url = {https://link.springer.com/10.1007/s10009-024-00768-9},
	doi = {10.1007/s10009-024-00768-9},
	abstract = {To put sound program analysis at the Ô¨Ångertips of the software developer, we propose a framework for interactive abstract interpretation of multithreaded C code. Abstract interpretation provides sound analysis results, but can be quite costly in general. To achieve quick response times, we incrementalize the analysis infrastructure, including postprocessing, without necessitating any modiÔ¨Åcations to the analysis speciÔ¨Åcations themselves. We rely on the local generic Ô¨Åxpoint engine TD ‚Äìwhich we enhance with reluctant destabilization to minimize reanalysis eÔ¨Äort. Dedicated further improvements support precise incremental analysis of program properties that include concurrency deÔ¨Åciencies such as data-races. The framework has been implemented in the static analyzer G oblint, and combined with the Mag pieBridg e framework to relay Ô¨Åndings to IDEs. We evaluate our implementation w.r.t. the yard sticks of response time and consistency. We also provide examples of program development highlighting the usability of our approach.},
	language = {en},
	urldate = {2024-09-27},
	journal = {International Journal on Software Tools for Technology Transfer},
	author = {Erhard, Julian and Saan, Simmo and Tilscher, Sarah and Schwarz, Michael and Holter, Karoliine and Vojdani, Vesal and Seidl, Helmut},
	month = sep,
	year = {2024},
	file = {PDF:/home/tim/Zotero/storage/P9DSWWYA/Erhard et al. - 2024 - Interactive abstract interpretation reanalyzing multithreaded C programs for cheap.pdf:application/pdf},
}

@article{wadler_call-by-value_nodate,
	title = {Call-by-{Value} is {Dual} to {Call}-by-{Name}},
	abstract = {The rules of classical logic may be formulated in pairs corresponding to De Morgan duals: rules about \& are dual to rules about ‚à®. A line of work, including that of Filinski (1989), GriÔ¨Én (1990), Parigot (1992), Danos, Joinet, and Schellinx (1995), Selinger (1998,2001), and Curien and Herbelin (2000), has led to the startling conclusion that call-byvalue is the de Morgan dual of call-by-name.},
	language = {en},
	author = {Wadler, Philip},
	file = {PDF:/home/tim/Zotero/storage/ZNL9VK87/Wadler - Call-by-Value is Dual to Call-by-Name.pdf:application/pdf},
}

@article{yedidia_relatively_2016,
	title = {A {Relatively} {Small} {Turing} {Machine} {Whose} {Behavior} {Is} {Independent} of {Set} {Theory}},
	volume = {25},
	issn = {08912513},
	url = {https://www.complex-systems.com/abstracts/v25_i04_a04/},
	doi = {10.25088/ComplexSystems.25.4.297},
	abstract = {Since the deÔ¨Ånition of the Busy Beaver function by Rad¬¥o in 1962, an interesting open question has been what the smallest value of n for which BB(n) is independent of ZFC set theory. Is this n approximately 10, or closer to 1,000,000, or is it even larger? In this paper, we show that it is at most 7,918 by presenting an explicit description of a 7,918-state Turing machine Z with 1 tape and a 2-symbol alphabet that cannot be proved to run forever in ZFC (even though it presumably does), assuming ZFC is consistent. The machine is based on work of Harvey Friedman on independent statements involving order-invariant graphs. In doing so, we give the Ô¨Årst known upper bound on the highest provable Busy Beaver number in ZFC. We also present a 4,888-state Turing machine G that halts if and only if there is a counterexample to Goldbach‚Äôs conjecture, and a 5,372-state Turing machine R that halts if and only if the Riemann hypothesis is false. To create G, R, and Z, we develop and use a higher-level language, Laconic, which is much more convenient than direct state manipulation.},
	language = {en},
	number = {4},
	urldate = {2024-10-01},
	journal = {Complex Systems},
	author = {Yedidia, Adam and Aaronson, Scott and {Massachusetts Institute of Technology}},
	month = dec,
	year = {2016},
	pages = {297--328},
	file = {PDF:/home/tim/Zotero/storage/3Y7DXQWB/Yedidia et al. - 2016 - A Relatively Small Turing Machine Whose Behavior Is Independent of Set Theory.pdf:application/pdf},
}

@article{johnson_pushdown_2014,
	title = {Pushdown flow analysis with abstract garbage collection},
	volume = {24},
	issn = {0956-7968, 1469-7653},
	url = {http://arxiv.org/abs/1406.5106},
	doi = {10.1017/S0956796814000100},
	abstract = {In the static analysis of functional programs, pushdown Ô¨Çow analysis and abstract garbage collection push the boundaries of what we can learn about programs statically. This work illuminates and poses solutions to theoretical and practical challenges that stand in the way of combining the power of these techniques. Pushdown Ô¨Çow analysis grants unbounded yet computable polyvariance to the analysis of return-Ô¨Çow in higher-order programs. Abstract garbage collection grants unbounded polyvariance to abstract addresses which become unreachable between invocations of the abstract contexts in which they were created. Pushdown analysis solves the problem of precisely analyzing recursion in higher-order languages; abstract garbage collection is essential in solving the ‚Äústickiness‚Äù problem. Alone, our benchmarks demonstrate that each method can reduce analysis times and boost precision by orders of magnitude.},
	language = {en},
	number = {2-3},
	urldate = {2024-10-04},
	journal = {Journal of Functional Programming},
	author = {Johnson, J. Ian and Sergey, Ilya and Earl, Christopher and Might, Matthew and Van Horn, David},
	month = may,
	year = {2014},
	note = {arXiv:1406.5106 [cs]},
	keywords = {Computer Science - Programming Languages, F.3.2, D.3.4},
	pages = {218--283},
	file = {PDF:/home/tim/Zotero/storage/225MLAVS/Johnson et al. - 2014 - Pushdown flow analysis with abstract garbage collection.pdf:application/pdf},
}

@article{chargueraud_locally_2012,
	title = {The {Locally} {Nameless} {Representation}},
	volume = {49},
	copyright = {http://www.springer.com/tdm},
	issn = {0168-7433, 1573-0670},
	url = {http://link.springer.com/10.1007/s10817-011-9225-2},
	doi = {10.1007/s10817-011-9225-2},
	abstract = {This paper provides an introduction to the locally nameless approach to the representation of syntax with variable binding, focusing in particular on the use of this technique in formal proofs. First, we explain the beneÔ¨Åts of representing bound variables with de Bruijn indices while retaining names for free variables. Then, we explain how to describe and manipulate syntax in that form, and show how to deÔ¨Åne and reason about judgments on locally nameless terms.},
	language = {en},
	number = {3},
	urldate = {2024-10-04},
	journal = {Journal of Automated Reasoning},
	author = {Chargu√©raud, Arthur},
	month = oct,
	year = {2012},
	pages = {363--408},
	file = {PDF:/home/tim/Zotero/storage/MAU3VWGV/Chargu√©raud - 2012 - The Locally Nameless Representation.pdf:application/pdf},
}

@article{hutton_monadic_nodate,
	title = {Monadic {Parser} {Combinators}},
	abstract = {In functional programming, a popular approach to building recursive descent parsers is to model parsers as functions, and to deÔ¨Åne higher-order functions (or combinators) that implement grammar constructions such as sequencing, choice, and repetition. Such parsers form an instance of a monad , an algebraic structure from mathematics that has proved useful for addressing a number of computational problems. The purpose of this article is to provide a step-by-step tutorial on the monadic approach to building functional parsers, and to explain some of the beneÔ¨Åts that result from exploiting monads. No prior knowledge of parser combinators or of monads is assumed. Indeed, this article can also be viewed as a Ô¨Årst introduction to the use of monads in programming.},
	language = {en},
	author = {Hutton, Graham and Meijer, Erik},
	file = {PDF:/home/tim/Zotero/storage/FW97G2MI/Hutton and Meijer - Monadic Parser Combinators.pdf:application/pdf},
}

@article{owens_regular-expression_2009,
	title = {Regular-expression derivatives re-examined},
	volume = {19},
	copyright = {https://www.cambridge.org/core/terms},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796808007090/type/journal_article},
	doi = {10.1017/S0956796808007090},
	abstract = {Abstract
            Regular-expression derivatives are an old, but elegant, technique for compiling regular expressions to deterministic finite-state machines. It easily supports extending the regular-expression operators with boolean operations, such as intersection and complement. Unfortunately, this technique has been lost in the sands of time and few computer scientists are aware of it. In this paper, we reexamine regular-expression derivatives and report on our experiences in the context of two different functional-language implementations. The basic implementation is simple and we show how to extend it to handle large character sets (e.g., Unicode). We also show that the derivatives approach leads to smaller state machines than the traditional algorithm given by McNaughton and Yamada.},
	language = {en},
	number = {2},
	urldate = {2024-10-17},
	journal = {Journal of Functional Programming},
	author = {Owens, Scott and Reppy, John and Turon, Aaron},
	month = mar,
	year = {2009},
	pages = {173--190},
	file = {PDF:/home/tim/Zotero/storage/KVDYMB78/Owens et al. - 2009 - Regular-expression derivatives re-examined.pdf:application/pdf},
}

@article{brzozowski_derivatives_1964,
	title = {Derivatives of {Regular} {Expressions}},
	volume = {11},
	issn = {0004-5411, 1557-735X},
	url = {https://dl.acm.org/doi/10.1145/321239.321249},
	doi = {10.1145/321239.321249},
	abstract = {Kleene's regular expressions, which can be used for describing sequential circuits, were defined using three operators (union, concatenation and iterate) on sets of sequences. Word descriptions of problems can be more easily put in the regular expression language if the language is enriched by the inclusion of other logical operations. However, il{\textasciitilde}the problem of converting the regular expression description to a state diagram, the existing methods either cannot handle expressions with additional operators, or are made quite complicated by the presence of such operators. In this paper the notion of a derivative of a regular expression is introduced atld the properties of derivatives are discussed. This leads, in a very natural way, to the construction of a state diagram from a regular expression containing any number of logical operators.},
	language = {en},
	number = {4},
	urldate = {2024-10-17},
	journal = {Journal of the ACM},
	author = {Brzozowski, Janusz A.},
	month = oct,
	year = {1964},
	pages = {481--494},
	file = {PDF:/home/tim/Zotero/storage/NKH8P3HJ/Brzozowski - 1964 - Derivatives of Regular Expressions.pdf:application/pdf},
}

@article{ma_lexical_2024,
	title = {Lexical {Effect} {Handlers}, {Directly}},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3689770},
	doi = {10.1145/3689770},
	abstract = {Lexically scoping effect handlers is a language-design idea that equips algebraic effects with a modular semantics: it enables local-reasoning principles without giving up on the control-flow expressiveness that makes effect handlers powerful. However, we observe that existing implementations risk incurring costs akin to the run-time search for dynamically scoped handlers. This paper presents a compilation strategy for lexical effect handlers, adhering to the lexical scoping principle and targeting a language with low-level control over stack layout. Key aspects of this approach are formalized and proven correct. We embody the ideas in a language called Lexa: the Lexa compiler translates high-level effect handling to low-level stack switching. We evaluate the Lexa compiler on a set of benchmarks; the results suggest that it generates efficient code, reducing running-time complexity from quadratic to linear in some cases. CCS Concepts: ‚Ä¢ Software and its engineering ‚Üí Compilers; Control structures; Functional languages; Assembly languages; Formal language definitions; Concurrent programming structures; Coroutines; ‚Ä¢ Theory of computation ‚Üí Control primitives; Functional constructs; Operational semantics.},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-10-21},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Ma, Cong and Ge, Zhaoyi and Lee, Edward and Zhang, Yizhou},
	month = oct,
	year = {2024},
	pages = {1670--1698},
	file = {PDF:/home/tim/Zotero/storage/V8IPVM6G/Ma et al. - 2024 - Lexical Effect Handlers, Directly.pdf:application/pdf},
}

@book{nielson_semantics_2007,
	address = {London},
	series = {Undergraduate topics in computer science},
	title = {Semantics with applications: an appetizer},
	isbn = {978-1-84628-691-9},
	shorttitle = {Semantics with applications},
	language = {en},
	publisher = {Springer},
	author = {Nielson, Hanne Riis and Nielson, Flemming},
	year = {2007},
	note = {OCLC: ocm80332660},
	keywords = {Programming languages (Electronic computers), Semantics},
	file = {PDF:/home/tim/Zotero/storage/JC4BD9BX/Nielson and Nielson - 2007 - Semantics with applications an appetizer.pdf:application/pdf},
}

@incollection{noauthor_lambda_1984,
	title = {The {Lambda} {Calculus} - {Its} {Syntax} and {Semantics}},
	volume = {103},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	isbn = {978-0-444-87508-2},
	url = {https://linkinghub.elsevier.com/retrieve/pii/B9780444875082500381},
	language = {en},
	urldate = {2024-10-25},
	booktitle = {Studies in {Logic} and the {Foundations} of {Mathematics}},
	publisher = {Elsevier},
	year = {1984},
	doi = {10.1016/B978-0-444-87508-2.50038-1},
	pages = {611--621},
	file = {PDF:/home/tim/Zotero/storage/37IDNUIZ/1984 - Index of Symbols.pdf:application/pdf},
}

@inproceedings{ariola_call-by-need_1995,
	address = {San Francisco, California, United States},
	title = {A call-by-need lambda calculus},
	isbn = {978-0-89791-692-9},
	url = {http://portal.acm.org/citation.cfm?doid=199448.199507},
	doi = {10.1145/199448.199507},
	abstract = {The mismatch between the operational semantics of the lambda calculus and the actual behavior of implementations is a major obstacle for compiler writers. They cannot explain the behavior of their evaluator in terms of source level syntax, and they cannot easily compare distinct implementations of different lazy strategies. In this paper we derive an equational characterization of call-by-need and prove it correct with respect to the original lambda calculus. The theory is a strictly smaller theory than the lambda calculus. Immediate applications of the theory concern the correctness proofs of a number of implementation strategies, e.g., the callby-need continuation passing transformation and the realization of sharing via assignments.},
	language = {en},
	urldate = {2024-10-28},
	booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '95},
	publisher = {ACM Press},
	author = {Ariola, Zena M. and Maraist, John and Odersky, Martin and Felleisen, Matthias and Wadler, Philip},
	year = {1995},
	pages = {233--246},
	file = {PDF:/home/tim/Zotero/storage/3VCIWJWJ/Ariola et al. - 1995 - A call-by-need lambda calculus.pdf:application/pdf},
}

@inproceedings{steele_jr_debunking_1977,
	title = {Debunking the ‚Äúexpensive procedure call‚Äù myth or, procedure call implementations considered harmful or, lambda: {The} ultimate goto},
	booktitle = {Proceedings of the 1977 annual conference},
	author = {Steele Jr, Guy Lewis},
	year = {1977},
	pages = {153--162},
	file = {800179.810196:/home/tim/Zotero/storage/SDUQIIQS/800179.810196.pdf:application/pdf},
}

@book{chlipala_certified_2013,
	title = {Certified {Programming} with {Dependent} {Types}: {A} {Pragmatic} {Introduction} to the {Coq} {Proof} {Assistant}},
	copyright = {https://creativecommons.org/licenses/by-nc-nd/4.0/},
	isbn = {978-0-262-31787-0},
	shorttitle = {Certified {Programming} with {Dependent} {Types}},
	url = {https://direct.mit.edu/books/book/4021/Certified-Programming-with-Dependent-TypesA},
	abstract = {A handbook to the Coq software for writing and checking mathematical proofs, with a practical engineering focus.
            The technology of mechanized program verification can play a supporting role in many kinds of research projects in computer science, and related tools for formal proof-checking are seeing increasing adoption in mathematics and engineering. This book provides an introduction to the Coq software for writing and checking mathematical proofs. It takes a practical engineering focus throughout, emphasizing techniques that will help users to build, understand, and maintain large Coq developments and minimize the cost of code change over time.
            Two topics, rarely discussed elsewhere, are covered in detail: effective dependently typed programming (making productive use of a feature at the heart of the Coq system) and construction of domain-specific proof tactics. Almost every subject covered is also relevant to interactive computer theorem proving in general, not just program verification, demonstrated through examples of verified programs applied in many different sorts of formalizations. The book develops a unique automated proof style and applies it throughout; even experienced Coq users may benefit from reading about basic Coq concepts from this novel perspective. The book also offers a library of tactics, or programs that find proofs, designed for use with examples in the book. Readers will acquire the necessary skills to reimplement these tactics in other settings by the end of the book. All of the code appearing in the book is freely available online.},
	language = {en},
	urldate = {2024-10-31},
	publisher = {The MIT Press},
	author = {Chlipala, Adam},
	month = dec,
	year = {2013},
	doi = {10.7551/mitpress/9153.001.0001},
	file = {PDF:/home/tim/Zotero/storage/XBNUZNJY/Chlipala - 2013 - Certified Programming with Dependent Types A Pragmatic Introduction to the Coq Proof Assistant.pdf:application/pdf},
}

@article{binder_grokking_2024,
	title = {Grokking the {Sequent} {Calculus} ({Functional} {Pearl})},
	volume = {8},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3674639},
	doi = {10.1145/3674639},
	abstract = {DAVID BINDER, University of T√ºbingen, Germany MARCO TZSCHENTKE, University of T√ºbingen, Germany MARIUS M√úLLER, University of T√ºbingen, Germany KLAUS OSTERMANN, University of T√ºbingen, Germany The sequent calculus is a proof system which was designed as a more symmetric alternative to natural deduction. The ùúÜùúáùúáÀú-calculus is a term assignment system for the sequent calculus and a great foundation for compiler intermediate languages due to its first-class representation of evaluation contexts. Unfortunately, only experts of the sequent calculus can appreciate its beauty. To remedy this, we present the first introduction to the ùúÜùúáùúáÀú-calculus which is not directed at type theorists or logicians but at compiler hackers and programming-language enthusiasts. We do this by writing a compiler from a small but interesting surface language to the ùúÜùúáùúáÀú-calculus as a compiler intermediate language. CCS Concepts: ‚Ä¢ Theory of computation ‚Üí Lambda calculus; ‚Ä¢ Software and its engineering ‚Üí Compilers; Control structures.},
	language = {en},
	number = {ICFP},
	urldate = {2024-11-07},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Binder, David and Tzschentke, Marco and M√ºller, Marius and Ostermann, Klaus},
	month = aug,
	year = {2024},
	pages = {395--425},
	file = {PDF:/home/tim/Zotero/storage/SNCLZ755/Binder et al. - 2024 - Grokking the Sequent Calculus (Functional Pearl).pdf:application/pdf},
}

@article{danvy_refocusing_2004,
	title = {Refocusing in {Reduction} {Semantics}},
	volume = {11},
	issn = {1601-5355, 0909-0878},
	url = {https://tidsskrift.dk/brics/article/view/21851},
	doi = {10.7146/brics.v11i26.21851},
	abstract = {The evaluation function of a reduction semantics (i.e., a small-step operational semantics with an explicit representation of the reduction context) is canonically deÔ¨Åned as the transitive closure of (1) decomposing a term into a reduction context and a redex, (2) contracting this redex, and (3) plugging the contractum in the context. Directly implementing this evaluation function therefore yields an interpreter with a worst-case overhead, for each step, that is linear in the size of the input term.},
	language = {en},
	number = {26},
	urldate = {2024-11-08},
	journal = {BRICS Report Series},
	author = {Danvy, Olivier and Nielsen, Lasse R.},
	month = nov,
	year = {2004},
	file = {PDF:/home/tim/Zotero/storage/698W5KYR/Danvy and Nielsen - 2004 - Refocusing in Reduction Semantics.pdf:application/pdf},
}
