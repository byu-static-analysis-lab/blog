<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>BYU Static Analysis / Programming Languages Lab Blog</title>
        <link>https://byu-static-analysis-lab.github.io/blog</link>
        <description>BYU Static Analysis / Programming Languages Lab Blog</description>
        <lastBuildDate>Mon, 18 Nov 2024 12:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Paper - Database-Aware Program Optimization via Static Analysis]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization</guid>
            <pubDate>Mon, 18 Nov 2024 12:00:00 GMT</pubDate>
            <description><![CDATA[A lot of developer work on database applications goes into making sure the interaction between the application layer and the database layer is efficient. In my experience in industry, this work is mostly done manually, and in an ad-hoc fashion. [@ramachandra2014database] give an account about some ways this can be done manually.]]></description>
            <content:encoded><![CDATA[<p>A lot of developer work on database applications goes into making sure the interaction between the application layer and the database layer is efficient. In my experience in industry, this work is mostly done manually, and in an ad-hoc fashion. <span id="citation--ramachandra2014database--1">(Ramachandra and Guravannavar 2014)</span> give an account about some ways this can be done manually.</p>
<p>There are # major methods they talk about in the paper. They are as follows:</p>
<ol>
<li>Set-oriented query execution: this technique gathers multiple queries together (they specifically reference queries made in a loop) and combines them into a single query whose results can be broken up and used as if they were single queries. Their technique relies on a program transformation which breaks the loop into two loops, one of which adds the individual queries to the batch, and one which consumes the results of that batch.</li>
<li>Asynchronous Prefetching: this technique tries to move queries as early as possible in the program, so that you can overlap the network latency and computation at the database layer with the computation on the application layer. Optionally, you can batch these queries using technique 1. They also discuss ways to do prefetching in more complicated scenarios, such as when the query is made inside nested procedures.</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="kobys-thoughts">Koby's thoughts<a href="https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization#kobys-thoughts" class="hash-link" aria-label="Direct link to Koby's thoughts" title="Direct link to Koby's thoughts">​</a></h2>
<p>This paper identifies precisely the problem that I've been thinking about, which is how to optimize programs when you know things both about the program and the database schema. More generally, if you have some way to combine api calls that can reduce overhead of some kind, can we find an automated way to do so? However, the paper relies on two broad techniques to solve this: program transformations and (database-aware) compiler optimizations, both of which I see problems with.</p>
<p>While, generally speaking, program transformations may be alright, I feel that those presented in the paper, such as the loop fission technique that is at the core of almost everything they discuss, are very invasive. They would end up producing code that is difficult to read and maintain (especially if multiple devs implement separate loop fissions, leading to nested loops). The authors themselves point out that this is especially a problem when dealing with queries made in nested procedures. (On the topic of nested procedures, they don't describe the full technique, but instead refer to an earlier paper, which I am curious to read).</p>
<p>Compiler optimizations are also risky because they make implicit a very important aspect of the program, the algorithms that determine its speed. If these techniques are not universally (or nearly universally) applicable, it would be easy for an inexperienced developer to make a change that causes a serious performance regression without ever realizing. Why am I worried about this and not other compiler optimizations? My ideas are not fully formed on this yet, but I think one aspect is just how important things like network latency are to the performance of an application.</p>
<p>So an ideal technique for me would be one that leaves the code mostly intact as the developer wrote it (which, hopefully, would mean it would be more readable and maintainable), but which also has an explicit reference at some point to how the optimization is taking place. It would also be very difficult to accidentally cause a serious performance regression in the technique, or at least there would be a way to warn the developer if they have.</p>
<p>A few thoughts about where to go from here:</p>
<ol>
<li>CFA seems like a promising technique to help with the nested procedure problem, but I'd like to read more about their solution first.</li>
<li>Algebraic effects could provide a really solid way to provide for batching while still leaving a trace in the code that isn't too intrusive. However, I can't think of how you could do prefetching using algebraic effects.</li>
<li>The paper mentions that their techniques could potentially be broadened to other domains where significant overhead exists besides databases. It could be interesting to explore a technique that could generalize to all of these.</li>
</ol>
<div id="refs" class="references csl-bib-body">
  <div class="csl-entry" id="bib-ramachandra2014database">Karthik Ramachandra, and Ravindra Guravannavar. “Database-Aware Program Optimization via Static Analysis.” <i>IEEE Data Eng. Bull.</i> 37 (1). Citeseer: 60–69. 2014.</div>
</div>]]></content:encoded>
            <category>paper</category>
            <category>optimization</category>
            <category>database</category>
            <category>api coalescing</category>
        </item>
        <item>
            <title><![CDATA[Paper - A General Fine-Grained Reduction Theory for Effect Handlers]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers</guid>
            <pubDate>Fri, 08 Nov 2024 12:00:00 GMT</pubDate>
            <description><![CDATA[A General Fine-Grained Reduction Theory for Effect Handlers [@sieczkowskigeneral2023]]]></description>
            <content:encoded><![CDATA[<p>A General Fine-Grained Reduction Theory for Effect Handlers <span id="citation--sieczkowski_general_2023--1">(Sieczkowski et al. 2023)</span>
presents a theory of effect handlers that can be used for term rewriting systems,
and provides a few different abstract machines for effect handlers.</p>
<p>A significant contribution of this paper I believe is that it provides
a top down small-step semantics for effect handlers, which is a bit unusual.</p>
<p>One disadvantages of most reduction semantics for effect handlers is that
they require being able to capture a reduction context itself as a term in the language.
This is easy to understand in principle, but makes the reduction semantics
hard to translate into an abstract machine.</p>
<p>The fine-grained reduction theory presented in this paper makes it easy to apply the
normal refocusing method to come up with an abstract machine for algebraic effects (see <a href="https://byu-static-analysis-lab.github.io/blog/refocusing-reduction">this paper</a>).</p>
<p>The crux of the idea is that continuations can either be built from the top-down or the bottom-up.</p>
<p>Typical reduction semantics for algebraic effects capture the reduction context and wrap it in a closure to plug the context. This is effectively a bottom-up approach.</p>
<p>For example in Generalized Evidence Passing for Effect Handlers <span id="citation--xie_generalized_2021--2">(Xie and Leijen 2021)</span>,
Koka's evaluation rules look as follows:</p>
<span class="katex-display fleqn"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>p</mi><mi>p</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mi>e</mi><mo stretchy="false">)</mo><mi>v</mi><mo>⟶</mo><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>v</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>l</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext mathvariant="monospace">handler</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>f</mi><mo>⟶</mo><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext>  </mtext><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>v</mi><mo>⟶</mo><mi>v</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>e</mi><mi>r</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>E</mi><mo stretchy="false">[</mo><mtext mathvariant="monospace">perform</mtext><mtext>  </mtext><mi>o</mi><mi>p</mi><mtext>  </mtext><mi>v</mi><mo stretchy="false">]</mo><mo>⟶</mo><mi>f</mi><mtext>  </mtext><mi>v</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>E</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mtext>  </mtext><mtext mathvariant="monospace">iff</mtext><mtext>  </mtext><mi>o</mi><mi>p</mi><mo mathvariant="normal">∉</mo><mi>b</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>o</mi><mi>p</mi><mo>⟼</mo><mi>f</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>h</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
(app)\;\; &amp;(λx.\; e) v ⟶ e[x:=v]  \\
(handler)\;\; &amp;\texttt{handler}\; h\; f ⟶ \texttt{handle}\; h\; (f\; ()) \\
(return)\;\; &amp;\texttt{handle}\; h\; v ⟶ v  \\
(perform)\;\; &amp;\texttt{handle}\; h\; E[\texttt{perform}\; op\; v] ⟶ 
  f\; v\; (λx.\; \texttt{handle}\; h\; E[x])\; \texttt{iff}\; op \notin bop(E) ∧ (op ⟼ f)  \in h
\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em"><span style="top:-5.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">pp</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">han</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal" style="margin-right:0.02778em">er</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span><span style="top:-2.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span><span style="top:-0.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em">er</span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mord mathnormal" style="margin-right:0.02778em">or</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em"><span style="top:-5.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mclose">]</span></span></span><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord texttt">handler</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mopen">(</span><span class="mclose">))</span></span></span><span style="top:-2.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span><span style="top:-0.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mopen">[</span><span class="mord text"><span class="mord texttt">perform</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord text"><span class="mord texttt">iff</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟼</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>In this we can see the caputring of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span></span></span></span> and wrapping up in a lambda to build the continuation.
Additionally we see the nature of <code>deep</code> effect handlers where the continuation reinstates
the handler frame on top of the evaluation context.</p>
<p>While later in the Koka paper they present a monad for building up the continuation piece by piece, this is still a bottom-up treatment and composition of elementary evaluation contexts.</p>
<p>Instead the top down treatment presented in this paper, builds the continuation on the way down, and only uses lambda functions.</p>
<p>The abstract machine presented in the paper is pretty straightforward, though as mentioned in the paper it is a <code>hybrid</code> machine because the context changes how evaluation proceeds. In particular
evaluation changes depending on whether it is in the context of one or more handlers, versus if it is finishing up a computation in the top level continuation.</p>
<p>Later they introduce a similarity relation to equate terms in the fine-grained calculus and a normal calculus. This part is pretty involved since the rewriting of handlers in the fine-grained calculus ends up changing a lot of terms, and the capturing of a resumption in the regular calculus introduces an eta expansion for the application.</p>
<p>Next they present three core proofs: Simulation, Confluence, and Standardization.</p>
<p>Simulation states that it doesn't matter whether you use the fine-grained or non-local semantics you get the same result. i.e. fine-grained simulates non-local and vice versa. One step in one either could correspond to many steps in the other, so you have to consider the transitive closure. Additionally the similarity relation is needed since the terms could look different but be syntactically or otherwise equivalent.</p>
<p>Confluence of the relation is the diamond property meaning that if an expression reduces to two different expressions, then there exists an expression that each of those expressions can reduce further to.</p>
<p>Standardization states the any reduction sequence that reaches head-normal form can be split into a sequence that reaches a normal form followed by an internal reduction sequence. This is tricky with effect handlers due to the hybrid nature of the semantics in which let and lift behave differently depending if a handler surrounds them.</p>
<p>Using those proofs they show that the reduction theory is a foundation for an equational theory which is sound with respect to the non-local semantics. In other words, rewriting pieces of programs using this theory will result in the same program, even if you switch back to a non-local semantics to execute the rest.</p>
<div id="refs" class="references csl-bib-body">
  <div class="csl-entry" id="bib-sieczkowski_general_2023">Filip Sieczkowski, Mateusz Pyzik, and Dariusz Biernacki. “A General Fine-Grained Reduction Theory for Effect Handlers.” <i>Proceedings of the ACM on Programming Languages</i> 7 (ICFP): 511–540. 2023. Publisher: ACM New York, NY, USA.</div>
  <div class="csl-entry" id="bib-xie_generalized_2021">Ningning Xie, and Daan Leijen. “Generalized Evidence Passing for Effect Handlers.” <i>Microsoft Research. Extended Version with Proofs</i>. 2021.</div>
</div>]]></content:encoded>
            <category>paper</category>
            <category>abstract interpreters</category>
            <category>reduction semantics</category>
            <category>effect handlers</category>
            <category>abstract machine</category>
        </item>
        <item>
            <title><![CDATA[Paper - Refocusing in Reduction Semantics]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/refocusing-reduction</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/refocusing-reduction</guid>
            <pubDate>Fri, 08 Nov 2024 12:00:00 GMT</pubDate>
            <description><![CDATA[Refocusing in Reduction Semantics [@danvyrefocusing2004] presents a way to go from]]></description>
            <content:encoded><![CDATA[<p>Refocusing in Reduction Semantics <span id="citation--danvy_refocusing_2004--1">(Danvy and Nielsen Nov. 2004)</span> presents a way to go from
a reduction semantics to an refocused pre-abstract machine, and eventually to an abstract machine. The paper is a good read after being introduced to reduction semantics and abstract machines, and has a few simple walkthroughs of how to actually apply the theory.</p>
<p>The goal of this paper is to systematize the development of abstract machines based on
a reduction semantics.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reduction-semantics">Reduction Semantics<a href="https://byu-static-analysis-lab.github.io/blog/refocusing-reduction#reduction-semantics" class="hash-link" aria-label="Direct link to Reduction Semantics" title="Direct link to Reduction Semantics">​</a></h3>
<p>Reduction semantics involve three distinct steps:</p>
<ul>
<li><code>decompose</code>: rules for breaking apart expressions into a term that can be reduced and its surrounding evaluation contexts (aka reduction contexts)</li>
<li><code>reduction</code> / <code>contraction</code>: rules for how a term should be reduced</li>
<li><code>plug</code>: rules for how to recompose a full program expression given an evaluation context and a term</li>
</ul>
<p>In reduction semantics some terms are considered fully reduced (values), and others can be decomposed. In general a term can be decomposed in many ways, however</p>
<p>Often reduction semantics satisfy the property that there is a unique <em>complete</em> decomposition. A decomposition is <em>complete</em> iff the term it decomposes into a term that is trivially reducible (not a value, and not itself containing a complete decomposition). For example, the call-by-value simple lambda calculus semantics has the following reduction contexts</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>:</mo><mo>:</mo><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo>∣</mo><mi>a</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>∣</mo><mi>a</mi><mi>p</mi><mi>p</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C ::= [] \mid app(C,t) \mid app(v,C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">::=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">pp</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">pp</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mclose">)</span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span></span></span></span> denotes a reduction context, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span></span></span></span> a term, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span> a value, with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> being a hole.</p>
<p>Crucially the restriction on the first term of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>p</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">app</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">pp</span></span></span></span> being either an evaluation context, or a value makes this decomposition unique and specifies a left-to-right evaluation order.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="deriving-an-abstract-machine">Deriving An Abstract Machine<a href="https://byu-static-analysis-lab.github.io/blog/refocusing-reduction#deriving-an-abstract-machine" class="hash-link" aria-label="Direct link to Deriving An Abstract Machine" title="Direct link to Deriving An Abstract Machine">​</a></h3>
<p>Given this property, the paper shows how to derive an abstract machine from it.</p>
<p>Intuitively, instead of finding the decomposition and replugging after every step, we can
instead traverse the reduction contexts of the previous decomposition to find the next
reduction step and recompose the evaluation contexts to obtain the new evaluation context.
In this way we can merge all intermediate steps of <code>plug</code> followed by <code>reduction</code>. The paper
calls this the <code>refocus</code> step.</p>
<p>After merging <code>plug</code> and <code>reduction</code>, the only thing that we need to get rid of is to inline the <code>refocus</code> step itself to get a properly tail recursive abstract machine.</p>
<p>Of course the paper goes into more detail, and considers two separate <code>refocus</code> functions, one
which applies when the expression reduces to another potential redux, and another when it reduces to a value.
After inlining both, the differences don't exactly matter, since they are now just part of the machine transitions.
However, it is useful to understand how the machine is derived, since you don't always have an abstract machine, but do know how to select the next statement to reduce.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="https://byu-static-analysis-lab.github.io/blog/refocusing-reduction#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2>
<p>The conclusion of the paper states:</p>
<blockquote>
<p>We have presented a structural result about reduction semantics with context-free grammars of values, reduction contexts, and redexes, and satisfying a unique-decomposition property. These conditions are quite general: they hold for deterministic languages and also for oracle-based non-deterministic languages.</p>
</blockquote>
<p>I appreciate the examples that they showed to make this claim more concrete - instead of solely in terms of context-free grammars, but it is nice to know that there is very little syntactic restrictions, and that the conditions for applying it are rather general.</p>
<blockquote>
<p>The construction of the refocus function suggests a convenient definition of the decompose function that directly connects one-step reduction and evaluation in the form of an abstract machine. It also suggests a practical method to obtain a reduction semantics out of an abstract machine.</p>
</blockquote>
<p>I wish they spent more time connecting this - how to go in the reverse direction. It is also interesting that they don't talk about the restriction to <code>one-step</code> reductions. Is that a restriction only going in the reverse, or is it a restriction in the forward direction as well.</p>
<div class="theme-admonition theme-admonition-note admonition_xJq3 alert alert--secondary"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_BuS1"><p>A many step strategy is apparently one in which a whole set of redexes is contracted simultaneously</p><p>As such, the restriction makes sense and I believe applies in both directions. What would an abstract machine that performs multiple steps simultaneously even look like?</p></div></div>
<div id="refs" class="references csl-bib-body">
  <div class="csl-entry" id="bib-danvy_refocusing_2004">Olivier Danvy, and Lasse R. Nielsen. “Refocusing in Reduction Semantics.” <i>BRICS Report Series</i> 11 (26). Nov. 2004. doi:10.7146/brics.v11i26.21851.</div>
</div>]]></content:encoded>
            <category>paper</category>
            <category>abstract interpreters</category>
            <category>reduction semantics</category>
        </item>
        <item>
            <title><![CDATA[Topic - Flow Sensitivity]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/flow-sensitivity</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/flow-sensitivity</guid>
            <pubDate>Thu, 07 Nov 2024 19:17:45 GMT</pubDate>
            <description><![CDATA[There are (at least) three different "sensitivities" an abstract analysis can have:]]></description>
            <content:encoded><![CDATA[<p>There are (at least) three different "sensitivities" an <a href="https://byu-static-analysis-lab.github.io/blog/abstract-interpretation">abstract analysis</a> can have:</p>
<ul>
<li>flow insensitive</li>
<li>flow sensitive</li>
<li>path sensitive</li>
</ul>
<p>This article briefly describes the difference between them.</p>
<p>One form of abstract analysis is a type check.</p>
<p>Consider this typescript program:</p>
<div class="language-ts codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-ts codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">function</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">myFunc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">x </span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> </span><span class="token builtin" style="color:rgb(130, 170, 255)">string</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain"> </span><span class="token builtin" style="color:rgb(130, 170, 255)">number</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">let</span><span class="token plain"> y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">x </span><span class="token operator" style="color:rgb(137, 221, 255)">===</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    y </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// a</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    y </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">"some string"</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// b</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">x </span><span class="token operator" style="color:rgb(137, 221, 255)">===</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin" style="color:rgb(130, 170, 255)">console</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token function" style="color:rgb(130, 170, 255)">log</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// c</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token builtin" style="color:rgb(130, 170, 255)">console</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token function" style="color:rgb(130, 170, 255)">log</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">y </span><span class="token operator" style="color:rgb(137, 221, 255)">+</span><span class="token plain"> y</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// d</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>What is the type of <code>x</code> at point <code>a</code> in the program? Many type checkers would simply report <code>string | number</code>, but TypeScript's type checker is smart enough to know that it is <code>number</code> here, based on the check <code>x === 0</code>, which can only be true if <code>x</code> is a number. This is because TypeScript's type checker is <em>flow sensitive</em>, while many other type checkers are <em>flow insensitive</em>.</p>
<p>Now, what is the type of <code>y</code> at point <code>c</code> in the program? We can inspect it and know that if we got to point <code>c</code>, then <code>x === 0</code> is true, and earlier we must have gone through point <code>a</code>. This means that <code>y</code> must be <code>number</code>, since it was assigned <code>0</code>. However, TypeScript still just reports <code>number | string</code>. This is because, TypeScript's type checker is <em>not</em> path-sensitive. Our analysis that we did manually <em>was</em> path-sensitive.</p>
<p>So, in order of specificity, we have flow-insensitive &lt; flow-sensitive &lt; path-sensitive. Flow-insensitive analyses collect facts that are true at any point in the program. It is always true to say that <code>x : string | number</code> and <code>y : string | number</code>. Flow-sensitive analyses associate facts with particular points in the program, but do not distinguish how you got there. At point <code>c</code> in the program, it is always true to say that <code>x : number</code> and <code>y : string | number</code> (we can't say anything more specific about <code>y</code> because we don't know if we went through point <code>a</code> or <code>b</code>). Path-sensitivity associates facts with points in the program <em>and how you got there</em>, or "path". It is always true to say that at point <code>c</code>, given you went through point <code>a</code>, that <code>x : number</code> and <code>y : number</code>, and there are no flows that reach point <code>c</code> except those that also previously reach <code>a</code>.</p>]]></content:encoded>
            <category>static analysis</category>
            <category>flow analysis</category>
            <category>abstract interpretation</category>
        </item>
        <item>
            <title><![CDATA[Topic - Abstract Interpretation]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/abstract-interpretation</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/abstract-interpretation</guid>
            <pubDate>Thu, 07 Nov 2024 12:00:00 GMT</pubDate>
            <description><![CDATA[Abstract interpretation is a very common technique for analyzing programs. This is a quick primer on the topic.]]></description>
            <content:encoded><![CDATA[<p>Abstract interpretation is a very common technique for analyzing programs. This is a quick primer on the topic.</p>
<p>The core idea of an abstract interpretation is to "run the program", but instead of typical program states/values/etc (sometimes referred to collectively as configurations), we use some replacement that means the execution is decidable (the program always terminates).</p>
<p>Probably the single most common automated analysis is a type check, which is itself a form of abstract analysis. Throughout this primer, we'll use a simply typed lambda calculus, extended with <code>nat</code>, <code>if0</code>, and <code>letrec</code>. Execution will be done via the standard syntax-based transition system with replacement for function application (no environment or store).</p>
<p>In abstract interpretion, the convention is to write the concrete types with their normal notation, and the abstract versions with the normal notation with a hat. In our example, we have the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>, which is the type of the result of running the program, and can either be a value in <code>nat</code>, or a closure. We also have type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span>, which is the result of running the type check. But in the typical abstract interpretation, we would write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{Value}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9944em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span><span class="svg-align" style="top:-3.6944em"><span class="pstrut" style="height:3em"></span><span style="height:0.3em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.3em" viewBox="0 0 2364 360" preserveAspectRatio="none"><path d="M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z"></path></svg></span></span></span></span></span></span></span></span></span>. To familiarize us with this notation, I will use the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{Value}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9944em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span><span class="svg-align" style="top:-3.6944em"><span class="pstrut" style="height:3em"></span><span style="height:0.3em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.3em" viewBox="0 0 2364 360" preserveAspectRatio="none"><path d="M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z"></path></svg></span></span></span></span></span></span></span></span></span> notation, but know that it is the same as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Type</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span>.</p>
<p>Now, we have two domains, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{Value}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9944em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span><span class="svg-align" style="top:-3.6944em"><span class="pstrut" style="height:3em"></span><span style="height:0.3em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.3em" viewBox="0 0 2364 360" preserveAspectRatio="none"><path d="M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z"></path></svg></span></span></span></span></span></span></span></span></span>, but for our analysis to be useful, we need some way to relate them. Often, the way that we do this is having a couple of functions that translate between the two domains. A common way to notate these is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span></span></span></span> (stands for "abstract") and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span></span></span></span> (stands for concretize). In our case, we could have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>→</mo><mover accent="true"><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\alpha : Value \rightarrow \widehat{Value}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9944em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span><span class="svg-align" style="top:-3.6944em"><span class="pstrut" style="height:3em"></span><span style="height:0.3em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.3em" viewBox="0 0 2364 360" preserveAspectRatio="none"><path d="M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z"></path></svg></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>:</mo><mover accent="true"><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><mo stretchy="true">^</mo></mover><mo>→</mo><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\gamma : \widehat{Value} \rightarrow \mathcal{P}(Value)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9944em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span><span class="svg-align" style="top:-3.6944em"><span class="pstrut" style="height:3em"></span><span style="height:0.3em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.3em" viewBox="0 0 2364 360" preserveAspectRatio="none"><path d="M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathcal" style="margin-right:0.08222em">P</span><span class="mopen">(</span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>. Note that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span></span></span></span>'s return type is a powerset, since there are any number of values in a given type.</p>
<p>Once we have one or both of these functions, we can write theorems that relate elements of the two domains. After running the abstract analysis and get a result in the abstract domain, then we can say something about the concrete execution of the program. If we can prove the analysis is sound, then the result of the abstract interpreter tells us something trustworthy about what the concrete analysis will look like.</p>
<p>Take the program</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">((lambda x. if0 x then 1 else 2 end) 0)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>We can just interpret this program and know that the result will be <code>1</code>, which is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span></span>. But in general, because we have <code>letrec</code> in our language, just interpretting and finding the result might not terminate, and in any case might take a very long time. A type check would be much faster. If you've taken CS 330 at BYU, you probably noticed that the <code>typecheck</code> function looks very similar to the <code>interp</code> function. One difference is the types they return (<code>Value</code> vs <code>Type</code>), but the more important one is that we know <code>typecheck</code> will always terminate, and is much faster.</p>
<p>Running a type check on this program produces <code>nat</code>, which is in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{Value}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9944em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span></span></span><span class="svg-align" style="top:-3.6944em"><span class="pstrut" style="height:3em"></span><span style="height:0.3em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.3em" viewBox="0 0 2364 360" preserveAspectRatio="none"><path d="M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z"></path></svg></span></span></span></span></span></span></span></span></span>. While this is not nearly as specific as <code>1</code>, it does tell us something! We can use <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>γ</mi><mtext> </mtext><mi>n</mi><mi>a</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\gamma \, nat)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">na</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> to return a set of all of the possibilities our program <em>could</em> return, based on our analysis. In this case, we know that it could be any natural number, and that it definitely isn't a closure.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="generalizing">Generalizing<a href="https://byu-static-analysis-lab.github.io/blog/abstract-interpretation#generalizing" class="hash-link" aria-label="Direct link to Generalizing" title="Direct link to Generalizing">​</a></h2>
<p>In our type check example, our abstract domain was related to the values returned by our program, but in general, there are all kinds of domains we could be concerned with. For instance, if our language has a store, we could have an abstract store that has only finitely many addresses. The key is that whatever abstraction you use, you can prove that that abstraction makes your interpretation decidable.</p>]]></content:encoded>
            <category>static analysis</category>
            <category>abstract interpretation</category>
        </item>
        <item>
            <title><![CDATA[Paper - Galois Transformers and Modular Abstract Interpreters]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/galois-transformers</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/galois-transformers</guid>
            <pubDate>Thu, 07 Nov 2024 12:00:00 GMT</pubDate>
            <description><![CDATA[Galois Transformers and Modular Abstract Interpreters [@daraisgalois2015] provides a way to do abstract interpretation in general, without having to specify a particular language or analysis. This paper is fairly mathematically dense, so I'll do my best to break down what I understood from it. This paper is also a good starting point if you want to understand Dr. Germane's paper on Full Control-Flow Sensitivity.]]></description>
            <content:encoded><![CDATA[<p>Galois Transformers and Modular Abstract Interpreters <span id="citation--darais_galois_2015--1">(Darais et al. 2015)</span> provides a way to do abstract interpretation <em>in general</em>, without having to specify a particular language or analysis. This paper is fairly mathematically dense, so I'll do my best to break down what I understood from it. This paper is also a good starting point if you want to understand Dr. Germane's paper on Full Control-Flow Sensitivity.</p>
<p>Ultimately, the goal of the paper is basically to have some function (let's call it <code>run_analysis</code>), that can be passed a collection of parameters that specify the language on which to run an analysis, as well as what analysis should be run. The coolest thing in my mind is that they were able to do this in such a way that as long as you can prove a couple of properties about the arguments you pass to <code>run_analysis</code>, the soundness of the analysis is given to you for free.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="breaking-down-the-abstract">Breaking Down the Abstract<a href="https://byu-static-analysis-lab.github.io/blog/galois-transformers#breaking-down-the-abstract" class="hash-link" aria-label="Direct link to Breaking Down the Abstract" title="Direct link to Breaking Down the Abstract">​</a></h2>
<p>I think a good way to understand what is going on in this paper will be to break down the abstract and understand each of its claims.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-problem-statement">The Problem Statement<a href="https://byu-static-analysis-lab.github.io/blog/galois-transformers#the-problem-statement" class="hash-link" aria-label="Direct link to The Problem Statement" title="Direct link to The Problem Statement">​</a></h3>
<blockquote>
<p>The design and implementation of static analyzers has become increasingly systematic. Yet for a given language or analysis feature, it often requires tedious and error prone work to implement an analyzer and prove it sound. In short, static analysis features and their proofs of soundness do not compose well, causing a dearth of reuse in both implementation and metatheory.</p>
</blockquote>
<p>This part is fairly self explanatory. The authors identified a classic software engineering problem: we're repeating ourselves a lot when we write up analyzers and their proofs. Is there some way we can take the parts that get repeated and abstract them out, parameterized on the portions that actually are different between different analyses?</p>
<p>Now would probably be a good time to note that the paper uses the word "abstract" in a couple of different ways. One of them is the traditional programming sense, that means something like "generalize". If we're repeating ourselves, let's separate out the portions that are repeated from the portions that are different. The other way it uses abstract is in the term "abstract interpreter". See <a href="https://byu-static-analysis-lab.github.io/blog/abstract-interpretation">abstract interpretation</a> for more information on what that means, if you're unfamiliar with the concept.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="solution">Solution<a href="https://byu-static-analysis-lab.github.io/blog/galois-transformers#solution" class="hash-link" aria-label="Direct link to Solution" title="Direct link to Solution">​</a></h3>
<blockquote>
<p>We solve the problem of systematically constructing static analyzers by introducing Galois transformers: monad transformers that transport Galois connection properties.</p>
</blockquote>
<p>"Systematically constructing" here just means that they have an algorithm for combining the parameters (the language and analysis properties) to produce an analysis that is always sound, i.e. the <code>run_analysis</code> function is defined in the paper.</p>
<p>"Galois transformers" are (as the title suggests) the biggest new concept of the paper. They are defined as "monad transformers that transport Galois connection properties". Monad transformers are a special kind of function that take in a monad and produce a different monad, preserving the monad laws. The reason that we care about them is they allow us to essentially "stack" monads. For instance, there is a State Monad Transformer called <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">S^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7936em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span> (monad transformers are usually written with some symbol followed by a superscript <code>t</code>). When <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">S^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7936em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span> is applied to a different monad (say, the <code>Option</code> monad), it "adds" the state effect to the monad. You can then chain these to combine effects in a highly composable way.</p>
<p>"Galois connection properties" is a whole topic in and of itself that I may write an article on at some point. The TL;DR here though (as far as I understand it) is that if you have two sets, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9233em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9233em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="width:calc(100% - 0.2778em);margin-left:0.2778em;top:-3.6833em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span></span></span></span>, and a "Galois connection" between them, there is a sort of mapping between them. This mapping is used in several different ways in the paper, which I'll get into a little more later on. For now, here is a more formal definition of Galois connections. Given two partial orders, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mo>≤</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, \leq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≤</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mover accent="true"><mi>A</mi><mo stretchy="true">^</mo></mover><mo separator="true">,</mo><mo>⊑</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\widehat{A}, \sqsubseteq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1733em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9233em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="width:calc(100% - 0.2778em);margin-left:0.2778em;top:-3.6833em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊑</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mclose">)</span></span></span></span>, and functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>:</mo><mi>A</mi><mo>→</mo><mover accent="true"><mi>A</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\alpha : A \rightarrow \widehat{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9233em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9233em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="width:calc(100% - 0.2778em);margin-left:0.2778em;top:-3.6833em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>:</mo><mover accent="true"><mi>A</mi><mo stretchy="true">^</mo></mover><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\gamma : \widehat{A} \rightarrow A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9233em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9233em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="width:calc(100% - 0.2778em);margin-left:0.2778em;top:-3.6833em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span> for converting between them, then there is a Galois connection between them if for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover><mo>∈</mo><mover accent="true"><mi>A</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{a} \in \widehat{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7097em;vertical-align:-0.0391em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6706em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">a</span></span><span class="svg-align" style="top:-3.4306em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9233em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9233em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="width:calc(100% - 0.2778em);margin-left:0.2778em;top:-3.6833em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mo stretchy="false">(</mo><mi>γ</mi><mtext> </mtext><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover><mo stretchy="false">)</mo><mo>⇔</mo><mo stretchy="false">(</mo><mi>α</mi><mtext> </mtext><mi>a</mi><mo stretchy="false">)</mo><mo>⊑</mo><mover accent="true"><mi>a</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">a \leq (\gamma \, \widehat{a}) \Leftrightarrow (\alpha \, a) \sqsubseteq \widehat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6706em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">a</span></span><span class="svg-align" style="top:-3.4306em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⊑</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6706em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6706em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">a</span></span><span class="svg-align" style="top:-3.4306em"><span class="pstrut" style="height:3em"></span><span style="height:0.24em"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none"><path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path></svg></span></span></span></span></span></span></span></span></span>. Note that the names here are suggestive of concrete and abstract domains, but Galois connections aren't specific to abstract interpretation. Intuitively, this definition means that there is a way to convert between the two sets that preserves the partial order.</p>
<p>There are two ways the paper uses Galois connections. One of them is to formalize the correspondence between concrete and abstract domains. See <a href="https://byu-static-analysis-lab.github.io/blog/abstract-interpretation">abstract interpretation</a> for more details of what that means. The other has to do with how they define "running" the analysis. The paper defines a "monadic interpreter", which takes an expression of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>x</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">Exp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span></span></span></span> and returns an expression wrapped in a monad <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>E</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(Exp)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>. The monad in this case is specific to the particular language and analysis. For reasons that I don't fully understand yet, they state that this monadic function "cannot be iterated to least-fixed-point to execute the analysis." Instead, they define a transition system that defines a step relation between configurations of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Σ</span></span></span></span>. They then prove a Galois connection between this relation, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>→</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma \rightarrow \Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Σ</span></span></span></span> and the monadic function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>x</mi><mi>p</mi><mo>→</mo><mi>m</mi><mo stretchy="false">(</mo><mi>E</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Exp \rightarrow m(Exp)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span>. The transition system <em>can</em> be used in a least-fixed-point computation. The takeaway seems to be that this allows them to define a concept of execution, even though at first that seems tricky.</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Tim</div><div class="admonitionContent_BuS1"><p>I believe the answer to your question is as follows:</p><p>The monadic function "cannot be iterated to least-fixed-point to execute the analysis" because the monad itself only maps expressions to monadic values.
We need the monad to correspond to a transition system where we can reify the configuration <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Σ</span></span></span></span> (whose components are implicit and modularized in the monad) in such a way that we can see if a particular <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Σ</span></span></span></span> has already been visited. That way we can iterate to a fixed-point by collecting all configurations that have already been seen, and running unseen configurations through the monad to get another set of states.</p><p>Without this connection, we wouldn't know which configurations still need to be run, and which configurations have been produced by the monad.</p><p>Abstracting definitional interpreters <span id="citation--darais_abstracting_2017--2">(Darais et al. 2017)</span> shows how you can reify the configurations within the monad and iterate to a fixed-point using another nondeterminism monad and cache.
That paper also does the analysis in big-step style.
This paper however, limits the nondeterminism monad to the inherent nondeterminism due to the abstract domains.</p></div></div>
<p>Now for the key part: they show that there are certain monad transformers (which they call "Galois transformers") that, when applied, preserve the Galois connections of the monads they are applied to. This is a critical step in what they are trying to accomplish, because it now means that if you apply a series of Galois transformers, as long as your original monad was sound and each Galois transformer was sound, they result is also sound by construction. The proofs compose!</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="accomplishments">Accomplishments<a href="https://byu-static-analysis-lab.github.io/blog/galois-transformers#accomplishments" class="hash-link" aria-label="Direct link to Accomplishments" title="Direct link to Accomplishments">​</a></h3>
<blockquote>
<p>In concert with a monadic interpreter, we define a library of monad transformers that implement building blocks for classic analysis parameters like context, path, and heap (in)sensitivity.</p>
</blockquote>
<p>They also define a few arguments that can be passed to our hypothetical <code>run_analysis</code> function. These define things like state and nondeterminism effects for a language, as well as parameterizing the analysis based on <a href="https://byu-static-analysis-lab.github.io/blog/flow-sensitivity">sensitivity</a>.</p>
<blockquote>
<p>Moreover, these can be composed together independent of the language being analyzed.
Significantly, a Galois transformer can be proved sound once and for all, making it a reusable analysis component. As new analysis features and abstractions are developed and mixed in, soundness proofs need not be reconstructed, as the composition of a monad transformer stack is sound by virtue of its constituents. Galois transformers provide a viable foundation for reusable and composable metatheory for program analysis.</p>
</blockquote>
<p>These statements summarize what we've been talking about with the fact that the proofs compose nicely.</p>
<blockquote>
<p>Finally, these Galois transformers shift the level of abstraction in analysis design and implementation to a level where non-specialists have the ability to synthesize sound analyzers over a number of parameters.</p>
</blockquote>
<p>Finally, they make the assertion that, since the individual pieces are so easily composable, someone who is not familiar with the mathematical foundations of program analysis could still create an analyzer, as long as they were given the building blocks. This is a pretty cool assertion, although I'm not sure they really justify it much.</p>
<div id="refs" class="references csl-bib-body">
  <div class="csl-entry" id="bib-darais_abstracting_2017">David Darais, Nicholas Labich, Phúc C Nguyen, and David Van Horn. “Abstracting Definitional Interpreters (Functional Pearl).” <i>Proceedings of the ACM on Programming Languages</i> 1 (ICFP): 1–25. 2017. Publisher: ACM New York, NY, USA.</div>
  <div class="csl-entry" id="bib-darais_galois_2015">David Darais, Matthew Might, and David Van Horn. “Galois Transformers and Modular Abstract Interpreters: Reusable Metatheory for Program Analysis.” <i>ACM SIGPLAN Notices</i> 50 (10): 552–571. 2015. Publisher: ACM New York, NY, USA.</div>
</div>]]></content:encoded>
            <category>paper</category>
            <category>galois connections</category>
            <category>monad transformers</category>
            <category>abstract interpreters</category>
        </item>
        <item>
            <title><![CDATA[Paper - Abstracting Abstract Machines]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/abstracting-abstract-machines</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/abstracting-abstract-machines</guid>
            <pubDate>Wed, 06 Nov 2024 12:00:00 GMT</pubDate>
            <description><![CDATA[The Abstracting Abstract Machines [@vanhornabstracting_2010] paper]]></description>
            <content:encoded><![CDATA[<p>The Abstracting Abstract Machines <span id="citation--van_horn_abstracting_2010--1">(Van Horn and Might 2010)</span> paper
is frequently cited due to its presentation of a methodological process of
abstracting a small-step abstract machine for analysis.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="tim---learnings--thoughts">Tim - Learnings / Thoughts<a href="https://byu-static-analysis-lab.github.io/blog/abstracting-abstract-machines#tim---learnings--thoughts" class="hash-link" aria-label="Direct link to Tim - Learnings / Thoughts" title="Direct link to Tim - Learnings / Thoughts">​</a></h2>
<p>TODO</p>
<div id="refs" class="references csl-bib-body">
  <div class="csl-entry" id="bib-van_horn_abstracting_2010">David Van Horn, and Matthew Might. “Abstracting Abstract Machines.” In <i>Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming</i>, 51–62. 2010.</div>
</div>]]></content:encoded>
            <category>paper</category>
            <category>control flow analysis</category>
        </item>
        <item>
            <title><![CDATA[Topic - Control Flow Analysis]]></title>
            <link>https://byu-static-analysis-lab.github.io/blog/control-flow-analysis</link>
            <guid>https://byu-static-analysis-lab.github.io/blog/control-flow-analysis</guid>
            <pubDate>Wed, 06 Nov 2024 12:00:00 GMT</pubDate>
            <description><![CDATA[This is a Blog for the BYU Static Analysis Lab]]></description>
            <content:encoded><![CDATA[<p>This is a Blog for the BYU Static Analysis Lab</p>
<p>Dr. Kimball Germane is our advisor at BYU. <a href="https://kimball.germane.net/" target="_blank" rel="noopener noreferrer">https://kimball.germane.net/</a></p>
<p>He has a lot of experience with static analysis, and especially with making control flow analysis practical for real world use.</p>
<p>In this blog post we will introduce static analysis from a few different perspectives.</p>
<p>Click (Read More) below to read the rest of the post.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="tims-thoughts-on-static-control-flow-analysis">Tim's Thoughts on Static Control Flow Analysis<a href="https://byu-static-analysis-lab.github.io/blog/control-flow-analysis#tims-thoughts-on-static-control-flow-analysis" class="hash-link" aria-label="Direct link to Tim's Thoughts on Static Control Flow Analysis" title="Direct link to Tim's Thoughts on Static Control Flow Analysis">​</a></h2>
<p><strong>Static analysis</strong> is a way to analyze properties about a program without running it. Some properties of a program are restricted by the type system, but
often you want to know a bit more about the program than a type system can tell you. For example, you might want to know if an integer is always positive, or if a function never throws an exception.</p>
<p>While some of these properties can be determined by a more restrictive type system, there is always a tradeoff when you make a type system more restrictive. The more restrictive a type system is, the more difficult it is to write programs that may be valid, but don't fit the type system. On the other hand, some type systems are super expressive allowing the programmer to express rich types where types can depend on values (see <a href="https://www.idris-lang.org/" target="_blank" rel="noopener noreferrer">Idris</a> for an example). Both by making a type system more restrictive and by making it more expressive, you completely change the developer experience which can make it much easier or much harder to write programs.</p>
<p>Even with an expressive type system, there are still properties that are interesting to a compiler that the type system is unlikely to help you with. A common example is inlining. Inlining functions can be very beneficial to runtime performance – it can save you the overhead of a function call (though the overhead can be minimal depending on the language you use). Additionally, in the case of higher order functions such as closures, it can save you de/allocation of the closure. Another example of a property that is useful, but not typically expressed in type systems are security properties such as ensuring that secrets within a program are not leaked, and that the program doesn't accept any input from the user that could compromise the program.</p>
<p><strong>Flow analysis</strong> is one way of solving many static analysis questions. Essentially the common questions that we ask is about what values can flow to which points in the program. Due to infinite loops, and arbitrary run-time input, we cannot just interpret the program while logging all values of each variable. Instead we really want to know all possible ways the program can execute given <em>any</em> input or path through the program. This is a very difficult problem, and in general is undecidable. However, there are many cases where we can get a good approximation of the answer, and that is what we are interested in. There are many ways of approximating the solution to this problem, but what we are interested in is a <em>sound</em> solution. For the solution to be <em>sound</em> it means that we need to consider all possible executions of the program. Because it is an approximation we can either underestimate all possible executions (leaving out some possibilities) or overestimate all possible executions (including some possibilities that are in reality not possible). We are interested in the latter case, because we want to be sure that we are not missing any possible execution paths. If we don't consider all possible executions that could mean that our analysis is <em>unsound</em>, for example it might say that a value is always positive, when in reality it could be negative. You could imagine that it might be useful to know when something has to happen, in which case you would want a <em>complete</em> analysis. A complete analysis guarantees that if it says something happens then it really does. Soundness and completeness are not opposites, but they are both useful properties to think about when discussing formal reasoning systems.
Flow analysis starts with a sound analysis and much of the research focuses on how to make the analyses more <em>precise</em> (complete).</p>
<p>However just following where simple values flow – such as into and out of functions or into branches of a switch or if statement – is not typically enough. Many languages have first class functions. With first class functions, functions are values that themselves can be passed around the program. This means that the flow of a value can depend on the flow of a function and vice versa. This is what we call <strong>Control Flow Analysis</strong>.</p>
<p>Control flow analyses are really expensive, so in practice, they are not often used in compilers. Our aim is to change that. There are theoretic barriers indicating that a full-program flow analysis requires at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> time / space. However we believe that there is a lot of room for improvement in the practicality of control flow analyses, by breaking up the full program into parts of interest and doing a local control flow analysis on demand from there. We believe that this approach can solve many of the flow problems that compilers and users would like answered.</p>
<p>A great paper by Kimball on the topic is <a href="http://kimball.germane.net/germane-2019-dcfa.pdf" target="_blank" rel="noopener noreferrer">Demand Control-Flow Analysis</a>. It is a great read, especially for understanding the approach we are using for part ofmy PhD research.</p>]]></content:encoded>
            <category>static analysis</category>
            <category>flow analysis</category>
            <category>soundness</category>
            <category>completeness</category>
            <category>Demand CFA</category>
        </item>
    </channel>
</rss>