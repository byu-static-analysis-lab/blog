<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.6.0">
<title data-rh="true">Topic - Control Flow Analysis | BYU Static Analysis / Programming Languages Lab</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://byu-static-analysis-lab.github.io/blog/control-flow-analysis"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Topic - Control Flow Analysis | BYU Static Analysis / Programming Languages Lab"><meta data-rh="true" name="description" content="This is a Blog for the BYU Static Analysis Lab"><meta data-rh="true" property="og:description" content="This is a Blog for the BYU Static Analysis Lab"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-11-06T12:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/TimWhiting"><meta data-rh="true" property="article:tag" content="static analysis,flow analysis,soundness,completeness,Demand CFA"><link data-rh="true" rel="icon" href="/blog/img/byu-pl-logo.png"><link data-rh="true" rel="canonical" href="https://byu-static-analysis-lab.github.io/blog/control-flow-analysis"><link data-rh="true" rel="alternate" href="https://byu-static-analysis-lab.github.io/blog/control-flow-analysis" hreflang="en"><link data-rh="true" rel="alternate" href="https://byu-static-analysis-lab.github.io/blog/control-flow-analysis" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://byu-static-analysis-lab.github.io/blog/control-flow-analysis","mainEntityOfPage":"https://byu-static-analysis-lab.github.io/blog/control-flow-analysis","url":"https://byu-static-analysis-lab.github.io/blog/control-flow-analysis","headline":"Topic - Control Flow Analysis","name":"Topic - Control Flow Analysis","description":"This is a Blog for the BYU Static Analysis Lab","datePublished":"2024-11-06T12:00:00.000Z","author":{"@type":"Person","name":"Tim Whiting","description":"Author","url":"https://github.com/TimWhiting","image":"https://github.com/TimWhiting.png"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://byu-static-analysis-lab.github.io/blog/","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="BYU Static Analysis / Programming Languages Lab RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="BYU Static Analysis / Programming Languages Lab Atom Feed">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/blog/assets/css/styles.c721bfac.css">
<script src="/blog/assets/js/runtime~main.1e173575.js" defer="defer"></script>
<script src="/blog/assets/js/main.bca5469d.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/blog/"><div class="navbar__logo"><img src="/blog/img/byu-pl-logo.png" alt="Lab Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/blog/img/byu-pl-logo.png" alt="Lab Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">BYU Static Analysis / PL Lab</b></a><a class="navbar__item navbar__link" href="/blog/docs/Papers/algebraic-effects">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/byu-static-analysis-lab/blog/tree/main/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/fine-grained-reduction-theory-for-effect-handlers">Paper - A General Fine-Grained Reduction Theory for Effect Handlers</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/refocusing-reduction">Paper - Refocusing in Reduction Semantics</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/flow-sensitivity">Topic - Flow Sensitivity</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/abstract-interpretation">Topic - Abstract Interpretation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/galois-transformers">Paper - Galois Transformers and Modular Abstract Interpreters</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/abstracting-abstract-machines">Paper - Abstracting Abstract Machines</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/control-flow-analysis">Topic - Control Flow Analysis</a></li></ul></div></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">Topic - Control Flow Analysis</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-11-06T12:00:00.000Z">November 6, 2024</time> · <!-- -->5 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/TimWhiting" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/TimWhiting.png" alt="Tim Whiting"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/TimWhiting" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Tim Whiting</span></a></div><small class="authorTitle_nd0D" title="Author">Author</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>This is a Blog for the BYU Static Analysis Lab</p>
<p>Dr. Kimball Germane is our advisor at BYU. <a href="https://kimball.germane.net/" target="_blank" rel="noopener noreferrer">https://kimball.germane.net/</a></p>
<p>He has a lot of experience with static analysis, and especially with making control flow analysis practical for real world use.</p>
<p>In this blog post we will introduce static analysis from a few different perspectives.</p>
<p>Click (Read More) below to read the rest of the post.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="tims-thoughts-on-static-control-flow-analysis">Tim&#x27;s Thoughts on Static Control Flow Analysis<a href="#tims-thoughts-on-static-control-flow-analysis" class="hash-link" aria-label="Direct link to Tim&#x27;s Thoughts on Static Control Flow Analysis" title="Direct link to Tim&#x27;s Thoughts on Static Control Flow Analysis">​</a></h2>
<p><strong>Static analysis</strong> is a way to analyze properties about a program without running it. Some properties of a program are restricted by the type system, but
often you want to know a bit more about the program than a type system can tell you. For example, you might want to know if an integer is always positive, or if a function never throws an exception.</p>
<p>While some of these properties can be determined by a more restrictive type system, there is always a tradeoff when you make a type system more restrictive. The more restrictive a type system is, the more difficult it is to write programs that may be valid, but don&#x27;t fit the type system. On the other hand, some type systems are super expressive allowing the programmer to express rich types where types can depend on values (see <a href="https://www.idris-lang.org/" target="_blank" rel="noopener noreferrer">Idris</a> for an example). Both by making a type system more restrictive and by making it more expressive, you completely change the developer experience which can make it much easier or much harder to write programs.</p>
<p>Even with an expressive type system, there are still properties that are interesting to a compiler that the type system is unlikely to help you with. A common example is inlining. Inlining functions can be very beneficial to runtime performance – it can save you the overhead of a function call (though the overhead can be minimal depending on the language you use). Additionally, in the case of higher order functions such as closures, it can save you de/allocation of the closure. Another example of a property that is useful, but not typically expressed in type systems are security properties such as ensuring that secrets within a program are not leaked, and that the program doesn&#x27;t accept any input from the user that could compromise the program.</p>
<p><strong>Flow analysis</strong> is one way of solving many static analysis questions. Essentially the common questions that we ask is about what values can flow to which points in the program. Due to infinite loops, and arbitrary run-time input, we cannot just interpret the program while logging all values of each variable. Instead we really want to know all possible ways the program can execute given <em>any</em> input or path through the program. This is a very difficult problem, and in general is undecidable. However, there are many cases where we can get a good approximation of the answer, and that is what we are interested in. There are many ways of approximating the solution to this problem, but what we are interested in is a <em>sound</em> solution. For the solution to be <em>sound</em> it means that we need to consider all possible executions of the program. Because it is an approximation we can either underestimate all possible executions (leaving out some possibilities) or overestimate all possible executions (including some possibilities that are in reality not possible). We are interested in the latter case, because we want to be sure that we are not missing any possible execution paths. If we don&#x27;t consider all possible executions that could mean that our analysis is <em>unsound</em>, for example it might say that a value is always positive, when in reality it could be negative. You could imagine that it might be useful to know when something has to happen, in which case you would want a <em>complete</em> analysis. A complete analysis guarantees that if it says something happens then it really does. Soundness and completeness are not opposites, but they are both useful properties to think about when discussing formal reasoning systems.
Flow analysis starts with a sound analysis and much of the research focuses on how to make the analyses more <em>precise</em> (complete).</p>
<p>However just following where simple values flow – such as into and out of functions or into branches of a switch or if statement – is not typically enough. Many languages have first class functions. With first class functions, functions are values that themselves can be passed around the program. This means that the flow of a value can depend on the flow of a function and vice versa. This is what we call <strong>Control Flow Analysis</strong>.</p>
<p>Control flow analyses are really expensive, so in practice, they are not often used in compilers. Our aim is to change that. There are theoretic barriers indicating that a full-program flow analysis requires at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> time / space. However we believe that there is a lot of room for improvement in the practicality of control flow analyses, by breaking up the full program into parts of interest and doing a local control flow analysis on demand from there. We believe that this approach can solve many of the flow problems that compilers and users would like answered.</p>
<p>A great paper by Kimball on the topic is <a href="http://kimball.germane.net/germane-2019-dcfa.pdf" target="_blank" rel="noopener noreferrer">Demand Control-Flow Analysis</a>. It is a great read, especially for understanding the approach we are using for part ofmy PhD research.</p></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/static-analysis">static analysis</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/flow-analysis">flow analysis</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/soundness">soundness</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/completeness">completeness</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/demand-cfa">Demand CFA</a></li></ul></div></div><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><a href="https://github.com/byu-static-analysis-lab/blog/tree/main/blog/2024-11-control-flow-analysis.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/abstracting-abstract-machines"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">Paper - Abstracting Abstract Machines</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#tims-thoughts-on-static-control-flow-analysis" class="table-of-contents__link toc-highlight">Tim&#39;s Thoughts on Static Control Flow Analysis</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/byu-static-analysis-lab/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 BYU Static Analysis. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>