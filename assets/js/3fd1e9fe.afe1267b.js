"use strict";(self.webpackChunkdev_blog=self.webpackChunkdev_blog||[]).push([[168],{6882:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var i=n(3466),s=n(4848),a=n(8453);const r={slug:"flow-sensitivity",title:"Topic - Flow Sensitivity",data:"2024-11-07T12:00",authors:["koby"],tags:["static analysis","flow analysis","abstract interpretation"]},o=void 0,c={authorsImageUrls:[void 0]},l=[];function h(e){const t={a:"a",code:"code",em:"em",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:['There are (at least) three different "sensitivities" an ',(0,s.jsx)(t.a,{href:"/blog/abstract-interpretation",children:"abstract analysis"})," can have:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"flow insensitive"}),"\n",(0,s.jsx)(t.li,{children:"flow sensitive"}),"\n",(0,s.jsx)(t.li,{children:"path sensitive"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This article briefly describes the difference between them."}),"\n",(0,s.jsx)(t.p,{children:"One form of abstract analysis is a type check."}),"\n",(0,s.jsx)(t.p,{children:"Consider this typescript program:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'function myFunc(x : string | number) {\n  let y;\n  if (x === 0) {\n    y = 0; // a\n  } else {\n    y = "some string"; // b\n  }\n\n  if (x === 0) {\n    console.log(y); // c\n  } else {\n    console.log(y + y); // d\n  }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["What is the type of ",(0,s.jsx)(t.code,{children:"x"})," at point ",(0,s.jsx)(t.code,{children:"a"})," in the program? Many type checkers would simply report ",(0,s.jsx)(t.code,{children:"string | number"}),", but TypeScript's type checker is smart enough to know that it is ",(0,s.jsx)(t.code,{children:"number"})," here, based on the check ",(0,s.jsx)(t.code,{children:"x === 0"}),", which can only be true if ",(0,s.jsx)(t.code,{children:"x"})," is a number. This is because TypeScript's type checker is ",(0,s.jsx)(t.em,{children:"flow sensitive"}),", while many other type checkers are ",(0,s.jsx)(t.em,{children:"flow insensitive"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Now, what is the type of ",(0,s.jsx)(t.code,{children:"y"})," at point ",(0,s.jsx)(t.code,{children:"c"})," in the program? We can inspect it and know that if we got to point ",(0,s.jsx)(t.code,{children:"c"}),", then ",(0,s.jsx)(t.code,{children:"x === 0"})," is true, and earlier we must have gone through point ",(0,s.jsx)(t.code,{children:"a"}),". This means that ",(0,s.jsx)(t.code,{children:"y"})," must be ",(0,s.jsx)(t.code,{children:"number"}),", since it was assigned ",(0,s.jsx)(t.code,{children:"0"}),". However, TypeScript still just reports ",(0,s.jsx)(t.code,{children:"number | string"}),". This is because, TypeScript's type checker is ",(0,s.jsx)(t.em,{children:"not"})," path-sensitive. Our analysis that we did manually ",(0,s.jsx)(t.em,{children:"was"})," path-sensitive."]}),"\n",(0,s.jsxs)(t.p,{children:["So, in order of specificity, we have flow-insensitive < flow-sensitive < path-sensitive. Flow-insensitive analyses collect facts that are true at any point in the program. It is always true to say that ",(0,s.jsx)(t.code,{children:"x : string | number"})," and ",(0,s.jsx)(t.code,{children:"y : string | number"}),". Flow-sensitive analyses associate facts with particular points in the program, but do not distinguish how you got there. At point ",(0,s.jsx)(t.code,{children:"c"})," in the program, it is always true to say that ",(0,s.jsx)(t.code,{children:"x : number"})," and ",(0,s.jsx)(t.code,{children:"y : string | number"})," (we can't say anything more specific about ",(0,s.jsx)(t.code,{children:"y"})," because we don't know if we went through point ",(0,s.jsx)(t.code,{children:"a"})," or ",(0,s.jsx)(t.code,{children:"b"}),"). Path-sensitivity associates facts with points in the program ",(0,s.jsx)(t.em,{children:"and how you got there"}),', or "path". It is always true to say that at point ',(0,s.jsx)(t.code,{children:"c"}),", given you went through point ",(0,s.jsx)(t.code,{children:"a"}),", that ",(0,s.jsx)(t.code,{children:"x : number"})," and ",(0,s.jsx)(t.code,{children:"y : number"}),", and there are no flows that reach point ",(0,s.jsx)(t.code,{children:"c"})," except those that also previously reach ",(0,s.jsx)(t.code,{children:"a"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}},3466:e=>{e.exports=JSON.parse('{"permalink":"/blog/flow-sensitivity","editUrl":"https://github.com/byu-static-analysis-lab/blog/tree/main/blog/2024-11-flow-sensitivity.md","source":"@site/blog/2024-11-flow-sensitivity.md","title":"Topic - Flow Sensitivity","description":"There are (at least) three different \\"sensitivities\\" an abstract analysis can have:","date":"2024-11-07T19:17:45.000Z","tags":[{"inline":true,"label":"static analysis","permalink":"/blog/tags/static-analysis"},{"inline":true,"label":"flow analysis","permalink":"/blog/tags/flow-analysis"},{"inline":true,"label":"abstract interpretation","permalink":"/blog/tags/abstract-interpretation"}],"readingTime":1.985,"hasTruncateMarker":true,"authors":[{"name":"Koby Lewis","title":"Author","url":"https://github.com/plyb","imageURL":"https://github.com/plyb.png","key":"koby","page":null}],"frontMatter":{"slug":"flow-sensitivity","title":"Topic - Flow Sensitivity","data":"2024-11-07T12:00","authors":["koby"],"tags":["static analysis","flow analysis","abstract interpretation"]},"unlisted":false,"prevItem":{"title":"Paper - Refocusing in Reduction Semantics","permalink":"/blog/refocusing-reduction"},"nextItem":{"title":"Topic - Abstract Interpretation","permalink":"/blog/abstract-interpretation"}}')}}]);