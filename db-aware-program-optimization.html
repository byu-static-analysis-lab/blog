<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.6.0">
<title data-rh="true">Paper - Database-Aware Program Optimization via Static Analysis | BYU Static Analysis / Programming Languages Lab</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Paper - Database-Aware Program Optimization via Static Analysis | BYU Static Analysis / Programming Languages Lab"><meta data-rh="true" name="description" content="A lot of developer work on database applications goes into making sure the interaction between the application layer and the database layer is efficient. In my experience in industry, this work is mostly done manually, and in an ad-hoc fashion. [@ramachandra2014database] give an account about some ways this can be done manually."><meta data-rh="true" property="og:description" content="A lot of developer work on database applications goes into making sure the interaction between the application layer and the database layer is efficient. In my experience in industry, this work is mostly done manually, and in an ad-hoc fashion. [@ramachandra2014database] give an account about some ways this can be done manually."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-11-18T12:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/plyb"><meta data-rh="true" property="article:tag" content="paper,optimization,database,api coalescing"><link data-rh="true" rel="icon" href="/blog/img/byu-pl-logo.png"><link data-rh="true" rel="canonical" href="https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization"><link data-rh="true" rel="alternate" href="https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization" hreflang="en"><link data-rh="true" rel="alternate" href="https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization","mainEntityOfPage":"https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization","url":"https://byu-static-analysis-lab.github.io/blog/db-aware-program-optimization","headline":"Paper - Database-Aware Program Optimization via Static Analysis","name":"Paper - Database-Aware Program Optimization via Static Analysis","description":"A lot of developer work on database applications goes into making sure the interaction between the application layer and the database layer is efficient. In my experience in industry, this work is mostly done manually, and in an ad-hoc fashion. [@ramachandra2014database] give an account about some ways this can be done manually.","datePublished":"2024-11-18T12:00:00.000Z","author":{"@type":"Person","name":"Koby Lewis","description":"Author","url":"https://github.com/plyb","image":"https://github.com/plyb.png"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://byu-static-analysis-lab.github.io/blog/","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="BYU Static Analysis / Programming Languages Lab RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="BYU Static Analysis / Programming Languages Lab Atom Feed">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/blog/assets/css/styles.c721bfac.css">
<script src="/blog/assets/js/runtime~main.0d1c29bf.js" defer="defer"></script>
<script src="/blog/assets/js/main.70a6ca2b.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/blog/"><div class="navbar__logo"><img src="/blog/img/byu-pl-logo.png" alt="Lab Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/blog/img/byu-pl-logo.png" alt="Lab Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">BYU Static Analysis / PL Lab</b></a><a class="navbar__item navbar__link" href="/blog/docs/Papers/algebraic-effects">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/byu-static-analysis-lab/blog/tree/main/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/db-aware-program-optimization">Paper - Database-Aware Program Optimization via Static Analysis</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/fine-grained-reduction-theory-for-effect-handlers">Paper - A General Fine-Grained Reduction Theory for Effect Handlers</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/refocusing-reduction">Paper - Refocusing in Reduction Semantics</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/flow-sensitivity">Topic - Flow Sensitivity</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/abstract-interpretation">Topic - Abstract Interpretation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/galois-transformers">Paper - Galois Transformers and Modular Abstract Interpreters</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/abstracting-abstract-machines">Paper - Abstracting Abstract Machines</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/control-flow-analysis">Topic - Control Flow Analysis</a></li></ul></div></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">Paper - Database-Aware Program Optimization via Static Analysis</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-11-18T12:00:00.000Z">November 18, 2024</time> · <!-- -->4 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/plyb" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/plyb.png" alt="Koby Lewis"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/plyb" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Koby Lewis</span></a></div><small class="authorTitle_nd0D" title="Author">Author</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>A lot of developer work on database applications goes into making sure the interaction between the application layer and the database layer is efficient. In my experience in industry, this work is mostly done manually, and in an ad-hoc fashion. <span id="citation--ramachandra2014database--1">(Ramachandra and Guravannavar 2014)</span> give an account about some ways this can be done manually.</p>
<p>There are two major methods they talk about in the paper. They are as follows:</p>
<ol>
<li>Set-oriented query execution: this technique gathers multiple queries together (they specifically reference queries made in a loop) and combines them into a single query whose results can be broken up and used as if they were single queries. Their technique relies on a program transformation which breaks the loop into two loops, one of which adds the individual queries to the batch, and one which consumes the results of that batch.</li>
<li>Asynchronous Prefetching: this technique tries to move queries as early as possible in the program, so that you can overlap the network latency and computation at the database layer with the computation on the application layer. Optionally, you can batch these queries using technique 1. They also discuss ways to do prefetching in more complicated scenarios, such as when the query is made inside nested procedures.</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="kobys-thoughts">Koby&#x27;s thoughts<a href="#kobys-thoughts" class="hash-link" aria-label="Direct link to Koby&#x27;s thoughts" title="Direct link to Koby&#x27;s thoughts">​</a></h2>
<p>This paper identifies precisely the problem that I&#x27;ve been thinking about, which is how to optimize programs when you know things both about the program and the database schema. More generally, if you have some way to combine api calls that can reduce overhead of some kind, can we find an automated way to do so? However, the paper relies on two broad techniques to solve this: program transformations and (database-aware) compiler optimizations, both of which I see problems with.</p>
<p>While, generally speaking, program transformations may be alright, I feel that those presented in the paper, such as the loop fission technique that is at the core of almost everything they discuss, are very invasive. They would end up producing code that is difficult to read and maintain (especially if multiple devs implement separate loop fissions, leading to nested loops). The authors themselves point out that this is especially a problem when dealing with queries made in nested procedures. (On the topic of nested procedures, they don&#x27;t describe the full technique, but instead refer to an earlier paper, which I am curious to read).</p>
<p>Compiler optimizations are also risky because they make implicit a very important aspect of the program, the algorithms that determine its speed. If these techniques are not universally (or nearly universally) applicable, it would be easy for an inexperienced developer to make a change that causes a serious performance regression without ever realizing. Why am I worried about this and not other compiler optimizations? My ideas are not fully formed on this yet, but I think one aspect is just how important things like network latency are to the performance of an application.</p>
<p>So an ideal technique for me would be one that leaves the code mostly intact as the developer wrote it (which, hopefully, would mean it would be more readable and maintainable), but which also has an explicit reference at some point to how the optimization is taking place. It would also be very difficult to accidentally cause a serious performance regression in the technique, or at least there would be a way to warn the developer if they have.</p>
<p>A few thoughts about where to go from here:</p>
<ol>
<li>CFA seems like a promising technique to help with the nested procedure problem, but I&#x27;d like to read more about their solution first.</li>
<li>Algebraic effects could provide a really solid way to provide for batching while still leaving a trace in the code that isn&#x27;t too intrusive. However, I can&#x27;t think of how you could do prefetching using algebraic effects.</li>
<li>The paper mentions that their techniques could potentially be broadened to other domains where significant overhead exists besides databases. It could be interesting to explore a technique that could generalize to all of these.</li>
</ol>
<div id="refs" class="references csl-bib-body">
  <div class="csl-entry" id="bib-ramachandra2014database">Karthik Ramachandra, and Ravindra Guravannavar. “Database-Aware Program Optimization via Static Analysis.” <i>IEEE Data Eng. Bull.</i> 37 (1). Citeseer: 60–69. 2014.</div>
</div></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/paper">paper</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/optimization">optimization</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/database">database</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/api-coalescing">api coalescing</a></li></ul></div></div><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><a href="https://github.com/byu-static-analysis-lab/blog/tree/main/blog/2024-11-db-aware-program-optimization.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/fine-grained-reduction-theory-for-effect-handlers"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">Paper - A General Fine-Grained Reduction Theory for Effect Handlers</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#kobys-thoughts" class="table-of-contents__link toc-highlight">Koby&#39;s thoughts</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/byu-static-analysis-lab/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 BYU Static Analysis. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>