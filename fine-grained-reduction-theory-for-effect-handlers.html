<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.6.0">
<title data-rh="true">Paper - A General Fine-Grained Reduction Theory for Effect Handlers | BYU Static Analysis / Programming Languages Lab</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Paper - A General Fine-Grained Reduction Theory for Effect Handlers | BYU Static Analysis / Programming Languages Lab"><meta data-rh="true" name="description" content="A General Fine-Grained Reduction Theory for Effect Handlers [@sieczkowskigeneral2023]"><meta data-rh="true" property="og:description" content="A General Fine-Grained Reduction Theory for Effect Handlers [@sieczkowskigeneral2023]"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-11-08T12:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/TimWhiting"><meta data-rh="true" property="article:tag" content="paper,abstract interpreters,reduction semantics,effect handlers,abstract machine"><link data-rh="true" rel="icon" href="/blog/img/byu-pl-logo.png"><link data-rh="true" rel="canonical" href="https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers"><link data-rh="true" rel="alternate" href="https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers" hreflang="en"><link data-rh="true" rel="alternate" href="https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers","mainEntityOfPage":"https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers","url":"https://byu-static-analysis-lab.github.io/blog/fine-grained-reduction-theory-for-effect-handlers","headline":"Paper - A General Fine-Grained Reduction Theory for Effect Handlers","name":"Paper - A General Fine-Grained Reduction Theory for Effect Handlers","description":"A General Fine-Grained Reduction Theory for Effect Handlers [@sieczkowskigeneral2023]","datePublished":"2024-11-08T12:00:00.000Z","author":{"@type":"Person","name":"Tim Whiting","description":"Author","url":"https://github.com/TimWhiting","image":"https://github.com/TimWhiting.png"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://byu-static-analysis-lab.github.io/blog/","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="BYU Static Analysis / Programming Languages Lab RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="BYU Static Analysis / Programming Languages Lab Atom Feed">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/blog/assets/css/styles.c721bfac.css">
<script src="/blog/assets/js/runtime~main.fc6b4e0b.js" defer="defer"></script>
<script src="/blog/assets/js/main.0a5a6d2f.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?t("light"):t("dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/blog/"><div class="navbar__logo"><img src="/blog/img/byu-pl-logo.png" alt="Lab Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/blog/img/byu-pl-logo.png" alt="Lab Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">BYU Static Analysis / PL Lab</b></a><a class="navbar__item navbar__link" href="/blog/docs/Papers/algebraic-effects">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/byu-static-analysis-lab/blog/tree/main/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/query-by-synthesis">Paper - Optimizing Database-Backed Applications with Query Synthesis</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/db-aware-program-optimization">Paper - Database-Aware Program Optimization via Static Analysis</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/fine-grained-reduction-theory-for-effect-handlers">Paper - A General Fine-Grained Reduction Theory for Effect Handlers</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/refocusing-reduction">Paper - Refocusing in Reduction Semantics</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/flow-sensitivity">Topic - Flow Sensitivity</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/abstract-interpretation">Topic - Abstract Interpretation</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/galois-transformers">Paper - Galois Transformers and Modular Abstract Interpreters</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/abstracting-abstract-machines">Paper - Abstracting Abstract Machines</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/control-flow-analysis">Topic - Control Flow Analysis</a></li></ul></div></nav></aside><main class="col col--7"><article><header><h1 class="title_f1Hy">Paper - A General Fine-Grained Reduction Theory for Effect Handlers</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-11-08T12:00:00.000Z">November 8, 2024</time> · <!-- -->4 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/TimWhiting" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/TimWhiting.png" alt="Tim Whiting"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/TimWhiting" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Tim Whiting</span></a></div><small class="authorTitle_nd0D" title="Author">Author</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>A General Fine-Grained Reduction Theory for Effect Handlers <span id="citation--sieczkowski_general_2023--1">(Sieczkowski et al. 2023)</span>
presents a theory of effect handlers that can be used for term rewriting systems,
and provides a few different abstract machines for effect handlers.</p>
<p>A significant contribution of this paper I believe is that it provides
a top down small-step semantics for effect handlers, which is a bit unusual.</p>
<p>One disadvantages of most reduction semantics for effect handlers is that
they require being able to capture a reduction context itself as a term in the language.
This is easy to understand in principle, but makes the reduction semantics
hard to translate into an abstract machine.</p>
<p>The fine-grained reduction theory presented in this paper makes it easy to apply the
normal refocusing method to come up with an abstract machine for algebraic effects (see <a href="/blog/refocusing-reduction">this paper</a>).</p>
<p>The crux of the idea is that continuations can either be built from the top-down or the bottom-up.</p>
<p>Typical reduction semantics for algebraic effects capture the reduction context and wrap it in a closure to plug the context. This is effectively a bottom-up approach.</p>
<p>For example in Generalized Evidence Passing for Effect Handlers <span id="citation--xie_generalized_2021--2">(Xie and Leijen 2021)</span>,
Koka&#x27;s evaluation rules look as follows:</p>
<span class="katex-display fleqn"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>a</mi><mi>p</mi><mi>p</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mi>e</mi><mo stretchy="false">)</mo><mi>v</mi><mo>⟶</mo><mi>e</mi><mo stretchy="false">[</mo><mi>x</mi><mo>:</mo><mo>=</mo><mi>v</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>h</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>l</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext mathvariant="monospace">handler</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>f</mi><mo>⟶</mo><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext>  </mtext><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>v</mi><mo>⟶</mo><mi>v</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>e</mi><mi>r</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mo stretchy="false">)</mo><mtext>  </mtext><mtext>  </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>E</mi><mo stretchy="false">[</mo><mtext mathvariant="monospace">perform</mtext><mtext>  </mtext><mi>o</mi><mi>p</mi><mtext>  </mtext><mi>v</mi><mo stretchy="false">]</mo><mo>⟶</mo><mi>f</mi><mtext>  </mtext><mi>v</mi><mtext>  </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mtext>  </mtext><mtext mathvariant="monospace">handle</mtext><mtext>  </mtext><mi>h</mi><mtext>  </mtext><mi>E</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mtext>  </mtext><mtext mathvariant="monospace">iff</mtext><mtext>  </mtext><mi>o</mi><mi>p</mi><mo mathvariant="normal">∉</mo><mi>b</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>o</mi><mi>p</mi><mo>⟼</mo><mi>f</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>h</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
(app)\;\; &amp;(λx.\; e) v ⟶ e[x:=v]  \\
(handler)\;\; &amp;\texttt{handler}\; h\; f ⟶ \texttt{handle}\; h\; (f\; ()) \\
(return)\;\; &amp;\texttt{handle}\; h\; v ⟶ v  \\
(perform)\;\; &amp;\texttt{handle}\; h\; E[\texttt{perform}\; op\; v] ⟶ 
  f\; v\; (λx.\; \texttt{handle}\; h\; E[x])\; \texttt{iff}\; op \notin bop(E) ∧ (op ⟼ f)  \in h
\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em"><span style="top:-5.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">pp</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">han</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal" style="margin-right:0.02778em">er</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span><span style="top:-2.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span><span style="top:-0.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em">er</span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mord mathnormal" style="margin-right:0.02778em">or</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mspace" style="margin-right:0.2778em"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em"><span style="top:-5.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">e</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">:=</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mclose">]</span></span></span><span style="top:-3.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord texttt">handler</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mopen">(</span><span class="mclose">))</span></span></span><span style="top:-2.41em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span><span style="top:-0.91em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mopen">[</span><span class="mord text"><span class="mord texttt">perform</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟶</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord text"><span class="mord texttt">handle</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord text"><span class="mord texttt">iff</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">⟼</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mord mathnormal">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>In this we can see the caputring of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.05764em">E</span></span></span></span> and wrapping up in a lambda to build the continuation.
Additionally we see the nature of <code>deep</code> effect handlers where the continuation reinstates
the handler frame on top of the evaluation context.</p>
<p>While later in the Koka paper they present a monad for building up the continuation piece by piece, this is still a bottom-up treatment and composition of elementary evaluation contexts.</p>
<p>Instead the top down treatment presented in this paper, builds the continuation on the way down, and only uses lambda functions.</p>
<p>The abstract machine presented in the paper is pretty straightforward, though as mentioned in the paper it is a <code>hybrid</code> machine because the context changes how evaluation proceeds. In particular
evaluation changes depending on whether it is in the context of one or more handlers, versus if it is finishing up a computation in the top level continuation.</p>
<p>Later they introduce a similarity relation to equate terms in the fine-grained calculus and a normal calculus. This part is pretty involved since the rewriting of handlers in the fine-grained calculus ends up changing a lot of terms, and the capturing of a resumption in the regular calculus introduces an eta expansion for the application.</p>
<p>Next they present three core proofs: Simulation, Confluence, and Standardization.</p>
<p>Simulation states that it doesn&#x27;t matter whether you use the fine-grained or non-local semantics you get the same result. i.e. fine-grained simulates non-local and vice versa. One step in one either could correspond to many steps in the other, so you have to consider the transitive closure. Additionally the similarity relation is needed since the terms could look different but be syntactically or otherwise equivalent.</p>
<p>Confluence of the relation is the diamond property meaning that if an expression reduces to two different expressions, then there exists an expression that each of those expressions can reduce further to.</p>
<p>Standardization states the any reduction sequence that reaches head-normal form can be split into a sequence that reaches a normal form followed by an internal reduction sequence. This is tricky with effect handlers due to the hybrid nature of the semantics in which let and lift behave differently depending if a handler surrounds them.</p>
<p>Using those proofs they show that the reduction theory is a foundation for an equational theory which is sound with respect to the non-local semantics. In other words, rewriting pieces of programs using this theory will result in the same program, even if you switch back to a non-local semantics to execute the rest.</p>
<div id="refs" class="references csl-bib-body">
  <div class="csl-entry" id="bib-sieczkowski_general_2023">Filip Sieczkowski, Mateusz Pyzik, and Dariusz Biernacki. “A General Fine-Grained Reduction Theory for Effect Handlers.” <i>Proceedings of the ACM on Programming Languages</i> 7 (ICFP): 511–540. 2023. Publisher: ACM New York, NY, USA.</div>
  <div class="csl-entry" id="bib-xie_generalized_2021">Ningning Xie, and Daan Leijen. “Generalized Evidence Passing for Effect Handlers.” <i>Microsoft Research. Extended Version with Proofs</i>. 2021.</div>
</div></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/paper">paper</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/abstract-interpreters">abstract interpreters</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/reduction-semantics">reduction semantics</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/effect-handlers">effect handlers</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/abstract-machine">abstract machine</a></li></ul></div></div><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><a href="https://github.com/byu-static-analysis-lab/blog/tree/main/blog/2024-11-fine-grained-reduction-theory-for-effect-handlers.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/db-aware-program-optimization"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">Paper - Database-Aware Program Optimization via Static Analysis</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/refocusing-reduction"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">Paper - Refocusing in Reduction Semantics</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/byu-static-analysis-lab/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 BYU Static Analysis. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>