"use strict";(self.webpackChunkdev_blog=self.webpackChunkdev_blog||[]).push([[3395],{4641:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>o});var t=n(4694),a=n(4848),i=n(8453);const r={slug:"refocusing-reduction",title:"Paper - Refocusing in Reduction Semantics",date:"2024-11-08T12:00",authors:["tim"],tags:["paper","abstract interpreters","reduction semantics"]},c=void 0,l={authorsImageUrls:[void 0]},o=[{value:"Reduction Semantics",id:"reduction-semantics",level:3},{value:"Deriving An Abstract Machine",id:"deriving-an-abstract-machine",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const s={admonition:"admonition",annotation:"annotation",blockquote:"blockquote",code:"code",div:"div",em:"em",h2:"h2",h3:"h3",i:"i",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",semantics:"semantics",span:"span",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.p,{children:["Refocusing in Reduction Semantics ",(0,a.jsx)(s.span,{className:"",id:"citation--danvy_refocusing_2004--1",children:"(Danvy and Nielsen Nov. 2004)"})," presents a way to go from\na reduction semantics to an recfocused pre-abstract machine, and eventually to an abstract machine. The paper is a good read after being introduced to reduction semantics and abstract machines, and has a few simple walkthroughs of how to actually apply the theory."]}),"\n",(0,a.jsx)(s.p,{children:"The goal of this paper is to systematize the development of abstract machines based on\na reduction semantics."}),"\n",(0,a.jsx)(s.h3,{id:"reduction-semantics",children:"Reduction Semantics"}),"\n",(0,a.jsx)(s.p,{children:"Reduction semantics involve three distinct steps:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"decompose"}),": rules for breaking apart expressions into a term that can be reduced and its surrounding evaluation contexts (aka reduction contexts)"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"reduction"})," / ",(0,a.jsx)(s.code,{children:"contraction"}),": rules for how a term should be reduced"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"plug"}),": rules for how to recompose a full program expression given an evaluation context and a term"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"In reduction semantics some terms are considered fully reduced (values), and others can be decomposed. In general a term can be decomposed in many ways, however"}),"\n",(0,a.jsxs)(s.p,{children:["Often reduction semantics satisfy the property that there is a unique ",(0,a.jsx)(s.em,{children:"complete"})," decomposition. A decomposition is ",(0,a.jsx)(s.em,{children:"complete"})," iff the term it decomposes into a term that is trivially reducible (not a value, and not itself containing a complete decomposition). For example, the call-by-value simple lambda calculus semantics has the following reduction contexts"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"C"}),(0,a.jsx)(s.mo,{children:":"}),(0,a.jsx)(s.mo,{children:":"}),(0,a.jsx)(s.mo,{children:"="}),(0,a.jsx)(s.mo,{stretchy:"false",children:"["}),(0,a.jsx)(s.mo,{stretchy:"false",children:"]"}),(0,a.jsx)(s.mo,{children:"\u2223"}),(0,a.jsx)(s.mi,{children:"a"}),(0,a.jsx)(s.mi,{children:"p"}),(0,a.jsx)(s.mi,{children:"p"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsx)(s.mi,{children:"C"}),(0,a.jsx)(s.mo,{separator:"true",children:","}),(0,a.jsx)(s.mi,{children:"t"}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"}),(0,a.jsx)(s.mo,{children:"\u2223"}),(0,a.jsx)(s.mi,{children:"a"}),(0,a.jsx)(s.mi,{children:"p"}),(0,a.jsx)(s.mi,{children:"p"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"("}),(0,a.jsx)(s.mi,{children:"v"}),(0,a.jsx)(s.mo,{separator:"true",children:","}),(0,a.jsx)(s.mi,{children:"C"}),(0,a.jsx)(s.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"C ::= [] \\mid app(C,t) \\mid app(v,C)"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(s.span,{className:"mrel",children:"::="}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mopen",children:"["}),(0,a.jsx)(s.span,{className:"mclose",children:"]"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(s.span,{className:"mrel",children:"\u2223"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"a"}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"pp"}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,a.jsx)(s.span,{className:"mpunct",children:","}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"t"}),(0,a.jsx)(s.span,{className:"mclose",children:")"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(s.span,{className:"mrel",children:"\u2223"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"a"}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"pp"}),(0,a.jsx)(s.span,{className:"mopen",children:"("}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"}),(0,a.jsx)(s.span,{className:"mpunct",children:","}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,a.jsx)(s.span,{className:"mclose",children:")"})]})]})]})}),"\n",(0,a.jsxs)(s.p,{children:["where ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"C"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"C"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"})]})})]})," denotes a reduction context, ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"t"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"t"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6151em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"t"})]})})]})," a term, and ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsx)(s.mi,{children:"v"})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"v"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"v"})]})})]})," a value, with ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mo,{stretchy:"false",children:"["}),(0,a.jsx)(s.mo,{stretchy:"false",children:"]"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"[]"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mopen",children:"["}),(0,a.jsx)(s.span,{className:"mclose",children:"]"})]})})]})," being a hole."]}),"\n",(0,a.jsxs)(s.p,{children:["Crucially the restriction on the first term of the ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mi,{children:"a"}),(0,a.jsx)(s.mi,{children:"p"}),(0,a.jsx)(s.mi,{children:"p"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"app"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"a"}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"pp"})]})})]})," being either an evaluation context, or a value makes this decomposition unique and specifies a left-to-right evaluation order."]}),"\n",(0,a.jsx)(s.h3,{id:"deriving-an-abstract-machine",children:"Deriving An Abstract Machine"}),"\n",(0,a.jsx)(s.p,{children:"Given this property, the paper shows how to derive an abstract machine from it."}),"\n",(0,a.jsxs)(s.p,{children:["Intuitively, instead of finding the decomposition and replugging after every step, we can\ninstead traverse the reduction contexts of the previous decomposition to find the next\nreduction step and recompose the evaluation contexts to obtain the new evaluation context.\nIn this way we can merge all intermediate steps of ",(0,a.jsx)(s.code,{children:"plug"})," followed by ",(0,a.jsx)(s.code,{children:"reduction"}),". The paper\ncalls this the ",(0,a.jsx)(s.code,{children:"refocus"})," step."]}),"\n",(0,a.jsxs)(s.p,{children:["After merging ",(0,a.jsx)(s.code,{children:"plug"})," and ",(0,a.jsx)(s.code,{children:"reduction"}),", the only thing that we need to get rid of is to inline the ",(0,a.jsx)(s.code,{children:"refocus"})," step itself to get a properly tail recursive abstract machine."]}),"\n",(0,a.jsxs)(s.p,{children:["Of course the paper goes into more detail, and considers two separate ",(0,a.jsx)(s.code,{children:"refocus"})," functions, one\nwhich applies when the expression reduces to another potential redux, and another when it reduces to a value.\nAfter inlining both, the differences don't exactly matter, since they are now just part of the machine transitions.\nHowever, it is useful to understand how the machine is derived, since you don't always have an abstract machine, but do know how to select the next statement to reduce."]}),"\n",(0,a.jsx)(s.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(s.p,{children:"The conclusion of the paper states:"}),"\n",(0,a.jsxs)(s.blockquote,{children:["\n",(0,a.jsx)(s.p,{children:"We have presented a structural result about reduction semantics with context-free grammars of values, reduction contexts, and redexes, and satisfying a unique-decomposition property. These conditions are quite general: they hold for deterministic languages and also for oracle-based non-deterministic languages."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"I appreciate the examples that they showed to make this claim more concrete - instead of solely in terms of context-free grammars, but it is nice to know that there is very little syntactic restrictions, and that the conditions for applying it are rather general."}),"\n",(0,a.jsxs)(s.blockquote,{children:["\n",(0,a.jsx)(s.p,{children:"The construction of the refocus function suggests a convenient definition of the decompose function that directly connects one-step reduction and evaluation in the form of an abstract machine. It also suggests a practical method to obtain a reduction semantics out of an abstract machine."}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["I wish they spent more time connecting this - how to go in the reverse direction. It is also interesting that they don't talk about the restriction to ",(0,a.jsx)(s.code,{children:"one-step"})," reductions. Is that a restriction only going in the reverse, or is it a restriction in the forward direction as well."]}),"\n",(0,a.jsxs)(s.admonition,{type:"note",children:[(0,a.jsx)(s.p,{children:"A many step strategy is apparently one in which a whole set of redexes is contracted simultaneously"}),(0,a.jsx)(s.p,{children:"As such, the restriction makes sense and I believe applies in both directions. What would an abstract machine that performs multiple steps simultaneously even look like?"})]}),"\n",(0,a.jsxs)(s.div,{id:"refs",className:"references csl-bib-body",children:["\n  ",(0,a.jsxs)(s.div,{className:"csl-entry",id:"bib-danvy_refocusing_2004",children:["Olivier Danvy, and Lasse R. Nielsen. \u201cRefocusing in Reduction Semantics.\u201d ",(0,a.jsx)(s.i,{children:"BRICS Report Series"})," 11 (26). Nov. 2004. doi:10.7146/brics.v11i26.21851."]}),"\n"]})]})}function m(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>c});var t=n(6540);const a={},i=t.createContext(a);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:s},e.children)}},4694:e=>{e.exports=JSON.parse('{"permalink":"/blog/refocusing-reduction","editUrl":"https://github.com/byu-static-analysis-lab/blog/tree/main/blog/2024-11-refocusing-reduction.md","source":"@site/blog/2024-11-refocusing-reduction.md","title":"Paper - Refocusing in Reduction Semantics","description":"Refocusing in Reduction Semantics [@danvyrefocusing2004] presents a way to go from","date":"2024-11-08T12:00:00.000Z","tags":[{"inline":true,"label":"paper","permalink":"/blog/tags/paper"},{"inline":true,"label":"abstract interpreters","permalink":"/blog/tags/abstract-interpreters"},{"inline":true,"label":"reduction semantics","permalink":"/blog/tags/reduction-semantics"}],"readingTime":3.435,"hasTruncateMarker":true,"authors":[{"name":"Tim Whiting","title":"Author","url":"https://github.com/TimWhiting","imageURL":"https://github.com/TimWhiting.png","key":"tim","page":null}],"frontMatter":{"slug":"refocusing-reduction","title":"Paper - Refocusing in Reduction Semantics","date":"2024-11-08T12:00","authors":["tim"],"tags":["paper","abstract interpreters","reduction semantics"]},"unlisted":false,"prevItem":{"title":"Paper - A General Fine-Grained Reduction Theory for Effect Handlers","permalink":"/blog/fine-grained-reduction-theory-for-effect-handlers"},"nextItem":{"title":"Topic - Flow Sensitivity","permalink":"/blog/flow-sensitivity"}}')}}]);